"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name3 in all)
    __defProp(target, name3, { get: all[name3], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var setupMSSQL_exports = {};
__export(setupMSSQL_exports, {
  setupMSSQL: () => setupMSSQL,
  tearDownMSSQL: () => tearDownMSSQL
});
module.exports = __toCommonJS(setupMSSQL_exports);
var import_chunk_MXIGSN4X = require("../chunk-MXIGSN4X.js");
var import_chunk_NTREA7ZR = require("../chunk-NTREA7ZR.js");
var import_chunk_QEHB4OUG = require("../chunk-QEHB4OUG.js");
var import_chunk_IETRW24Z = require("../chunk-IETRW24Z.js");
var import_chunk_FVJ3R4NJ = require("../chunk-FVJ3R4NJ.js");
var import_crypto = __toESM(require("crypto"));
var import_http = __toESM(require("http"));
var import_https = __toESM(require("https"));
var import_crypto2 = __toESM(require("crypto"));
var import_util = __toESM(require("util"));
var import_os = require("os");
var os = __toESM(require("os"));
var import_util2 = require("util");
var http2 = __toESM(require("http"));
var https2 = __toESM(require("https"));
var zlib = __toESM(require("zlib"));
var import_stream = require("stream");
var import_fs = __toESM(require("fs"));
var import_os2 = __toESM(require("os"));
var import_path = __toESM(require("path"));
var import_child_process = __toESM(require("child_process"));
var childProcess = __toESM(require("child_process"));
var import_fs2 = require("fs");
var import_crypto3 = require("crypto");
var import_util3 = require("util");
var import_fs3 = require("fs");
var import_fs4 = __toESM(require("fs"));
var import_util4 = require("util");
var import_https2 = __toESM(require("https"));
var import_http2 = __toESM(require("http"));
var import_fs5 = __toESM(require("fs"));
var import_path2 = __toESM(require("path"));
var import_url = require("url");
var require_connection_string = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/@tediousjs+connection-string@0.5.0/node_modules/@tediousjs/connection-string/lib/parser/connection-string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CollectionMode;
    (function(CollectionMode2) {
      CollectionMode2[CollectionMode2["key"] = 0] = "key";
      CollectionMode2[CollectionMode2["value"] = 1] = "value";
    })(CollectionMode || (CollectionMode = {}));
    var CONFIG = Object.freeze({
      key: {
        terminator: "=",
        quotes: {}
      },
      value: {
        terminator: ";",
        quotes: {
          '"': '"',
          "'": "'",
          "{": "}"
        }
      }
    });
    function connectionStringParser(connectionString, parserConfig = CONFIG) {
      const parsed = {};
      let collectionMode = CollectionMode.key;
      let started = false;
      let finished = false;
      let quoted = false;
      let quote = "";
      let buffer = "";
      let currentKey = "";
      let pointer = 0;
      function start() {
        started = true;
      }
      function finish() {
        finished = true;
      }
      function reset() {
        started = false;
        finished = false;
        quoted = false;
        quote = "";
        buffer = "";
      }
      function config() {
        return collectionMode === CollectionMode.key ? parserConfig.key : parserConfig.value;
      }
      function isTerminator(char) {
        return config().terminator === char;
      }
      function isStartQuote(char) {
        return Object.keys(config().quotes).some((val) => char === val);
      }
      function isEndQuote(char) {
        return quoted && char === config().quotes[quote];
      }
      function push(char) {
        buffer += char;
      }
      function collect() {
        if (!quoted) {
          buffer = buffer.trim();
        }
        switch (collectionMode) {
          case CollectionMode.key:
            currentKey = buffer.toLowerCase();
            collectionMode = CollectionMode.value;
            break;
          case CollectionMode.value:
            collectionMode = CollectionMode.key;
            parsed[currentKey] = buffer;
            currentKey = "";
            break;
        }
        reset();
      }
      while (pointer < connectionString.length) {
        const current = connectionString.charAt(pointer);
        if (!finished) {
          if (!started) {
            if (current.trim()) {
              start();
              if (isStartQuote(current)) {
                quoted = true;
                quote = current;
              } else {
                push(current);
              }
            }
          } else {
            if (quoted && isEndQuote(current)) {
              const next = connectionString.charAt(pointer + 1);
              if (current === next) {
                push(current);
                pointer++;
              } else {
                finish();
              }
            } else if (!quoted && isTerminator(current)) {
              const next = connectionString.charAt(pointer + 1);
              if (current === next) {
                push(current);
                pointer++;
              } else {
                collect();
              }
            } else {
              push(current);
            }
          }
        } else if (isTerminator(current)) {
          collect();
        } else if (current.trim()) {
          throw new Error("Malformed connection string");
        }
        pointer++;
      }
      if (quoted && !finished) {
        throw new Error("Connection string terminated unexpectedly");
      } else {
        collect();
      }
      return parsed;
    }
    exports.default = connectionStringParser;
  }
});
var require_sql_connection_string = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/@tediousjs+connection-string@0.5.0/node_modules/@tediousjs/connection-string/lib/parser/sql-connection-string.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SCHEMA = exports.SchemaTypes = void 0;
    var connection_string_1 = __importDefault(require_connection_string());
    var SchemaTypes;
    (function(SchemaTypes2) {
      SchemaTypes2[SchemaTypes2["BOOL"] = 0] = "BOOL";
      SchemaTypes2[SchemaTypes2["STRING"] = 1] = "STRING";
      SchemaTypes2[SchemaTypes2["NUMBER"] = 2] = "NUMBER";
    })(SchemaTypes = exports.SchemaTypes || (exports.SchemaTypes = {}));
    exports.SCHEMA = {
      "Application Name": {
        type: SchemaTypes.STRING,
        aliases: ["App"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "ApplicationIntent": {
        type: SchemaTypes.STRING,
        allowedValues: ["ReadOnly", "ReadWrite"],
        default: "ReadWrite"
      },
      "Asynchronous Processing": {
        type: SchemaTypes.BOOL,
        default: false,
        aliases: ["Async"]
      },
      "AttachDBFilename": {
        type: SchemaTypes.STRING,
        aliases: ["Extended Properties", "Initial File Name"]
      },
      "Authentication": {
        type: SchemaTypes.STRING,
        allowedValues: ["Active Directory Integrated", "Active Directory Password", "Sql Password"]
      },
      "Column Encryption Setting": {
        type: SchemaTypes.STRING
      },
      "Connection Timeout": {
        type: SchemaTypes.NUMBER,
        aliases: ["Connect Timeout", "Timeout"],
        default: 15
      },
      "Connection Lifetime": {
        type: SchemaTypes.NUMBER,
        aliases: ["Load Balance Timeout"],
        default: 0
      },
      "ConnectRetryCount": {
        type: SchemaTypes.NUMBER,
        default: 1,
        validator(val) {
          return val > 0 && val <= 255;
        }
      },
      "ConnectRetryInterval": {
        type: SchemaTypes.NUMBER,
        default: 10
      },
      "Context Connection": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Current Language": {
        aliases: ["Language"],
        type: SchemaTypes.STRING,
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "Data Source": {
        aliases: ["Addr", "Address", "Server", "Network Address"],
        type: SchemaTypes.STRING
      },
      "Encrypt": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Enlist": {
        type: SchemaTypes.BOOL,
        default: true
      },
      "Failover Partner": {
        type: SchemaTypes.STRING
      },
      "Initial Catalog": {
        type: SchemaTypes.STRING,
        aliases: ["Database"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "Integrated Security": {
        type: SchemaTypes.BOOL,
        aliases: ["Trusted_Connection"],
        coerce(val) {
          return val === "sspi" || null;
        }
      },
      "Max Pool Size": {
        type: SchemaTypes.NUMBER,
        default: 100,
        validator(val) {
          return val >= 1;
        }
      },
      "Min Pool Size": {
        type: SchemaTypes.NUMBER,
        default: 0,
        validator(val) {
          return val >= 0;
        }
      },
      "MultipleActiveResultSets": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "MultiSubnetFailover": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Network Library": {
        type: SchemaTypes.STRING,
        aliases: ["Network", "Net"],
        allowedValues: ["dbnmpntw", "dbmsrpcn", "dbmsadsn", "dbmsgnet", "dbmslpcn", "dbmsspxn", "dbmssocn", "Dbmsvinn"]
      },
      "Packet Size": {
        type: SchemaTypes.NUMBER,
        default: 8e3,
        validator(val) {
          return val >= 512 && val <= 32768;
        }
      },
      "Password": {
        type: SchemaTypes.STRING,
        aliases: ["PWD"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "Persist Security Info": {
        type: SchemaTypes.BOOL,
        aliases: ["PersistSecurityInfo"],
        default: false
      },
      "PoolBlockingPeriod": {
        type: SchemaTypes.NUMBER,
        default: 0,
        coerce(val) {
          if (typeof val !== "string") {
            return null;
          }
          switch (val.toLowerCase()) {
            case "alwaysblock":
              return 1;
            case "auto":
              return 0;
            case "neverblock":
              return 2;
          }
          return null;
        }
      },
      "Pooling": {
        type: SchemaTypes.BOOL,
        default: true
      },
      "Replication": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Transaction Binding": {
        type: SchemaTypes.STRING,
        allowedValues: ["Implicit Unbind", "Explicit Unbind"],
        default: "Implicit Unbind"
      },
      "TransparentNetworkIPResolution": {
        type: SchemaTypes.BOOL,
        default: true
      },
      "TrustServerCertificate": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Type System Version": {
        type: SchemaTypes.STRING,
        allowedValues: ["SQL Server 2012", "SQL Server 2008", "SQL Server 2005", "Latest"]
      },
      "User ID": {
        type: SchemaTypes.STRING,
        aliases: ["UID"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "User Instance": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Workstation ID": {
        type: SchemaTypes.STRING,
        aliases: ["WSID"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      }
    };
    function guessType(value) {
      if (value.trim() === "") {
        return SchemaTypes.STRING;
      }
      const asNum = parseInt(value, 10);
      if (!Number.isNaN(asNum) && asNum.toString() === value) {
        return SchemaTypes.NUMBER;
      }
      if (["true", "false", "yes", "no"].includes(value.toLowerCase())) {
        return SchemaTypes.BOOL;
      }
      return SchemaTypes.STRING;
    }
    function coerce(value, type2, coercer) {
      if (coercer) {
        const coerced = coercer(value);
        if (coerced !== null) {
          return coerced;
        }
      }
      switch (type2) {
        case SchemaTypes.BOOL:
          if (["true", "yes", "1"].includes(value.toLowerCase())) {
            return true;
          }
          if (["false", "no", "0"].includes(value.toLowerCase())) {
            return false;
          }
          return value;
        case SchemaTypes.NUMBER:
          return parseInt(value, 10);
      }
      return value;
    }
    function validate2(value, allowedValues, validator) {
      let valid = true;
      if (validator) {
        valid = validator(value);
      }
      if (valid) {
        valid = (allowedValues === null || allowedValues === void 0 ? void 0 : allowedValues.includes(value)) || false;
      }
      return valid;
    }
    function parseSqlConnectionString(connectionString, canonicalProps = false, allowUnknown = false, strict = false, schema = exports.SCHEMA) {
      const flattenedSchema = Object.entries(schema).reduce((flattened, [key, item]) => {
        var _a2;
        Object.assign(flattened, {
          [key.toLowerCase()]: item
        });
        return ((_a2 = item.aliases) === null || _a2 === void 0 ? void 0 : _a2.reduce((accum, alias) => {
          return Object.assign(accum, {
            [alias.toLowerCase()]: {
              ...item,
              canonical: key.toLowerCase()
            }
          });
        }, flattened)) || flattened;
      }, {});
      return Object.entries((0, connection_string_1.default)(connectionString)).reduce((config, [prop, value]) => {
        if (!Object.prototype.hasOwnProperty.call(flattenedSchema, prop)) {
          return Object.assign(config, {
            [prop]: coerce(value, guessType(value))
          });
        }
        let coercedValue = coerce(value, flattenedSchema[prop].type, flattenedSchema[prop].coerce);
        if (strict && !validate2(coercedValue, flattenedSchema[prop].allowedValues, flattenedSchema[prop].validator)) {
          coercedValue = flattenedSchema[prop].default;
        }
        const propName = canonicalProps ? flattenedSchema[prop].canonical || prop : prop;
        return Object.assign(config, {
          [propName]: coercedValue
        });
      }, {});
    }
    exports.default = parseSqlConnectionString;
  }
});
var require_builder = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/@tediousjs+connection-string@0.5.0/node_modules/@tediousjs/connection-string/lib/builder/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildConnectionString = void 0;
    function isQuoted(val) {
      if (val[0] !== "{") {
        return false;
      }
      for (let i = 1; i < val.length; i++) {
        if (val[i] === "}") {
          if (i + 1 === val.length) {
            return true;
          } else if (val[i + 1] !== "}") {
            return false;
          } else {
            i++;
          }
        }
      }
      return false;
    }
    function needsQuotes(val) {
      var _a2;
      return !isQuoted(val) && !!((_a2 = val.match(/\[|]|{|}|\|\(|\)|,|;|\?|\*|=|!|@/)) === null || _a2 === void 0 ? void 0 : _a2.length);
    }
    function encodeTuple(key, value) {
      if (value === null || value === void 0) {
        return [key, ""];
      }
      switch (typeof value) {
        case "boolean":
          return [key, value ? "Yes" : "No"];
        default: {
          const strVal = value.toString();
          if (needsQuotes(strVal)) {
            return [key, `{${strVal.replace(/}/g, "}}")}}`];
          }
          return [key, strVal];
        }
      }
    }
    function buildConnectionString(data) {
      return Object.entries(data).map(([key, value]) => {
        return encodeTuple(key.trim(), value).join("=");
      }).join(";");
    }
    exports.buildConnectionString = buildConnectionString;
  }
});
var require_lib2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/@tediousjs+connection-string@0.5.0/node_modules/@tediousjs/connection-string/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSqlConnectionString = exports.parseConnectionString = void 0;
    var connection_string_1 = __importDefault(require_connection_string());
    exports.parseConnectionString = connection_string_1.default;
    var sql_connection_string_1 = __importDefault(require_sql_connection_string());
    exports.parseSqlConnectionString = sql_connection_string_1.default;
    __exportStar(require_builder(), exports);
  }
});
var require_TimeoutError = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tarn@3.0.2/node_modules/tarn/dist/TimeoutError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TimeoutError = class extends Error {
    };
    exports.TimeoutError = TimeoutError;
  }
});
var require_PromiseInspection = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tarn@3.0.2/node_modules/tarn/dist/PromiseInspection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PromiseInspection = class {
      constructor(args) {
        this._value = args.value;
        this._error = args.error;
      }
      value() {
        return this._value;
      }
      reason() {
        return this._error;
      }
      isRejected() {
        return !!this._error;
      }
      isFulfilled() {
        return !!this._value;
      }
    };
    exports.PromiseInspection = PromiseInspection;
  }
});
var require_utils = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tarn@3.0.2/node_modules/tarn/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PromiseInspection_1 = require_PromiseInspection();
    function defer() {
      let resolve = null;
      let reject = null;
      const promise = new Promise((resolver, rejecter) => {
        resolve = resolver;
        reject = rejecter;
      });
      return {
        promise,
        resolve,
        reject
      };
    }
    exports.defer = defer;
    function now() {
      return Date.now();
    }
    exports.now = now;
    function duration(t1, t2) {
      return Math.abs(t2 - t1);
    }
    exports.duration = duration;
    function checkOptionalTime(time) {
      if (typeof time === "undefined") {
        return true;
      }
      return checkRequiredTime(time);
    }
    exports.checkOptionalTime = checkOptionalTime;
    function checkRequiredTime(time) {
      return typeof time === "number" && time === Math.round(time) && time > 0;
    }
    exports.checkRequiredTime = checkRequiredTime;
    function delay3(millis) {
      return new Promise((resolve) => setTimeout(resolve, millis));
    }
    exports.delay = delay3;
    function reflect(promise) {
      return promise.then((value) => {
        return new PromiseInspection_1.PromiseInspection({ value });
      }).catch((error) => {
        return new PromiseInspection_1.PromiseInspection({ error });
      });
    }
    exports.reflect = reflect;
    function tryPromise(cb) {
      try {
        const result = cb();
        return Promise.resolve(result);
      } catch (err) {
        return Promise.reject(err);
      }
    }
    exports.tryPromise = tryPromise;
  }
});
var require_PendingOperation = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tarn@3.0.2/node_modules/tarn/dist/PendingOperation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TimeoutError_1 = require_TimeoutError();
    var utils_1 = require_utils();
    var PendingOperation = class {
      constructor(timeoutMillis) {
        this.timeoutMillis = timeoutMillis;
        this.deferred = utils_1.defer();
        this.possibleTimeoutCause = null;
        this.isRejected = false;
        this.promise = timeout(this.deferred.promise, timeoutMillis).catch((err) => {
          if (err instanceof TimeoutError_1.TimeoutError) {
            if (this.possibleTimeoutCause) {
              err = new TimeoutError_1.TimeoutError(this.possibleTimeoutCause.message);
            } else {
              err = new TimeoutError_1.TimeoutError("operation timed out for an unknown reason");
            }
          }
          this.isRejected = true;
          return Promise.reject(err);
        });
      }
      abort() {
        this.reject(new Error("aborted"));
      }
      reject(err) {
        this.deferred.reject(err);
      }
      resolve(value) {
        this.deferred.resolve(value);
      }
    };
    exports.PendingOperation = PendingOperation;
    function timeout(promise, time) {
      return new Promise((resolve, reject) => {
        const timeoutHandle = setTimeout(() => reject(new TimeoutError_1.TimeoutError()), time);
        promise.then((result) => {
          clearTimeout(timeoutHandle);
          resolve(result);
        }).catch((err) => {
          clearTimeout(timeoutHandle);
          reject(err);
        });
      });
    }
  }
});
var require_Resource = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tarn@3.0.2/node_modules/tarn/dist/Resource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    var Resource = class _Resource {
      constructor(resource) {
        this.resource = resource;
        this.resource = resource;
        this.timestamp = utils_1.now();
        this.deferred = utils_1.defer();
      }
      get promise() {
        return this.deferred.promise;
      }
      resolve() {
        this.deferred.resolve(void 0);
        return new _Resource(this.resource);
      }
    };
    exports.Resource = Resource;
  }
});
var require_Pool = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tarn@3.0.2/node_modules/tarn/dist/Pool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PendingOperation_1 = require_PendingOperation();
    var Resource_1 = require_Resource();
    var utils_1 = require_utils();
    var events_1 = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var timers_1 = (0, import_chunk_FVJ3R4NJ.__require)("timers");
    var Pool = class {
      constructor(opt) {
        this.destroyed = false;
        this.emitter = new events_1.EventEmitter();
        opt = opt || {};
        if (!opt.create) {
          throw new Error("Tarn: opt.create function most be provided");
        }
        if (!opt.destroy) {
          throw new Error("Tarn: opt.destroy function most be provided");
        }
        if (typeof opt.min !== "number" || opt.min < 0 || opt.min !== Math.round(opt.min)) {
          throw new Error("Tarn: opt.min must be an integer >= 0");
        }
        if (typeof opt.max !== "number" || opt.max <= 0 || opt.max !== Math.round(opt.max)) {
          throw new Error("Tarn: opt.max must be an integer > 0");
        }
        if (opt.min > opt.max) {
          throw new Error("Tarn: opt.max is smaller than opt.min");
        }
        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.acquireTimeoutMillis " + JSON.stringify(opt.acquireTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.createTimeoutMillis " + JSON.stringify(opt.createTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.destroyTimeoutMillis " + JSON.stringify(opt.destroyTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.idleTimeoutMillis " + JSON.stringify(opt.idleTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {
          throw new Error("Tarn: invalid opt.reapIntervalMillis " + JSON.stringify(opt.reapIntervalMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {
          throw new Error("Tarn: invalid opt.createRetryIntervalMillis " + JSON.stringify(opt.createRetryIntervalMillis));
        }
        const allowedKeys = {
          create: true,
          validate: true,
          destroy: true,
          log: true,
          min: true,
          max: true,
          acquireTimeoutMillis: true,
          createTimeoutMillis: true,
          destroyTimeoutMillis: true,
          idleTimeoutMillis: true,
          reapIntervalMillis: true,
          createRetryIntervalMillis: true,
          propagateCreateError: true
        };
        for (const key of Object.keys(opt)) {
          if (!allowedKeys[key]) {
            throw new Error(`Tarn: unsupported option opt.${key}`);
          }
        }
        this.creator = opt.create;
        this.destroyer = opt.destroy;
        this.validate = typeof opt.validate === "function" ? opt.validate : () => true;
        this.log = opt.log || (() => {
        });
        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 3e4;
        this.createTimeoutMillis = opt.createTimeoutMillis || 3e4;
        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5e3;
        this.idleTimeoutMillis = opt.idleTimeoutMillis || 3e4;
        this.reapIntervalMillis = opt.reapIntervalMillis || 1e3;
        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;
        this.propagateCreateError = !!opt.propagateCreateError;
        this.min = opt.min;
        this.max = opt.max;
        this.used = [];
        this.free = [];
        this.pendingCreates = [];
        this.pendingAcquires = [];
        this.pendingDestroys = [];
        this.pendingValidations = [];
        this.destroyed = false;
        this.interval = null;
        this.eventId = 1;
      }
      numUsed() {
        return this.used.length;
      }
      numFree() {
        return this.free.length;
      }
      numPendingAcquires() {
        return this.pendingAcquires.length;
      }
      numPendingValidations() {
        return this.pendingValidations.length;
      }
      numPendingCreates() {
        return this.pendingCreates.length;
      }
      acquire() {
        const eventId = this.eventId++;
        this._executeEventHandlers("acquireRequest", eventId);
        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
        this.pendingAcquires.push(pendingAcquire);
        pendingAcquire.promise = pendingAcquire.promise.then((resource) => {
          this._executeEventHandlers("acquireSuccess", eventId, resource);
          return resource;
        }).catch((err) => {
          this._executeEventHandlers("acquireFail", eventId, err);
          remove(this.pendingAcquires, pendingAcquire);
          return Promise.reject(err);
        });
        this._tryAcquireOrCreate();
        return pendingAcquire;
      }
      release(resource) {
        this._executeEventHandlers("release", resource);
        for (let i = 0, l = this.used.length; i < l; ++i) {
          const used = this.used[i];
          if (used.resource === resource) {
            this.used.splice(i, 1);
            this.free.push(used.resolve());
            this._tryAcquireOrCreate();
            return true;
          }
        }
        return false;
      }
      isEmpty() {
        return [
          this.numFree(),
          this.numUsed(),
          this.numPendingAcquires(),
          this.numPendingValidations(),
          this.numPendingCreates()
        ].reduce((total, value) => total + value) === 0;
      }
      /**
       * Reaping cycle.
       */
      check() {
        const timestamp = utils_1.now();
        const newFree = [];
        const minKeep = this.min - this.used.length;
        const maxDestroy = this.free.length - minKeep;
        let numDestroyed = 0;
        this.free.forEach((free) => {
          if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis && numDestroyed < maxDestroy) {
            numDestroyed++;
            this._destroy(free.resource);
          } else {
            newFree.push(free);
          }
        });
        this.free = newFree;
        if (this.isEmpty()) {
          this._stopReaping();
        }
      }
      destroy() {
        const eventId = this.eventId++;
        this._executeEventHandlers("poolDestroyRequest", eventId);
        this._stopReaping();
        this.destroyed = true;
        return utils_1.reflect(Promise.all(this.pendingCreates.map((create) => utils_1.reflect(create.promise))).then(() => {
          return new Promise((resolve, reject) => {
            if (this.numPendingValidations() === 0) {
              resolve();
              return;
            }
            const interval = setInterval(() => {
              if (this.numPendingValidations() === 0) {
                timers_1.clearInterval(interval);
                resolve();
              }
            }, 100);
          });
        }).then(() => {
          return Promise.all(this.used.map((used) => utils_1.reflect(used.promise)));
        }).then(() => {
          return Promise.all(this.pendingAcquires.map((acquire) => {
            acquire.abort();
            return utils_1.reflect(acquire.promise);
          }));
        }).then(() => {
          return Promise.all(this.free.map((free) => utils_1.reflect(this._destroy(free.resource))));
        }).then(() => {
          return Promise.all(this.pendingDestroys.map((pd) => pd.promise));
        }).then(() => {
          this.free = [];
          this.pendingAcquires = [];
        })).then((res) => {
          this._executeEventHandlers("poolDestroySuccess", eventId);
          this.emitter.removeAllListeners();
          return res;
        });
      }
      on(event, listener) {
        this.emitter.on(event, listener);
      }
      removeListener(event, listener) {
        this.emitter.removeListener(event, listener);
      }
      removeAllListeners(event) {
        this.emitter.removeAllListeners(event);
      }
      /**
       * The most important method that is called always when resources
       * are created / destroyed / acquired / released. In other words
       * every time when resources are moved from used to free or vice
       * versa.
       *
       * Either assigns free resources to pendingAcquires or creates new
       * resources if there is room for it in the pool.
       */
      _tryAcquireOrCreate() {
        if (this.destroyed) {
          return;
        }
        if (this._hasFreeResources()) {
          this._doAcquire();
        } else if (this._shouldCreateMoreResources()) {
          this._doCreate();
        }
      }
      _hasFreeResources() {
        return this.free.length > 0;
      }
      _doAcquire() {
        while (this._canAcquire()) {
          const pendingAcquire = this.pendingAcquires.shift();
          const free = this.free.pop();
          if (free === void 0 || pendingAcquire === void 0) {
            const errMessage = "this.free was empty while trying to acquire resource";
            this.log(`Tarn: ${errMessage}`, "warn");
            throw new Error(`Internal error, should never happen. ${errMessage}`);
          }
          this.pendingValidations.push(pendingAcquire);
          this.used.push(free);
          const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
          pendingAcquire.promise.catch((err) => {
            abortAbleValidation.abort();
          });
          abortAbleValidation.promise.catch((err) => {
            this.log("Tarn: resource validator threw an exception " + err.stack, "warn");
            return false;
          }).then((validationSuccess) => {
            try {
              if (validationSuccess && !pendingAcquire.isRejected) {
                this._startReaping();
                pendingAcquire.resolve(free.resource);
              } else {
                remove(this.used, free);
                if (!validationSuccess) {
                  this._destroy(free.resource);
                  setTimeout(() => {
                    this._tryAcquireOrCreate();
                  }, 0);
                } else {
                  this.free.push(free);
                }
                if (!pendingAcquire.isRejected) {
                  this.pendingAcquires.unshift(pendingAcquire);
                }
              }
            } finally {
              remove(this.pendingValidations, pendingAcquire);
            }
          });
          this._validateResource(free.resource).then((validationSuccess) => {
            abortAbleValidation.resolve(validationSuccess);
          }).catch((err) => {
            abortAbleValidation.reject(err);
          });
        }
      }
      _canAcquire() {
        return this.free.length > 0 && this.pendingAcquires.length > 0;
      }
      _validateResource(resource) {
        try {
          return Promise.resolve(this.validate(resource));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      _shouldCreateMoreResources() {
        return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;
      }
      _doCreate() {
        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();
        const pendingCreate = this._create();
        pendingCreate.promise.then(() => {
          this._tryAcquireOrCreate();
          return null;
        }).catch((err) => {
          if (this.propagateCreateError && this.pendingAcquires.length !== 0) {
            this.pendingAcquires[0].reject(err);
          }
          pendingAcquiresBeforeCreate.forEach((pendingAcquire) => {
            pendingAcquire.possibleTimeoutCause = err;
          });
          utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());
        });
      }
      _create() {
        const eventId = this.eventId++;
        this._executeEventHandlers("createRequest", eventId);
        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);
        pendingCreate.promise = pendingCreate.promise.catch((err) => {
          if (remove(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          throw err;
        });
        this.pendingCreates.push(pendingCreate);
        callbackOrPromise(this.creator).then((resource) => {
          if (pendingCreate.isRejected) {
            this.destroyer(resource);
            return null;
          }
          remove(this.pendingCreates, pendingCreate);
          this.free.push(new Resource_1.Resource(resource));
          pendingCreate.resolve(resource);
          this._executeEventHandlers("createSuccess", eventId, resource);
          return null;
        }).catch((err) => {
          if (pendingCreate.isRejected) {
            return null;
          }
          if (remove(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          pendingCreate.reject(err);
          return null;
        });
        return pendingCreate;
      }
      _destroy(resource) {
        const eventId = this.eventId++;
        this._executeEventHandlers("destroyRequest", eventId, resource);
        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);
        const retVal = Promise.resolve().then(() => this.destroyer(resource));
        retVal.then(() => {
          pendingDestroy.resolve(resource);
        }).catch((err) => {
          pendingDestroy.reject(err);
        });
        this.pendingDestroys.push(pendingDestroy);
        return pendingDestroy.promise.then((res) => {
          this._executeEventHandlers("destroySuccess", eventId, resource);
          return res;
        }).catch((err) => this._logDestroyerError(eventId, resource, err)).then((res) => {
          const index = this.pendingDestroys.findIndex((pd) => pd === pendingDestroy);
          this.pendingDestroys.splice(index, 1);
          return res;
        });
      }
      _logDestroyerError(eventId, resource, err) {
        this._executeEventHandlers("destroyFail", eventId, resource, err);
        this.log("Tarn: resource destroyer threw an exception " + err.stack, "warn");
      }
      _startReaping() {
        if (!this.interval) {
          this._executeEventHandlers("startReaping");
          this.interval = setInterval(() => this.check(), this.reapIntervalMillis);
        }
      }
      _stopReaping() {
        if (this.interval !== null) {
          this._executeEventHandlers("stopReaping");
          timers_1.clearInterval(this.interval);
        }
        this.interval = null;
      }
      _executeEventHandlers(eventName, ...args) {
        const listeners = this.emitter.listeners(eventName);
        listeners.forEach((listener) => {
          try {
            listener(...args);
          } catch (err) {
            this.log(`Tarn: event handler "${eventName}" threw an exception ${err.stack}`, "warn");
          }
        });
      }
    };
    exports.Pool = Pool;
    function remove(arr, item) {
      const idx = arr.indexOf(item);
      if (idx === -1) {
        return false;
      } else {
        arr.splice(idx, 1);
        return true;
      }
    }
    function callbackOrPromise(func) {
      return new Promise((resolve, reject) => {
        const callback = (err, resource) => {
          if (err) {
            reject(err);
          } else {
            resolve(resource);
          }
        };
        utils_1.tryPromise(() => func(callback)).then((res) => {
          if (res) {
            resolve(res);
          }
        }).catch((err) => {
          reject(err);
        });
      });
    }
  }
});
var require_tarn = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tarn@3.0.2/node_modules/tarn/dist/tarn.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Pool_1 = require_Pool();
    exports.Pool = Pool_1.Pool;
    var TimeoutError_1 = require_TimeoutError();
    exports.TimeoutError = TimeoutError_1.TimeoutError;
    module2.exports = {
      Pool: Pool_1.Pool,
      TimeoutError: TimeoutError_1.TimeoutError
    };
  }
});
var require_utils2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/utils.js"(exports, module2) {
    "use strict";
    var IDS = /* @__PURE__ */ new WeakMap();
    var INCREMENT = {
      Connection: 1,
      ConnectionPool: 1,
      Request: 1,
      Transaction: 1,
      PreparedStatement: 1
    };
    module2.exports = {
      objectHasProperty: (object, property) => Object.prototype.hasOwnProperty.call(object, property),
      INCREMENT,
      IDS: {
        get: IDS.get.bind(IDS),
        add: (object, type2, id) => {
          if (id)
            return IDS.set(object, id);
          IDS.set(object, INCREMENT[type2]++);
        }
      }
    };
  }
});
var require_mssql_error = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/error/mssql-error.js"(exports, module2) {
    "use strict";
    var MSSQLError = class extends Error {
      /**
       * Creates a new ConnectionError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        if (message instanceof Error) {
          super(message.message);
          this.code = message.code || code;
          Error.captureStackTrace(this, this.constructor);
          Object.defineProperty(this, "originalError", { enumerable: true, value: message });
        } else {
          super(message);
          this.code = code;
        }
        this.name = "MSSQLError";
      }
    };
    module2.exports = MSSQLError;
  }
});
var require_connection_error = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/error/connection-error.js"(exports, module2) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var ConnectionError = class extends MSSQLError {
      /**
       * Creates a new ConnectionError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        this.name = "ConnectionError";
      }
    };
    module2.exports = ConnectionError;
  }
});
var require_datatypes = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/datatypes.js"(exports, module2) {
    "use strict";
    var objectHasProperty = require_utils2().objectHasProperty;
    var inspect2 = Symbol.for("nodejs.util.inspect.custom");
    var TYPES = {
      VarChar(length) {
        return { type: TYPES.VarChar, length };
      },
      NVarChar(length) {
        return { type: TYPES.NVarChar, length };
      },
      Text() {
        return { type: TYPES.Text };
      },
      Int() {
        return { type: TYPES.Int };
      },
      BigInt() {
        return { type: TYPES.BigInt };
      },
      TinyInt() {
        return { type: TYPES.TinyInt };
      },
      SmallInt() {
        return { type: TYPES.SmallInt };
      },
      Bit() {
        return { type: TYPES.Bit };
      },
      Float() {
        return { type: TYPES.Float };
      },
      Numeric(precision, scale) {
        return { type: TYPES.Numeric, precision, scale };
      },
      Decimal(precision, scale) {
        return { type: TYPES.Decimal, precision, scale };
      },
      Real() {
        return { type: TYPES.Real };
      },
      Date() {
        return { type: TYPES.Date };
      },
      DateTime() {
        return { type: TYPES.DateTime };
      },
      DateTime2(scale) {
        return { type: TYPES.DateTime2, scale };
      },
      DateTimeOffset(scale) {
        return { type: TYPES.DateTimeOffset, scale };
      },
      SmallDateTime() {
        return { type: TYPES.SmallDateTime };
      },
      Time(scale) {
        return { type: TYPES.Time, scale };
      },
      UniqueIdentifier() {
        return { type: TYPES.UniqueIdentifier };
      },
      SmallMoney() {
        return { type: TYPES.SmallMoney };
      },
      Money() {
        return { type: TYPES.Money };
      },
      Binary(length) {
        return { type: TYPES.Binary, length };
      },
      VarBinary(length) {
        return { type: TYPES.VarBinary, length };
      },
      Image() {
        return { type: TYPES.Image };
      },
      Xml() {
        return { type: TYPES.Xml };
      },
      Char(length) {
        return { type: TYPES.Char, length };
      },
      NChar(length) {
        return { type: TYPES.NChar, length };
      },
      NText() {
        return { type: TYPES.NText };
      },
      TVP(tvpType) {
        return { type: TYPES.TVP, tvpType };
      },
      UDT() {
        return { type: TYPES.UDT };
      },
      Geography() {
        return { type: TYPES.Geography };
      },
      Geometry() {
        return { type: TYPES.Geometry };
      },
      Variant() {
        return { type: TYPES.Variant };
      }
    };
    module2.exports.TYPES = TYPES;
    module2.exports.DECLARATIONS = {};
    var zero = function(value, length) {
      if (length == null)
        length = 2;
      value = String(value);
      if (value.length < length) {
        for (let i = 1; i <= length - value.length; i++) {
          value = `0${value}`;
        }
      }
      return value;
    };
    for (const key in TYPES) {
      if (objectHasProperty(TYPES, key)) {
        const value = TYPES[key];
        value.declaration = key.toLowerCase();
        module2.exports.DECLARATIONS[value.declaration] = value;
        ((key2, value2) => {
          value2[inspect2] = () => `[sql.${key2}]`;
        })(key, value);
      }
    }
    module2.exports.declare = (type2, options) => {
      switch (type2) {
        case TYPES.VarChar:
        case TYPES.VarBinary:
          return `${type2.declaration} (${options.length > 8e3 ? "MAX" : options.length == null ? "MAX" : options.length})`;
        case TYPES.NVarChar:
          return `${type2.declaration} (${options.length > 4e3 ? "MAX" : options.length == null ? "MAX" : options.length})`;
        case TYPES.Char:
        case TYPES.NChar:
        case TYPES.Binary:
          return `${type2.declaration} (${options.length == null ? 1 : options.length})`;
        case TYPES.Decimal:
        case TYPES.Numeric:
          return `${type2.declaration} (${options.precision == null ? 18 : options.precision}, ${options.scale == null ? 0 : options.scale})`;
        case TYPES.Time:
        case TYPES.DateTime2:
        case TYPES.DateTimeOffset:
          return `${type2.declaration} (${options.scale == null ? 7 : options.scale})`;
        case TYPES.TVP:
          return `${options.tvpType} readonly`;
        default:
          return type2.declaration;
      }
    };
    module2.exports.cast = (value, type2, options) => {
      if (value == null) {
        return null;
      }
      switch (typeof value) {
        case "string":
          return `N'${value.replace(/'/g, "''")}'`;
        case "number":
          return value;
        case "boolean":
          return value ? 1 : 0;
        case "object":
          if (value instanceof Date) {
            let ns = value.getUTCMilliseconds() / 1e3;
            if (value.nanosecondDelta != null) {
              ns += value.nanosecondDelta;
            }
            const scale = options.scale == null ? 7 : options.scale;
            if (scale > 0) {
              ns = String(ns).substr(1, scale + 1);
            } else {
              ns = "";
            }
            return `N'${value.getUTCFullYear()}-${zero(value.getUTCMonth() + 1)}-${zero(value.getUTCDate())} ${zero(value.getUTCHours())}:${zero(value.getUTCMinutes())}:${zero(value.getUTCSeconds())}${ns}'`;
          } else if (Buffer.isBuffer(value)) {
            return `0x${value.toString("hex")}`;
          }
          return null;
        default:
          return null;
      }
    };
  }
});
var require_table = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/table.js"(exports, module2) {
    "use strict";
    var TYPES = require_datatypes().TYPES;
    var declareType = require_datatypes().declare;
    var objectHasProperty = require_utils2().objectHasProperty;
    var MAX = 65535;
    var JSON_COLUMN_ID = "JSON_F52E2B61-18A1-11d1-B105-00805F49916B";
    function Table(name3) {
      if (name3) {
        const parsed = Table.parseName(name3);
        this.name = parsed.name;
        this.schema = parsed.schema;
        this.database = parsed.database;
        this.path = (this.database ? `[${this.database}].` : "") + (this.schema ? `[${this.schema}].` : "") + `[${this.name}]`;
        this.temporary = this.name.charAt(0) === "#";
      }
      this.columns = [];
      this.rows = [];
      Object.defineProperty(this.columns, "add", {
        value(name4, column, options) {
          if (column == null) {
            throw new Error("Column data type is not defined.");
          }
          if (column instanceof Function) {
            column = column();
          }
          options = options || {};
          column.name = name4;
          ["nullable", "primary", "identity", "readOnly", "length"].forEach((prop) => {
            if (objectHasProperty(options, prop)) {
              column[prop] = options[prop];
            }
          });
          return this.push(column);
        }
      });
      Object.defineProperty(
        this.rows,
        "add",
        {
          value() {
            return this.push(Array.prototype.slice.call(arguments));
          }
        }
      );
      Object.defineProperty(
        this.rows,
        "clear",
        {
          value() {
            return this.splice(0, this.length);
          }
        }
      );
    }
    Table.prototype._makeBulk = function _makeBulk() {
      for (let i = 0; i < this.columns.length; i++) {
        const col = this.columns[i];
        switch (col.type) {
          case TYPES.Date:
          case TYPES.DateTime:
          case TYPES.DateTime2:
            for (let j = 0; j < this.rows.length; j++) {
              const dateValue = this.rows[j][i];
              if (typeof dateValue === "string" || typeof dateValue === "number") {
                const date = new Date(dateValue);
                if (isNaN(date.getDate())) {
                  throw new TypeError("Invalid date value passed to bulk rows");
                }
                this.rows[j][i] = date;
              }
            }
            break;
          case TYPES.Xml:
            col.type = TYPES.NVarChar(MAX).type;
            break;
          case TYPES.UDT:
          case TYPES.Geography:
          case TYPES.Geometry:
            col.type = TYPES.VarBinary(MAX).type;
            break;
          default:
            break;
        }
      }
      return this;
    };
    Table.prototype.declare = function declare() {
      const pkey = this.columns.filter((col) => col.primary === true).map((col) => `[${col.name}]`);
      const cols = this.columns.map((col) => {
        const def = [`[${col.name}] ${declareType(col.type, col)}`];
        if (col.nullable === true) {
          def.push("null");
        } else if (col.nullable === false) {
          def.push("not null");
        }
        if (col.primary === true && pkey.length === 1) {
          def.push("primary key");
        }
        return def.join(" ");
      });
      const constraint = pkey.length > 1 ? `, constraint [PK_${this.temporary ? this.name.substr(1) : this.name}] primary key (${pkey.join(", ")})` : "";
      return `create table ${this.path} (${cols.join(", ")}${constraint})`;
    };
    Table.fromRecordset = function fromRecordset(recordset, name3) {
      const t = new this(name3);
      for (const colName in recordset.columns) {
        if (objectHasProperty(recordset.columns, colName)) {
          const col = recordset.columns[colName];
          t.columns.add(colName, {
            type: col.type,
            length: col.length,
            scale: col.scale,
            precision: col.precision
          }, {
            nullable: col.nullable,
            identity: col.identity,
            readOnly: col.readOnly
          });
        }
      }
      if (t.columns.length === 1 && t.columns[0].name === JSON_COLUMN_ID) {
        for (let i = 0; i < recordset.length; i++) {
          t.rows.add(JSON.stringify(recordset[i]));
        }
      } else {
        for (let i = 0; i < recordset.length; i++) {
          t.rows.add.apply(t.rows, t.columns.map((col) => recordset[i][col.name]));
        }
      }
      return t;
    };
    Table.parseName = function parseName(name3) {
      const length = name3.length;
      let cursor = -1;
      let buffer = "";
      let escaped = false;
      const path3 = [];
      while (++cursor < length) {
        const char = name3.charAt(cursor);
        if (char === "[") {
          if (escaped) {
            buffer += char;
          } else {
            escaped = true;
          }
        } else if (char === "]") {
          if (escaped) {
            escaped = false;
          } else {
            throw new Error("Invalid table name.");
          }
        } else if (char === ".") {
          if (escaped) {
            buffer += char;
          } else {
            path3.push(buffer);
            buffer = "";
          }
        } else {
          buffer += char;
        }
      }
      if (buffer) {
        path3.push(buffer);
      }
      switch (path3.length) {
        case 1:
          return {
            name: path3[0],
            schema: null,
            database: null
          };
        case 2:
          return {
            name: path3[1],
            schema: path3[0],
            database: null
          };
        case 3:
          return {
            name: path3[2],
            schema: path3[1],
            database: path3[0]
          };
        default:
          throw new Error("Invalid table name.");
      }
    };
    module2.exports = Table;
  }
});
var require_shared = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/shared.js"(exports, module2) {
    "use strict";
    var TYPES = require_datatypes().TYPES;
    var Table = require_table();
    var PromiseLibrary = Promise;
    var driver = {};
    var map = [];
    map.register = function(jstype, sqltype) {
      for (let index = 0; index < this.length; index++) {
        const item = this[index];
        if (item.js === jstype) {
          this.splice(index, 1);
          break;
        }
      }
      this.push({
        js: jstype,
        sql: sqltype
      });
      return null;
    };
    map.register(String, TYPES.NVarChar);
    map.register(Number, TYPES.Int);
    map.register(Boolean, TYPES.Bit);
    map.register(Date, TYPES.DateTime);
    map.register(Buffer, TYPES.VarBinary);
    map.register(Table, TYPES.TVP);
    var getTypeByValue = function(value) {
      if (value === null || value === void 0) {
        return TYPES.NVarChar;
      }
      switch (typeof value) {
        case "string":
          for (const item of Array.from(map)) {
            if (item.js === String) {
              return item.sql;
            }
          }
          return TYPES.NVarChar;
        case "number":
        case "bigint":
          if (value % 1 === 0) {
            if (value < -2147483648 || value > 2147483647) {
              return TYPES.BigInt;
            } else {
              return TYPES.Int;
            }
          } else {
            return TYPES.Float;
          }
        case "boolean":
          for (const item of Array.from(map)) {
            if (item.js === Boolean) {
              return item.sql;
            }
          }
          return TYPES.Bit;
        case "object":
          for (const item of Array.from(map)) {
            if (value instanceof item.js) {
              return item.sql;
            }
          }
          return TYPES.NVarChar;
        default:
          return TYPES.NVarChar;
      }
    };
    module2.exports = {
      driver,
      getTypeByValue,
      map
    };
    Object.defineProperty(module2.exports, "Promise", {
      get: () => {
        return PromiseLibrary;
      },
      set: (value) => {
        PromiseLibrary = value;
      }
    });
    Object.defineProperty(module2.exports, "valueHandler", {
      enumerable: true,
      value: /* @__PURE__ */ new Map(),
      writable: false,
      configurable: false
    });
  }
});
var require_rfdc = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/rfdc@1.3.0/node_modules/rfdc/index.js"(exports, module2) {
    "use strict";
    module2.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles)
        return rfdcCircles(opts);
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      var refs = [];
      var refsNew = [];
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            var index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});
var require_default = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/rfdc@1.3.0/node_modules/rfdc/default.js"(exports, module2) {
    "use strict";
    module2.exports = require_rfdc()();
  }
});
var require_prepared_statement_error = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/error/prepared-statement-error.js"(exports, module2) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var PreparedStatementError = class extends MSSQLError {
      /**
       * Creates a new PreparedStatementError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        this.name = "PreparedStatementError";
      }
    };
    module2.exports = PreparedStatementError;
  }
});
var require_request_error = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/error/request-error.js"(exports, module2) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var RequestError = class extends MSSQLError {
      /**
       * Creates a new RequestError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        if (message instanceof Error) {
          if (message.info) {
            this.number = message.info.number || message.code;
            this.lineNumber = message.info.lineNumber;
            this.state = message.info.state || message.sqlstate;
            this.class = message.info.class;
            this.serverName = message.info.serverName;
            this.procName = message.info.procName;
          } else {
            this.number = message.code;
            this.lineNumber = message.lineNumber;
            this.state = message.sqlstate;
            this.class = message.severity;
            this.serverName = message.serverName;
            this.procName = message.procName;
          }
        }
        this.name = "RequestError";
        const parsedMessage = /^\[Microsoft\]\[SQL Server Native Client 11\.0\](?:\[SQL Server\])?([\s\S]*)$/.exec(this.message);
        if (parsedMessage) {
          this.message = parsedMessage[1];
        }
      }
    };
    module2.exports = RequestError;
  }
});
var require_transaction_error = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/error/transaction-error.js"(exports, module2) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var TransactionError = class extends MSSQLError {
      /**
       * Creates a new TransactionError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        this.name = "TransactionError";
      }
    };
    module2.exports = TransactionError;
  }
});
var require_error = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/error/index.js"(exports, module2) {
    "use strict";
    var ConnectionError = require_connection_error();
    var MSSQLError = require_mssql_error();
    var PreparedStatementError = require_prepared_statement_error();
    var RequestError = require_request_error();
    var TransactionError = require_transaction_error();
    module2.exports = {
      ConnectionError,
      MSSQLError,
      PreparedStatementError,
      RequestError,
      TransactionError
    };
  }
});
var require_connection_pool = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/base/connection-pool.js"(exports, module2) {
    "use strict";
    var { EventEmitter } = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var debug = (0, import_chunk_MXIGSN4X.require_src)()("mssql:base");
    var { parseSqlConnectionString } = require_lib2();
    var tarn = require_tarn();
    var { IDS } = require_utils2();
    var ConnectionError = require_connection_error();
    var shared = require_shared();
    var clone = require_default();
    var { MSSQLError } = require_error();
    var ConnectionPool = class extends EventEmitter {
      /**
       * Create new Connection.
       *
       * @param {Object|String} config Connection configuration object or connection string.
       * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred.
       */
      constructor(config, callback) {
        super();
        IDS.add(this, "ConnectionPool");
        debug("pool(%d): created", IDS.get(this));
        this._connectStack = [];
        this._closeStack = [];
        this._connected = false;
        this._connecting = false;
        this._healthy = false;
        if (typeof config === "string") {
          try {
            this.config = this.constructor.parseConnectionString(config);
          } catch (ex) {
            if (typeof callback === "function") {
              return setImmediate(callback, ex);
            }
            throw ex;
          }
        } else {
          this.config = clone(config);
        }
        this.config.port = this.config.port || 1433;
        this.config.options = this.config.options || {};
        this.config.stream = this.config.stream || false;
        this.config.parseJSON = this.config.parseJSON || false;
        this.config.arrayRowMode = this.config.arrayRowMode || false;
        this.config.validateConnection = "validateConnection" in this.config ? this.config.validateConnection : true;
        const namedServer = /^(.*)\\(.*)$/.exec(this.config.server);
        if (namedServer) {
          this.config.server = namedServer[1];
          this.config.options.instanceName = namedServer[2];
        }
        if (typeof this.config.options.useColumnNames !== "undefined" && this.config.options.useColumnNames !== true) {
          const ex = new MSSQLError("Invalid options `useColumnNames`, use `arrayRowMode` instead");
          if (typeof callback === "function") {
            return setImmediate(callback, ex);
          }
          throw ex;
        }
        if (typeof callback === "function") {
          this.connect(callback);
        }
      }
      get connected() {
        return this._connected;
      }
      get connecting() {
        return this._connecting;
      }
      get healthy() {
        return this._healthy;
      }
      static parseConnectionString(connectionString) {
        return this._parseConnectionString(connectionString);
      }
      static _parseAuthenticationType(type2, entries) {
        switch (type2.toLowerCase()) {
          case "active directory integrated":
            if (entries.includes("token")) {
              return "azure-active-directory-access-token";
            } else if (["client id", "client secret", "tenant id"].every((entry) => entries.includes(entry))) {
              return "azure-active-directory-service-principal-secret";
            } else if (["client id", "msi endpoint", "msi secret"].every((entry) => entries.includes(entry))) {
              return "azure-active-directory-msi-app-service";
            } else if (["client id", "msi endpoint"].every((entry) => entries.includes(entry))) {
              return "azure-active-directory-msi-vm";
            }
            return "azure-active-directory-default";
          case "active directory password":
            return "azure-active-directory-password";
          case "ntlm":
            return "ntlm";
          default:
            return "default";
        }
      }
      static _parseConnectionString(connectionString) {
        const parsed = parseSqlConnectionString(connectionString, true, true);
        return Object.entries(parsed).reduce((config, [key, value]) => {
          switch (key) {
            case "application name":
              break;
            case "applicationintent":
              Object.assign(config.options, {
                readOnlyIntent: value === "readonly"
              });
              break;
            case "asynchronous processing":
              break;
            case "attachdbfilename":
              break;
            case "authentication":
              Object.assign(config, {
                authentication_type: this._parseAuthenticationType(value, Object.keys(parsed))
              });
              break;
            case "column encryption setting":
              break;
            case "connection timeout":
              Object.assign(config, {
                connectionTimeout: value * 1e3
              });
              break;
            case "connection lifetime":
              break;
            case "connectretrycount":
              break;
            case "connectretryinterval":
              Object.assign(config.options, {
                connectionRetryInterval: value * 1e3
              });
              break;
            case "context connection":
              break;
            case "client id":
              Object.assign(config, {
                clientId: value
              });
              break;
            case "client secret":
              Object.assign(config, {
                clientSecret: value
              });
              break;
            case "current language":
              Object.assign(config.options, {
                language: value
              });
              break;
            case "data source": {
              let server = value;
              let instanceName;
              let port = 1433;
              if (/^np:/i.test(server)) {
                throw new Error("Connection via Named Pipes is not supported.");
              }
              if (/^tcp:/i.test(server)) {
                server = server.substr(4);
              }
              const namedServerParts = /^(.*)\\(.*)$/.exec(server);
              if (namedServerParts) {
                server = namedServerParts[1].trim();
                instanceName = namedServerParts[2].trim();
              }
              const serverParts = /^(.*),(.*)$/.exec(server);
              if (serverParts) {
                server = serverParts[1].trim();
                port = parseInt(serverParts[2].trim(), 10);
              } else {
                const instanceParts = /^(.*),(.*)$/.exec(instanceName);
                if (instanceParts) {
                  instanceName = instanceParts[1].trim();
                  port = parseInt(instanceParts[2].trim(), 10);
                }
              }
              if (server === "." || server === "(.)" || server.toLowerCase() === "(localdb)" || server.toLowerCase() === "(local)") {
                server = "localhost";
              }
              Object.assign(config, {
                port,
                server
              });
              if (instanceName) {
                Object.assign(config.options, {
                  instanceName
                });
              }
              break;
            }
            case "encrypt":
              Object.assign(config.options, {
                encrypt: !!value
              });
              break;
            case "enlist":
              break;
            case "failover partner":
              break;
            case "initial catalog":
              Object.assign(config, {
                database: value
              });
              break;
            case "integrated security":
              break;
            case "max pool size":
              Object.assign(config.pool, {
                max: value
              });
              break;
            case "min pool size":
              Object.assign(config.pool, {
                min: value
              });
              break;
            case "msi endpoint":
              Object.assign(config, {
                msiEndpoint: value
              });
              break;
            case "msi secret":
              Object.assign(config, {
                msiSecret: value
              });
              break;
            case "multipleactiveresultsets":
              break;
            case "multisubnetfailover":
              Object.assign(config.options, {
                multiSubnetFailover: value
              });
              break;
            case "network library":
              break;
            case "packet size":
              Object.assign(config.options, {
                packetSize: value
              });
              break;
            case "password":
              Object.assign(config, {
                password: value
              });
              break;
            case "persist security info":
              break;
            case "poolblockingperiod":
              break;
            case "pooling":
              break;
            case "replication":
              break;
            case "tenant id":
              Object.assign(config, {
                tenantId: value
              });
              break;
            case "token":
              Object.assign(config, {
                token: value
              });
              break;
            case "transaction binding":
              Object.assign(config.options, {
                enableImplicitTransactions: value.toLowerCase() === "implicit unbind"
              });
              break;
            case "transparentnetworkipresolution":
              break;
            case "trustservercertificate":
              Object.assign(config.options, {
                trustServerCertificate: value
              });
              break;
            case "type system version":
              break;
            case "user id": {
              let user = value;
              let domain;
              const domainUser = /^(.*)\\(.*)$/.exec(user);
              if (domainUser) {
                domain = domainUser[1];
                user = domainUser[2];
              }
              if (domain) {
                Object.assign(config, {
                  domain
                });
              }
              if (user) {
                Object.assign(config, {
                  user
                });
              }
              break;
            }
            case "user instance":
              break;
            case "workstation id":
              Object.assign(config.options, {
                workstationId: value
              });
              break;
            case "request timeout":
              Object.assign(config, {
                requestTimeout: parseInt(value, 10)
              });
              break;
            case "stream":
              Object.assign(config, {
                stream: !!value
              });
              break;
            case "useutc":
              Object.assign(config.options, {
                useUTC: !!value
              });
              break;
            case "parsejson":
              Object.assign(config, {
                parseJSON: !!value
              });
              break;
          }
          return config;
        }, { options: {}, pool: {} });
      }
      /**
       * Acquire connection from this connection pool.
       *
       * @param {ConnectionPool|Transaction|PreparedStatement} requester Requester.
       * @param {acquireCallback} [callback] A callback which is called after connection has been acquired, or an error has occurred. If omited, method returns Promise.
       * @return {ConnectionPool|Promise}
       */
      acquire(requester, callback) {
        const acquirePromise = shared.Promise.resolve(this._acquire()).catch((err) => {
          this.emit("error", err);
          throw err;
        });
        if (typeof callback === "function") {
          acquirePromise.then((connection) => callback(null, connection, this.config)).catch(callback);
          return this;
        }
        return acquirePromise;
      }
      _acquire() {
        if (!this.pool) {
          return shared.Promise.reject(new ConnectionError("Connection not yet open.", "ENOTOPEN"));
        } else if (this.pool.destroyed) {
          return shared.Promise.reject(new ConnectionError("Connection is closing", "ENOTOPEN"));
        }
        return this.pool.acquire().promise;
      }
      /**
       * Release connection back to the pool.
       *
       * @param {Connection} connection Previously acquired connection.
       * @return {ConnectionPool}
       */
      release(connection) {
        debug("connection(%d): released", IDS.get(connection));
        if (this.pool) {
          this.pool.release(connection);
        }
        return this;
      }
      /**
       * Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.
       *
       * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
       * @return {ConnectionPool|Promise}
       */
      connect(callback) {
        if (typeof callback === "function") {
          this._connect(callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          return this._connect((err) => {
            if (err)
              return reject(err);
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} callback
       */
      _connect(callback) {
        if (this._connected) {
          debug("pool(%d): already connected, executing connect callback immediately", IDS.get(this));
          return setImmediate(callback, null, this);
        }
        this._connectStack.push(callback);
        if (this._connecting) {
          return;
        }
        this._connecting = true;
        debug("pool(%d): connecting", IDS.get(this));
        this._poolCreate().then((connection) => {
          debug("pool(%d): connected", IDS.get(this));
          this._healthy = true;
          return this._poolDestroy(connection).then(() => {
            this.pool = new tarn.Pool(
              Object.assign({
                create: () => this._poolCreate().then((connection2) => {
                  this._healthy = true;
                  return connection2;
                }).catch((err) => {
                  if (this.pool.numUsed() + this.pool.numFree() <= 0) {
                    this._healthy = false;
                  }
                  throw err;
                }),
                validate: this._poolValidate.bind(this),
                destroy: this._poolDestroy.bind(this),
                max: 10,
                min: 0,
                idleTimeoutMillis: 3e4,
                propagateCreateError: true
              }, this.config.pool)
            );
            this._connecting = false;
            this._connected = true;
          });
        }).then(() => {
          this._connectStack.forEach((cb) => {
            setImmediate(cb, null, this);
          });
        }).catch((err) => {
          this._connecting = false;
          this._connectStack.forEach((cb) => {
            setImmediate(cb, err);
          });
        }).then(() => {
          this._connectStack = [];
        });
      }
      get size() {
        return this.pool.numFree() + this.pool.numUsed() + this.pool.numPendingCreates();
      }
      get available() {
        return this.pool.numFree();
      }
      get pending() {
        return this.pool.numPendingAcquires();
      }
      get borrowed() {
        return this.pool.numUsed();
      }
      /**
       * Close all active connections in the pool.
       *
       * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.
       * @return {ConnectionPool|Promise}
       */
      close(callback) {
        if (typeof callback === "function") {
          this._close(callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._close((err) => {
            if (err)
              return reject(err);
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} callback
       */
      _close(callback) {
        if (this._connecting) {
          debug("pool(%d): close called while connecting", IDS.get(this));
          setImmediate(callback, new ConnectionError("Cannot close a pool while it is connecting"));
        }
        if (!this.pool) {
          debug("pool(%d): already closed, executing close callback immediately", IDS.get(this));
          return setImmediate(callback, null);
        }
        this._closeStack.push(callback);
        if (this.pool.destroyed)
          return;
        this._connecting = this._connected = this._healthy = false;
        this.pool.destroy().then(() => {
          debug("pool(%d): pool closed, removing pool reference and executing close callbacks", IDS.get(this));
          this.pool = null;
          this._closeStack.forEach((cb) => {
            setImmediate(cb, null);
          });
        }).catch((err) => {
          this.pool = null;
          this._closeStack.forEach((cb) => {
            setImmediate(cb, err);
          });
        }).then(() => {
          this._closeStack = [];
        });
      }
      /**
       * Returns new request using this connection.
       *
       * @return {Request}
       */
      request() {
        return new shared.driver.Request(this);
      }
      /**
       * Returns new transaction using this connection.
       *
       * @return {Transaction}
       */
      transaction() {
        return new shared.driver.Transaction(this);
      }
      /**
       * Creates a new query using this connection from a tagged template string.
       *
       * @variation 1
       * @param {Array} strings Array of string literals.
       * @param {...*} keys Values.
       * @return {Request}
       */
      /**
       * Execute the SQL command.
       *
       * @variation 2
       * @param {String} command T-SQL command to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      query() {
        if (typeof arguments[0] === "string") {
          return new shared.driver.Request(this).query(arguments[0], arguments[1]);
        }
        const values = Array.prototype.slice.call(arguments);
        const strings = values.shift();
        return new shared.driver.Request(this)._template(strings, values, "query");
      }
      /**
       * Creates a new batch using this connection from a tagged template string.
       *
       * @variation 1
       * @param {Array} strings Array of string literals.
       * @param {...*} keys Values.
       * @return {Request}
       */
      /**
       * Execute the SQL command.
       *
       * @variation 2
       * @param {String} command T-SQL command to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      batch() {
        if (typeof arguments[0] === "string") {
          return new shared.driver.Request(this).batch(arguments[0], arguments[1]);
        }
        const values = Array.prototype.slice.call(arguments);
        const strings = values.shift();
        return new shared.driver.Request(this)._template(strings, values, "batch");
      }
    };
    module2.exports = ConnectionPool;
  }
});
var require_global_connection = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/global-connection.js"(exports, module2) {
    "use strict";
    var shared = require_shared();
    var globalConnection = null;
    var globalConnectionHandlers = {};
    function connect(config, callback) {
      if (!globalConnection) {
        globalConnection = new shared.driver.ConnectionPool(config);
        for (const event in globalConnectionHandlers) {
          for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {
            globalConnection.on(event, globalConnectionHandlers[event][i]);
          }
        }
        const ogClose = globalConnection.close;
        const globalClose = function(callback2) {
          for (const event in globalConnectionHandlers) {
            for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {
              this.removeListener(event, globalConnectionHandlers[event][i]);
            }
          }
          this.on("error", (err) => {
            if (globalConnectionHandlers.error) {
              for (let i = 0, l = globalConnectionHandlers.error.length; i < l; i++) {
                globalConnectionHandlers.error[i].call(this, err);
              }
            }
          });
          globalConnection = null;
          return ogClose.call(this, callback2);
        };
        globalConnection.close = globalClose.bind(globalConnection);
      }
      if (typeof callback === "function") {
        return globalConnection.connect((err, connection) => {
          if (err) {
            globalConnection = null;
          }
          callback(err, connection);
        });
      }
      return globalConnection.connect().catch((err) => {
        globalConnection = null;
        return shared.Promise.reject(err);
      });
    }
    function close(callback) {
      if (globalConnection) {
        const gc = globalConnection;
        globalConnection = null;
        return gc.close(callback);
      }
      if (typeof callback === "function") {
        setImmediate(callback);
        return null;
      }
      return new shared.Promise((resolve) => {
        resolve(globalConnection);
      });
    }
    function on(event, handler) {
      if (!globalConnectionHandlers[event])
        globalConnectionHandlers[event] = [];
      globalConnectionHandlers[event].push(handler);
      if (globalConnection)
        globalConnection.on(event, handler);
      return globalConnection;
    }
    function removeListener(event, handler) {
      if (!globalConnectionHandlers[event])
        return globalConnection;
      const index = globalConnectionHandlers[event].indexOf(handler);
      if (index === -1)
        return globalConnection;
      globalConnectionHandlers[event].splice(index, 1);
      if (globalConnectionHandlers[event].length === 0)
        globalConnectionHandlers[event] = void 0;
      if (globalConnection)
        globalConnection.removeListener(event, handler);
      return globalConnection;
    }
    function query() {
      if (typeof arguments[0] === "string") {
        return new shared.driver.Request().query(arguments[0], arguments[1]);
      }
      const values = Array.prototype.slice.call(arguments);
      const strings = values.shift();
      return new shared.driver.Request()._template(strings, values, "query");
    }
    function batch() {
      if (typeof arguments[0] === "string") {
        return new shared.driver.Request().batch(arguments[0], arguments[1]);
      }
      const values = Array.prototype.slice.call(arguments);
      const strings = values.shift();
      return new shared.driver.Request()._template(strings, values, "batch");
    }
    module2.exports = {
      batch,
      close,
      connect,
      off: removeListener,
      on,
      query,
      removeListener
    };
    Object.defineProperty(module2.exports, "pool", {
      get: () => {
        return globalConnection;
      },
      set: () => {
      }
    });
  }
});
var require_prepared_statement = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/base/prepared-statement.js"(exports, module2) {
    "use strict";
    var debug = (0, import_chunk_MXIGSN4X.require_src)()("mssql:base");
    var { EventEmitter } = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var { IDS, objectHasProperty } = require_utils2();
    var globalConnection = require_global_connection();
    var { TransactionError, PreparedStatementError } = require_error();
    var shared = require_shared();
    var { TYPES, declare } = require_datatypes();
    var PreparedStatement = class extends EventEmitter {
      /**
       * Creates a new Prepared Statement.
       *
       * @param {ConnectionPool|Transaction} [holder]
       */
      constructor(parent) {
        super();
        IDS.add(this, "PreparedStatement");
        debug("ps(%d): created", IDS.get(this));
        this.parent = parent || globalConnection.pool;
        this._handle = 0;
        this.prepared = false;
        this.parameters = {};
      }
      get config() {
        return this.parent.config;
      }
      get connected() {
        return this.parent.connected;
      }
      /**
       * Acquire connection from connection pool.
       *
       * @param {Request} request Request.
       * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
       * @return {PreparedStatement|Promise}
       */
      acquire(request3, callback) {
        if (!this._acquiredConnection) {
          setImmediate(callback, new PreparedStatementError("Statement is not prepared. Call prepare() first.", "ENOTPREPARED"));
          return this;
        }
        if (this._activeRequest) {
          setImmediate(callback, new TransactionError("Can't acquire connection for the request. There is another request in progress.", "EREQINPROG"));
          return this;
        }
        this._activeRequest = request3;
        setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);
        return this;
      }
      /**
       * Release connection back to the pool.
       *
       * @param {Connection} connection Previously acquired connection.
       * @return {PreparedStatement}
       */
      release(connection) {
        if (connection === this._acquiredConnection) {
          this._activeRequest = null;
        }
        return this;
      }
      /**
       * Add an input parameter to the prepared statement.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} type SQL data type of input parameter.
       * @return {PreparedStatement}
       */
      input(name3, type2) {
        if (/--| |\/\*|\*\/|'/.test(name3)) {
          throw new PreparedStatementError(`SQL injection warning for param '${name3}'`, "EINJECT");
        }
        if (arguments.length < 2) {
          throw new PreparedStatementError("Invalid number of arguments. 2 arguments expected.", "EARGS");
        }
        if (type2 instanceof Function) {
          type2 = type2();
        }
        if (objectHasProperty(this.parameters, name3)) {
          throw new PreparedStatementError(`The parameter name ${name3} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name3] = {
          name: name3,
          type: type2.type,
          io: 1,
          length: type2.length,
          scale: type2.scale,
          precision: type2.precision,
          tvpType: type2.tvpType
        };
        return this;
      }
      /**
       * Replace an input parameter on the request.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
       * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
       * @return {Request}
       */
      replaceInput(name3, type2, value) {
        delete this.parameters[name3];
        return this.input(name3, type2, value);
      }
      /**
       * Add an output parameter to the prepared statement.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @return {PreparedStatement}
       */
      output(name3, type2) {
        if (/--| |\/\*|\*\/|'/.test(name3)) {
          throw new PreparedStatementError(`SQL injection warning for param '${name3}'`, "EINJECT");
        }
        if (arguments.length < 2) {
          throw new PreparedStatementError("Invalid number of arguments. 2 arguments expected.", "EARGS");
        }
        if (type2 instanceof Function)
          type2 = type2();
        if (objectHasProperty(this.parameters, name3)) {
          throw new PreparedStatementError(`The parameter name ${name3} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name3] = {
          name: name3,
          type: type2.type,
          io: 2,
          length: type2.length,
          scale: type2.scale,
          precision: type2.precision
        };
        return this;
      }
      /**
       * Replace an output parameter on the request.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @return {PreparedStatement}
       */
      replaceOutput(name3, type2) {
        delete this.parameters[name3];
        return this.output(name3, type2);
      }
      /**
       * Prepare a statement.
       *
       * @param {String} statement SQL statement to prepare.
       * @param {basicCallback} [callback] A callback which is called after preparation has completed, or an error has occurred. If omited, method returns Promise.
       * @return {PreparedStatement|Promise}
       */
      prepare(statement, callback) {
        if (typeof callback === "function") {
          this._prepare(statement, callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._prepare(statement, (err) => {
            if (err)
              return reject(err);
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {String} statement
       * @param {basicCallback} callback
       */
      _prepare(statement, callback) {
        debug("ps(%d): prepare", IDS.get(this));
        if (typeof statement === "function") {
          callback = statement;
          statement = void 0;
        }
        if (this.prepared) {
          return setImmediate(callback, new PreparedStatementError("Statement is already prepared.", "EALREADYPREPARED"));
        }
        this.statement = statement || this.statement;
        this.parent.acquire(this, (err, connection, config) => {
          if (err)
            return callback(err);
          this._acquiredConnection = connection;
          this._acquiredConfig = config;
          const req = new shared.driver.Request(this);
          req.stream = false;
          req.output("handle", TYPES.Int);
          req.input("params", TYPES.NVarChar, (() => {
            const result = [];
            for (const name3 in this.parameters) {
              if (!objectHasProperty(this.parameters, name3)) {
                continue;
              }
              const param = this.parameters[name3];
              result.push(`@${name3} ${declare(param.type, param)}${param.io === 2 ? " output" : ""}`);
            }
            return result;
          })().join(","));
          req.input("stmt", TYPES.NVarChar, this.statement);
          req.execute("sp_prepare", (err2, result) => {
            if (err2) {
              this.parent.release(this._acquiredConnection);
              this._acquiredConnection = null;
              this._acquiredConfig = null;
              return callback(err2);
            }
            debug("ps(%d): prepared", IDS.get(this));
            this._handle = result.output.handle;
            this.prepared = true;
            callback(null);
          });
        });
      }
      /**
       * Execute a prepared statement.
       *
       * @param {Object} values An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.
       * @param {basicCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      execute(values, callback) {
        if (this.stream || typeof callback === "function") {
          return this._execute(values, callback);
        }
        return new shared.Promise((resolve, reject) => {
          this._execute(values, (err, recordset) => {
            if (err)
              return reject(err);
            resolve(recordset);
          });
        });
      }
      /**
       * @private
       * @param {Object} values
       * @param {basicCallback} callback
       */
      _execute(values, callback) {
        const req = new shared.driver.Request(this);
        req.stream = this.stream;
        req.arrayRowMode = this.arrayRowMode;
        req.input("handle", TYPES.Int, this._handle);
        for (const name3 in this.parameters) {
          if (!objectHasProperty(this.parameters, name3)) {
            continue;
          }
          const param = this.parameters[name3];
          req.parameters[name3] = {
            name: name3,
            type: param.type,
            io: param.io,
            value: values[name3],
            length: param.length,
            scale: param.scale,
            precision: param.precision
          };
        }
        req.execute("sp_execute", (err, result) => {
          if (err)
            return callback(err);
          callback(null, result);
        });
        return req;
      }
      /**
       * Unprepare a prepared statement.
       *
       * @param {basicCallback} [callback] A callback which is called after unpreparation has completed, or an error has occurred. If omited, method returns Promise.
       * @return {PreparedStatement|Promise}
       */
      unprepare(callback) {
        if (typeof callback === "function") {
          this._unprepare(callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._unprepare((err) => {
            if (err)
              return reject(err);
            resolve();
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} callback
       */
      _unprepare(callback) {
        debug("ps(%d): unprepare", IDS.get(this));
        if (!this.prepared) {
          return setImmediate(callback, new PreparedStatementError("Statement is not prepared. Call prepare() first.", "ENOTPREPARED"));
        }
        if (this._activeRequest) {
          return setImmediate(callback, new TransactionError("Can't unprepare the statement. There is a request in progress.", "EREQINPROG"));
        }
        const req = new shared.driver.Request(this);
        req.stream = false;
        req.input("handle", TYPES.Int, this._handle);
        req.execute("sp_unprepare", (err) => {
          if (err)
            return callback(err);
          this.parent.release(this._acquiredConnection);
          this._acquiredConnection = null;
          this._acquiredConfig = null;
          this._handle = 0;
          this.prepared = false;
          debug("ps(%d): unprepared", IDS.get(this));
          return callback(null);
        });
      }
    };
    module2.exports = PreparedStatement;
  }
});
var require_request = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/base/request.js"(exports, module2) {
    "use strict";
    var debug = (0, import_chunk_MXIGSN4X.require_src)()("mssql:base");
    var { EventEmitter } = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var { Readable } = (0, import_chunk_FVJ3R4NJ.__require)("stream");
    var { IDS, objectHasProperty } = require_utils2();
    var globalConnection = require_global_connection();
    var { RequestError, ConnectionError } = require_error();
    var { TYPES } = require_datatypes();
    var shared = require_shared();
    var Request = class extends EventEmitter {
      /**
       * Create new Request.
       *
       * @param {Connection|ConnectionPool|Transaction|PreparedStatement} parent If omitted, global connection is used instead.
       */
      constructor(parent) {
        super();
        IDS.add(this, "Request");
        debug("request(%d): created", IDS.get(this));
        this.canceled = false;
        this._paused = false;
        this.parent = parent || globalConnection.pool;
        this.parameters = {};
        this.stream = null;
        this.arrayRowMode = null;
      }
      get paused() {
        return this._paused;
      }
      /**
       * Generate sql string and set input parameters from tagged template string.
       *
       * @param {Template literal} template
       * @return {String}
       */
      template() {
        const values = Array.prototype.slice.call(arguments);
        const strings = values.shift();
        return this._template(strings, values);
      }
      /**
       * Fetch request from tagged template string.
       *
       * @private
       * @param {Array} strings
       * @param {Array} values
       * @param {String} [method] If provided, method is automatically called with serialized command on this object.
       * @return {Request}
       */
      _template(strings, values, method) {
        const command = [strings[0]];
        for (let index = 0; index < values.length; index++) {
          const value = values[index];
          if (Array.isArray(value)) {
            for (let parameterIndex = 0; parameterIndex < value.length; parameterIndex++) {
              this.input(`param${index + 1}_${parameterIndex}`, value[parameterIndex]);
              command.push(`@param${index + 1}_${parameterIndex}`);
              if (parameterIndex < value.length - 1) {
                command.push(", ");
              }
            }
            command.push(strings[index + 1]);
          } else {
            this.input(`param${index + 1}`, value);
            command.push(`@param${index + 1}`, strings[index + 1]);
          }
        }
        if (method) {
          return this[method](command.join(""));
        } else {
          return command.join("");
        }
      }
      /**
       * Add an input parameter to the request.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
       * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
       * @return {Request}
       */
      input(name3, type2, value) {
        if (/--| |\/\*|\*\/|'/.test(name3)) {
          throw new RequestError(`SQL injection warning for param '${name3}'`, "EINJECT");
        }
        if (arguments.length < 2) {
          throw new RequestError("Invalid number of arguments. At least 2 arguments expected.", "EARGS");
        } else if (arguments.length === 2) {
          value = type2;
          type2 = shared.getTypeByValue(value);
        }
        if (value && typeof value.valueOf === "function" && !(value instanceof Date))
          value = value.valueOf();
        if (value === void 0)
          value = null;
        if (typeof value === "number" && isNaN(value))
          value = null;
        if (type2 instanceof Function)
          type2 = type2();
        if (objectHasProperty(this.parameters, name3)) {
          throw new RequestError(`The parameter name ${name3} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name3] = {
          name: name3,
          type: type2.type,
          io: 1,
          value,
          length: type2.length,
          scale: type2.scale,
          precision: type2.precision,
          tvpType: type2.tvpType
        };
        return this;
      }
      /**
       * Replace an input parameter on the request.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
       * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
       * @return {Request}
       */
      replaceInput(name3, type2, value) {
        delete this.parameters[name3];
        return this.input(name3, type2, value);
      }
      /**
       * Add an output parameter to the request.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
       * @return {Request}
       */
      output(name3, type2, value) {
        if (!type2) {
          type2 = TYPES.NVarChar;
        }
        if (/--| |\/\*|\*\/|'/.test(name3)) {
          throw new RequestError(`SQL injection warning for param '${name3}'`, "EINJECT");
        }
        if (type2 === TYPES.Text || type2 === TYPES.NText || type2 === TYPES.Image) {
          throw new RequestError("Deprecated types (Text, NText, Image) are not supported as OUTPUT parameters.", "EDEPRECATED");
        }
        if (value && typeof value.valueOf === "function" && !(value instanceof Date))
          value = value.valueOf();
        if (value === void 0)
          value = null;
        if (typeof value === "number" && isNaN(value))
          value = null;
        if (type2 instanceof Function)
          type2 = type2();
        if (objectHasProperty(this.parameters, name3)) {
          throw new RequestError(`The parameter name ${name3} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name3] = {
          name: name3,
          type: type2.type,
          io: 2,
          value,
          length: type2.length,
          scale: type2.scale,
          precision: type2.precision
        };
        return this;
      }
      /**
       * Replace an output parameter on the request.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
       * @return {Request}
       */
      replaceOutput(name3, type2, value) {
        delete this.parameters[name3];
        return this.output(name3, type2, value);
      }
      /**
       * Execute the SQL batch.
       *
       * @param {String} batch T-SQL batch to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      batch(batch, callback) {
        if (this.stream === null && this.parent)
          this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent)
          this.arrayRowMode = this.parent.config.arrayRowMode;
        this.rowsAffected = 0;
        if (typeof callback === "function") {
          this._batch(batch, (err, recordsets, output, rowsAffected) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err)
              return callback(err);
            callback(null, {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            });
          });
          return this;
        }
        if (typeof batch === "object") {
          const values = Array.prototype.slice.call(arguments);
          const strings = values.shift();
          batch = this._template(strings, values);
        }
        return new shared.Promise((resolve, reject) => {
          this._batch(batch, (err, recordsets, output, rowsAffected) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err)
              return reject(err);
            resolve({
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            });
          });
        });
      }
      /**
       * @private
       * @param {String} batch
       * @param {Request~requestCallback} callback
       */
      _batch(batch, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Bulk load.
       *
       * @param {Table} table SQL table.
       * @param {object} [options] Options to be passed to the underlying driver (tedious only).
       * @param {Request~bulkCallback} [callback] A callback which is called after bulk load has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      bulk(table, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else if (typeof options === "undefined") {
          options = {};
        }
        if (this.stream === null && this.parent)
          this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent)
          this.arrayRowMode = this.parent.config.arrayRowMode;
        if (this.stream || typeof callback === "function") {
          this._bulk(table, options, (err, rowsAffected) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              return this.emit("done", {
                rowsAffected
              });
            }
            if (err)
              return callback(err);
            callback(null, {
              rowsAffected
            });
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._bulk(table, options, (err, rowsAffected) => {
            if (err)
              return reject(err);
            resolve({
              rowsAffected
            });
          });
        });
      }
      /**
       * @private
       * @param {Table} table
       * @param {object} options
       * @param {Request~bulkCallback} callback
       */
      _bulk(table, options, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Wrap original request in a Readable stream that supports back pressure and return.
       * It also sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
       *
       * @param {Object} streamOptions - optional options to configure the readable stream with like highWaterMark
       * @return {Stream}
       */
      toReadableStream(streamOptions = {}) {
        this.stream = true;
        this.pause();
        const readableStream = new Readable({
          ...streamOptions,
          objectMode: true,
          read: () => {
            this.resume();
          }
        });
        this.on("row", (row) => {
          if (!readableStream.push(row)) {
            this.pause();
          }
        });
        this.on("error", (error) => {
          readableStream.emit("error", error);
        });
        this.on("done", () => {
          readableStream.push(null);
        });
        return readableStream;
      }
      /**
       * Wrap original request in a Readable stream that supports back pressure and pipe to the Writable stream.
       * It also sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
       *
       * @param {Stream} stream Stream to pipe data into.
       * @return {Stream}
       */
      pipe(writableStream) {
        const readableStream = this.toReadableStream();
        return readableStream.pipe(writableStream);
      }
      /**
       * Execute the SQL command.
       *
       * @param {String} command T-SQL command to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      query(command, callback) {
        if (this.stream === null && this.parent)
          this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent)
          this.arrayRowMode = this.parent.config.arrayRowMode;
        this.rowsAffected = 0;
        if (typeof callback === "function") {
          this._query(command, (err, recordsets, output, rowsAffected, columns) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err)
              return callback(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            };
            if (this.arrayRowMode)
              result.columns = columns;
            callback(null, result);
          });
          return this;
        }
        if (typeof command === "object") {
          const values = Array.prototype.slice.call(arguments);
          const strings = values.shift();
          command = this._template(strings, values);
        }
        return new shared.Promise((resolve, reject) => {
          this._query(command, (err, recordsets, output, rowsAffected, columns) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err)
              return reject(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            };
            if (this.arrayRowMode)
              result.columns = columns;
            resolve(result);
          });
        });
      }
      /**
       * @private
       * @param {String} command
       * @param {Request~bulkCallback} callback
       */
      _query(command, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Call a stored procedure.
       *
       * @param {String} procedure Name of the stored procedure to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      execute(command, callback) {
        if (this.stream === null && this.parent)
          this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent)
          this.arrayRowMode = this.parent.config.arrayRowMode;
        this.rowsAffected = 0;
        if (typeof callback === "function") {
          this._execute(command, (err, recordsets, output, returnValue, rowsAffected, columns) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected,
                returnValue
              });
            }
            if (err)
              return callback(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected,
              returnValue
            };
            if (this.arrayRowMode)
              result.columns = columns;
            callback(null, result);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._execute(command, (err, recordsets, output, returnValue, rowsAffected, columns) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected,
                returnValue
              });
            }
            if (err)
              return reject(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected,
              returnValue
            };
            if (this.arrayRowMode)
              result.columns = columns;
            resolve(result);
          });
        });
      }
      /**
       * @private
       * @param {String} procedure
       * @param {Request~bulkCallback} callback
       */
      _execute(procedure, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Cancel currently executed request.
       *
       * @return {Boolean}
       */
      cancel() {
        this._cancel();
        return true;
      }
      /**
       * @private
       */
      _cancel() {
        this.canceled = true;
      }
      pause() {
        if (this.stream) {
          this._pause();
          return true;
        }
        return false;
      }
      _pause() {
        this._paused = true;
      }
      resume() {
        if (this.stream) {
          this._resume();
          return true;
        }
        return false;
      }
      _resume() {
        this._paused = false;
      }
      _setCurrentRequest(request3) {
        this._currentRequest = request3;
        if (this._paused) {
          this.pause();
        }
        return this;
      }
    };
    module2.exports = Request;
  }
});
var require_isolationlevel = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/isolationlevel.js"(exports, module2) {
    "use strict";
    module2.exports = {
      READ_UNCOMMITTED: 1,
      READ_COMMITTED: 2,
      REPEATABLE_READ: 3,
      SERIALIZABLE: 4,
      SNAPSHOT: 5
    };
  }
});
var require_transaction = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/base/transaction.js"(exports, module2) {
    "use strict";
    var debug = (0, import_chunk_MXIGSN4X.require_src)()("mssql:base");
    var { EventEmitter } = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var { IDS } = require_utils2();
    var globalConnection = require_global_connection();
    var { TransactionError } = require_error();
    var shared = require_shared();
    var ISOLATION_LEVEL = require_isolationlevel();
    var Transaction = class _Transaction extends EventEmitter {
      /**
       * Create new Transaction.
       *
       * @param {Connection} [parent] If ommited, global connection is used instead.
       */
      constructor(parent) {
        super();
        IDS.add(this, "Transaction");
        debug("transaction(%d): created", IDS.get(this));
        this.parent = parent || globalConnection.pool;
        this.isolationLevel = _Transaction.defaultIsolationLevel;
        this.name = "";
      }
      get config() {
        return this.parent.config;
      }
      get connected() {
        return this.parent.connected;
      }
      /**
       * Acquire connection from connection pool.
       *
       * @param {Request} request Request.
       * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      acquire(request3, callback) {
        if (!this._acquiredConnection) {
          setImmediate(callback, new TransactionError("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
          return this;
        }
        if (this._activeRequest) {
          setImmediate(callback, new TransactionError("Can't acquire connection for the request. There is another request in progress.", "EREQINPROG"));
          return this;
        }
        this._activeRequest = request3;
        setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);
        return this;
      }
      /**
       * Release connection back to the pool.
       *
       * @param {Connection} connection Previously acquired connection.
       * @return {Transaction}
       */
      release(connection) {
        if (connection === this._acquiredConnection) {
          this._activeRequest = null;
        }
        return this;
      }
      /**
       * Begin a transaction.
       *
       * @param {Number} [isolationLevel] Controls the locking and row versioning behavior of TSQL statements issued by a connection.
       * @param {basicCallback} [callback] A callback which is called after transaction has began, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      begin(isolationLevel, callback) {
        if (isolationLevel instanceof Function) {
          callback = isolationLevel;
          isolationLevel = void 0;
        }
        if (typeof callback === "function") {
          this._begin(isolationLevel, (err) => {
            if (!err) {
              this.emit("begin");
            }
            callback(err);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._begin(isolationLevel, (err) => {
            if (err)
              return reject(err);
            this.emit("begin");
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {Number} [isolationLevel]
       * @param {basicCallback} [callback]
       * @return {Transaction}
       */
      _begin(isolationLevel, callback) {
        if (this._acquiredConnection) {
          return setImmediate(callback, new TransactionError("Transaction has already begun.", "EALREADYBEGUN"));
        }
        this._aborted = false;
        this._rollbackRequested = false;
        if (isolationLevel) {
          if (Object.keys(ISOLATION_LEVEL).some((key) => {
            return ISOLATION_LEVEL[key] === isolationLevel;
          })) {
            this.isolationLevel = isolationLevel;
          } else {
            throw new TransactionError("Invalid isolation level.");
          }
        }
        setImmediate(callback);
      }
      /**
       * Commit a transaction.
       *
       * @param {basicCallback} [callback] A callback which is called after transaction has commited, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      commit(callback) {
        if (typeof callback === "function") {
          this._commit((err) => {
            if (!err) {
              this.emit("commit");
            }
            callback(err);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._commit((err) => {
            if (err)
              return reject(err);
            this.emit("commit");
            resolve();
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} [callback]
       * @return {Transaction}
       */
      _commit(callback) {
        if (this._aborted) {
          return setImmediate(callback, new TransactionError("Transaction has been aborted.", "EABORT"));
        }
        if (!this._acquiredConnection) {
          return setImmediate(callback, new TransactionError("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
        }
        if (this._activeRequest) {
          return setImmediate(callback, new TransactionError("Can't commit transaction. There is a request in progress.", "EREQINPROG"));
        }
        setImmediate(callback);
      }
      /**
       * Returns new request using this transaction.
       *
       * @return {Request}
       */
      request() {
        return new shared.driver.Request(this);
      }
      /**
       * Rollback a transaction.
       *
       * @param {basicCallback} [callback] A callback which is called after transaction has rolled back, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      rollback(callback) {
        if (typeof callback === "function") {
          this._rollback((err) => {
            if (!err) {
              this.emit("rollback", this._aborted);
            }
            callback(err);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          return this._rollback((err) => {
            if (err)
              return reject(err);
            this.emit("rollback", this._aborted);
            resolve();
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} [callback]
       * @return {Transaction}
       */
      _rollback(callback) {
        if (this._aborted) {
          return setImmediate(callback, new TransactionError("Transaction has been aborted.", "EABORT"));
        }
        if (!this._acquiredConnection) {
          return setImmediate(callback, new TransactionError("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
        }
        if (this._activeRequest) {
          return setImmediate(callback, new TransactionError("Can't rollback transaction. There is a request in progress.", "EREQINPROG"));
        }
        this._rollbackRequested = true;
        setImmediate(callback);
      }
    };
    Transaction.defaultIsolationLevel = ISOLATION_LEVEL.READ_COMMITTED;
    module2.exports = Transaction;
  }
});
var require_base = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/base/index.js"(exports, module2) {
    "use strict";
    var ConnectionPool = require_connection_pool();
    var PreparedStatement = require_prepared_statement();
    var Request = require_request();
    var Transaction = require_transaction();
    var { ConnectionError, TransactionError, RequestError, PreparedStatementError, MSSQLError } = require_error();
    var shared = require_shared();
    var Table = require_table();
    var ISOLATION_LEVEL = require_isolationlevel();
    var { TYPES } = require_datatypes();
    var { connect, close, on, off, removeListener, query, batch } = require_global_connection();
    module2.exports = {
      ConnectionPool,
      Transaction,
      Request,
      PreparedStatement,
      ConnectionError,
      TransactionError,
      RequestError,
      PreparedStatementError,
      MSSQLError,
      driver: shared.driver,
      exports: {
        ConnectionError,
        TransactionError,
        RequestError,
        PreparedStatementError,
        MSSQLError,
        Table,
        ISOLATION_LEVEL,
        TYPES,
        MAX: 65535,
        // (1 << 16) - 1
        map: shared.map,
        getTypeByValue: shared.getTypeByValue,
        connect,
        close,
        on,
        removeListener,
        off,
        query,
        batch
      }
    };
    Object.defineProperty(module2.exports, "Promise", {
      enumerable: true,
      get: () => {
        return shared.Promise;
      },
      set: (value) => {
        shared.Promise = value;
      }
    });
    Object.defineProperty(module2.exports, "valueHandler", {
      enumerable: true,
      value: shared.valueHandler,
      writable: false,
      configurable: false
    });
    for (const key in TYPES) {
      const value = TYPES[key];
      module2.exports.exports[key] = value;
      module2.exports.exports[key.toUpperCase()] = value;
    }
  }
});
var require_writable_tracking_buffer = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/tracking-buffer/writable-tracking-buffer.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var ZERO_LENGTH_BUFFER = Buffer.alloc(0);
    var WritableTrackingBuffer = class {
      constructor(initialSize, encoding, doubleSizeGrowth) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "initialSize");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "encoding");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "doubleSizeGrowth");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "buffer");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "compositeBuffer");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "position");
        this.initialSize = initialSize;
        this.encoding = encoding || "ucs2";
        this.doubleSizeGrowth = doubleSizeGrowth || false;
        this.buffer = Buffer.alloc(this.initialSize, 0);
        this.compositeBuffer = ZERO_LENGTH_BUFFER;
        this.position = 0;
      }
      get data() {
        this.newBuffer(0);
        return this.compositeBuffer;
      }
      copyFrom(buffer) {
        const length = buffer.length;
        this.makeRoomFor(length);
        buffer.copy(this.buffer, this.position);
        this.position += length;
      }
      makeRoomFor(requiredLength) {
        if (this.buffer.length - this.position < requiredLength) {
          if (this.doubleSizeGrowth) {
            let size = Math.max(128, this.buffer.length * 2);
            while (size < requiredLength) {
              size *= 2;
            }
            this.newBuffer(size);
          } else {
            this.newBuffer(requiredLength);
          }
        }
      }
      newBuffer(size) {
        const buffer = this.buffer.slice(0, this.position);
        this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);
        this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);
        this.position = 0;
      }
      writeUInt8(value) {
        const length = 1;
        this.makeRoomFor(length);
        this.buffer.writeUInt8(value, this.position);
        this.position += length;
      }
      writeUInt16LE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeUInt16LE(value, this.position);
        this.position += length;
      }
      writeUShort(value) {
        this.writeUInt16LE(value);
      }
      writeUInt16BE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeUInt16BE(value, this.position);
        this.position += length;
      }
      writeUInt24LE(value) {
        const length = 3;
        this.makeRoomFor(length);
        this.buffer[this.position + 2] = value >>> 16 & 255;
        this.buffer[this.position + 1] = value >>> 8 & 255;
        this.buffer[this.position] = value & 255;
        this.position += length;
      }
      writeUInt32LE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeUInt32LE(value, this.position);
        this.position += length;
      }
      writeBigInt64LE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeBigInt64LE(value, this.position);
        this.position += length;
      }
      writeInt64LE(value) {
        this.writeBigInt64LE(BigInt(value));
      }
      writeUInt64LE(value) {
        this.writeBigUInt64LE(BigInt(value));
      }
      writeBigUInt64LE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeBigUInt64LE(value, this.position);
        this.position += length;
      }
      writeUInt32BE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeUInt32BE(value, this.position);
        this.position += length;
      }
      writeUInt40LE(value) {
        this.writeInt32LE(value & -1);
        this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));
      }
      writeInt8(value) {
        const length = 1;
        this.makeRoomFor(length);
        this.buffer.writeInt8(value, this.position);
        this.position += length;
      }
      writeInt16LE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeInt16LE(value, this.position);
        this.position += length;
      }
      writeInt16BE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeInt16BE(value, this.position);
        this.position += length;
      }
      writeInt32LE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeInt32LE(value, this.position);
        this.position += length;
      }
      writeInt32BE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeInt32BE(value, this.position);
        this.position += length;
      }
      writeFloatLE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeFloatLE(value, this.position);
        this.position += length;
      }
      writeDoubleLE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeDoubleLE(value, this.position);
        this.position += length;
      }
      writeString(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        const length = Buffer.byteLength(value, encoding);
        this.makeRoomFor(length);
        this.buffer.write(value, this.position, encoding);
        this.position += length;
      }
      writeBVarchar(value, encoding) {
        this.writeUInt8(value.length);
        this.writeString(value, encoding);
      }
      writeUsVarchar(value, encoding) {
        this.writeUInt16LE(value.length);
        this.writeString(value, encoding);
      }
      // TODO: Figure out what types are passed in other than `Buffer`
      writeUsVarbyte(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        let length;
        if (value instanceof Buffer) {
          length = value.length;
        } else {
          value = value.toString();
          length = Buffer.byteLength(value, encoding);
        }
        this.writeUInt16LE(length);
        if (value instanceof Buffer) {
          this.writeBuffer(value);
        } else {
          this.makeRoomFor(length);
          this.buffer.write(value, this.position, encoding);
          this.position += length;
        }
      }
      writePLPBody(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        let length;
        if (value instanceof Buffer) {
          length = value.length;
        } else {
          value = value.toString();
          length = Buffer.byteLength(value, encoding);
        }
        this.writeBuffer(UNKNOWN_PLP_LEN);
        if (length > 0) {
          this.writeUInt32LE(length);
          if (value instanceof Buffer) {
            this.writeBuffer(value);
          } else {
            this.makeRoomFor(length);
            this.buffer.write(value, this.position, encoding);
            this.position += length;
          }
        }
        this.writeUInt32LE(0);
      }
      writeBuffer(value) {
        const length = value.length;
        this.makeRoomFor(length);
        value.copy(this.buffer, this.position);
        this.position += length;
      }
      writeMoney(value) {
        this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));
        this.writeInt32LE(value & -1);
      }
    };
    var _default = WritableTrackingBuffer;
    exports.default = _default;
    module2.exports = WritableTrackingBuffer;
  }
});
var require_token = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/token.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Token = exports.TYPE = exports.SSPIToken = exports.RowToken = exports.RoutingEnvChangeToken = exports.RollbackTransactionEnvChangeToken = exports.ReturnValueToken = exports.ReturnStatusToken = exports.ResetConnectionEnvChangeToken = exports.PacketSizeEnvChangeToken = exports.OrderToken = exports.NBCRowToken = exports.LoginAckToken = exports.LanguageEnvChangeToken = exports.InfoMessageToken = exports.FedAuthInfoToken = exports.FeatureExtAckToken = exports.ErrorMessageToken = exports.DoneToken = exports.DoneProcToken = exports.DoneInProcToken = exports.DatabaseMirroringPartnerEnvChangeToken = exports.DatabaseEnvChangeToken = exports.CommitTransactionEnvChangeToken = exports.CollationChangeToken = exports.ColMetadataToken = exports.CharsetEnvChangeToken = exports.BeginTransactionEnvChangeToken = void 0;
    var TYPE = {
      ALTMETADATA: 136,
      ALTROW: 211,
      COLMETADATA: 129,
      COLINFO: 165,
      DONE: 253,
      DONEPROC: 254,
      DONEINPROC: 255,
      ENVCHANGE: 227,
      ERROR: 170,
      FEATUREEXTACK: 174,
      FEDAUTHINFO: 238,
      INFO: 171,
      LOGINACK: 173,
      NBCROW: 210,
      OFFSET: 120,
      ORDER: 169,
      RETURNSTATUS: 121,
      RETURNVALUE: 172,
      ROW: 209,
      SSPI: 237,
      TABNAME: 164
    };
    exports.TYPE = TYPE;
    var Token = class {
      constructor(name3, handlerName) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "name");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "handlerName");
        this.name = name3;
        this.handlerName = handlerName;
      }
    };
    exports.Token = Token;
    var ColMetadataToken = class extends Token {
      constructor(columns) {
        super("COLMETADATA", "onColMetadata");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "columns");
        this.columns = columns;
      }
    };
    exports.ColMetadataToken = ColMetadataToken;
    var DoneToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONE", "onDone");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "more");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "sqlError");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "attention");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "serverError");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "rowCount");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "curCmd");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports.DoneToken = DoneToken;
    var DoneInProcToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONEINPROC", "onDoneInProc");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "more");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "sqlError");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "attention");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "serverError");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "rowCount");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "curCmd");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports.DoneInProcToken = DoneInProcToken;
    var DoneProcToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONEPROC", "onDoneProc");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "more");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "sqlError");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "attention");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "serverError");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "rowCount");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "curCmd");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports.DoneProcToken = DoneProcToken;
    var DatabaseEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onDatabaseChange");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "type");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "newValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "oldValue");
        this.type = "DATABASE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.DatabaseEnvChangeToken = DatabaseEnvChangeToken;
    var LanguageEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onLanguageChange");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "type");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "newValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "oldValue");
        this.type = "LANGUAGE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.LanguageEnvChangeToken = LanguageEnvChangeToken;
    var CharsetEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onCharsetChange");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "type");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "newValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "oldValue");
        this.type = "CHARSET";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.CharsetEnvChangeToken = CharsetEnvChangeToken;
    var PacketSizeEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onPacketSizeChange");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "type");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "newValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "oldValue");
        this.type = "PACKET_SIZE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.PacketSizeEnvChangeToken = PacketSizeEnvChangeToken;
    var BeginTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onBeginTransaction");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "type");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "newValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "oldValue");
        this.type = "BEGIN_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.BeginTransactionEnvChangeToken = BeginTransactionEnvChangeToken;
    var CommitTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onCommitTransaction");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "type");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "newValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "oldValue");
        this.type = "COMMIT_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.CommitTransactionEnvChangeToken = CommitTransactionEnvChangeToken;
    var RollbackTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onRollbackTransaction");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "type");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "oldValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "newValue");
        this.type = "ROLLBACK_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.RollbackTransactionEnvChangeToken = RollbackTransactionEnvChangeToken;
    var DatabaseMirroringPartnerEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onDatabaseMirroringPartner");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "type");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "oldValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "newValue");
        this.type = "DATABASE_MIRRORING_PARTNER";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.DatabaseMirroringPartnerEnvChangeToken = DatabaseMirroringPartnerEnvChangeToken;
    var ResetConnectionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onResetConnection");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "type");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "oldValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "newValue");
        this.type = "RESET_CONNECTION";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.ResetConnectionEnvChangeToken = ResetConnectionEnvChangeToken;
    var CollationChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onSqlCollationChange");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "type");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "oldValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "newValue");
        this.type = "SQL_COLLATION";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.CollationChangeToken = CollationChangeToken;
    var RoutingEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onRoutingChange");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "type");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "newValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "oldValue");
        this.type = "ROUTING_CHANGE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.RoutingEnvChangeToken = RoutingEnvChangeToken;
    var FeatureExtAckToken = class extends Token {
      constructor(fedAuth, utf8Support) {
        super("FEATUREEXTACK", "onFeatureExtAck");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "fedAuth");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "utf8Support");
        this.fedAuth = fedAuth;
        this.utf8Support = utf8Support;
      }
    };
    exports.FeatureExtAckToken = FeatureExtAckToken;
    var FedAuthInfoToken = class extends Token {
      constructor(spn, stsurl) {
        super("FEDAUTHINFO", "onFedAuthInfo");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "spn");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "stsurl");
        this.spn = spn;
        this.stsurl = stsurl;
      }
    };
    exports.FedAuthInfoToken = FedAuthInfoToken;
    var InfoMessageToken = class extends Token {
      constructor({
        number,
        state,
        class: clazz,
        message,
        serverName,
        procName,
        lineNumber
      }) {
        super("INFO", "onInfoMessage");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "number");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "state");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "class");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "message");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "serverName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "procName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "lineNumber");
        this.number = number;
        this.state = state;
        this.class = clazz;
        this.message = message;
        this.serverName = serverName;
        this.procName = procName;
        this.lineNumber = lineNumber;
      }
    };
    exports.InfoMessageToken = InfoMessageToken;
    var ErrorMessageToken = class extends Token {
      constructor({
        number,
        state,
        class: clazz,
        message,
        serverName,
        procName,
        lineNumber
      }) {
        super("ERROR", "onErrorMessage");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "number");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "state");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "class");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "message");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "serverName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "procName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "lineNumber");
        this.number = number;
        this.state = state;
        this.class = clazz;
        this.message = message;
        this.serverName = serverName;
        this.procName = procName;
        this.lineNumber = lineNumber;
      }
    };
    exports.ErrorMessageToken = ErrorMessageToken;
    var LoginAckToken = class extends Token {
      constructor({
        interface: interfaze,
        tdsVersion,
        progName,
        progVersion
      }) {
        super("LOGINACK", "onLoginAck");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "interface");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "tdsVersion");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "progName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "progVersion");
        this.interface = interfaze;
        this.tdsVersion = tdsVersion;
        this.progName = progName;
        this.progVersion = progVersion;
      }
    };
    exports.LoginAckToken = LoginAckToken;
    var NBCRowToken = class extends Token {
      constructor(columns) {
        super("NBCROW", "onRow");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "columns");
        this.columns = columns;
      }
    };
    exports.NBCRowToken = NBCRowToken;
    var OrderToken = class extends Token {
      constructor(orderColumns) {
        super("ORDER", "onOrder");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "orderColumns");
        this.orderColumns = orderColumns;
      }
    };
    exports.OrderToken = OrderToken;
    var ReturnStatusToken = class extends Token {
      constructor(value) {
        super("RETURNSTATUS", "onReturnStatus");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "value");
        this.value = value;
      }
    };
    exports.ReturnStatusToken = ReturnStatusToken;
    var ReturnValueToken = class extends Token {
      constructor({
        paramOrdinal,
        paramName,
        metadata,
        value
      }) {
        super("RETURNVALUE", "onReturnValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "paramOrdinal");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "paramName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "metadata");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "value");
        this.paramOrdinal = paramOrdinal;
        this.paramName = paramName;
        this.metadata = metadata;
        this.value = value;
      }
    };
    exports.ReturnValueToken = ReturnValueToken;
    var RowToken = class extends Token {
      constructor(columns) {
        super("ROW", "onRow");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "columns");
        this.columns = columns;
      }
    };
    exports.RowToken = RowToken;
    var SSPIToken = class extends Token {
      constructor(ntlmpacket, ntlmpacketBuffer) {
        super("SSPICHALLENGE", "onSSPI");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "ntlmpacket");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "ntlmpacketBuffer");
        this.ntlmpacket = ntlmpacket;
        this.ntlmpacketBuffer = ntlmpacketBuffer;
      }
    };
    exports.SSPIToken = SSPIToken;
  }
});
var require_bulk_load = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/bulk-load.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _events = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _stream = (0, import_chunk_FVJ3R4NJ.__require)("stream");
    var _token = require_token();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var FLAGS = {
      nullable: 1 << 0,
      caseSen: 1 << 1,
      updateableReadWrite: 1 << 2,
      updateableUnknown: 1 << 3,
      identity: 1 << 4,
      computed: 1 << 5,
      // introduced in TDS 7.2
      fixedLenCLRType: 1 << 8,
      // introduced in TDS 7.2
      sparseColumnSet: 1 << 10,
      // introduced in TDS 7.3.B
      hidden: 1 << 13,
      // introduced in TDS 7.2
      key: 1 << 14,
      // introduced in TDS 7.2
      nullableUnknown: 1 << 15
      // introduced in TDS 7.2
    };
    var DONE_STATUS = {
      FINAL: 0,
      MORE: 1,
      ERROR: 2,
      INXACT: 4,
      COUNT: 16,
      ATTN: 32,
      SRVERROR: 256
    };
    var rowTokenBuffer = Buffer.from([_token.TYPE.ROW]);
    var textPointerAndTimestampBuffer = Buffer.from([
      // TextPointer length
      16,
      // TextPointer
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // Timestamp
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var textPointerNullBuffer = Buffer.from([0]);
    var RowTransform = class extends _stream.Transform {
      /**
       * @private
       */
      constructor(bulkLoad) {
        super({
          writableObjectMode: true
        });
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "columnMetadataWritten");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "bulkLoad");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "mainOptions");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "columns");
        this.bulkLoad = bulkLoad;
        this.mainOptions = bulkLoad.options;
        this.columns = bulkLoad.columns;
        this.columnMetadataWritten = false;
      }
      /**
       * @private
       */
      _transform(row, _encoding, callback) {
        if (!this.columnMetadataWritten) {
          this.push(this.bulkLoad.getColMetaData());
          this.columnMetadataWritten = true;
        }
        this.push(rowTokenBuffer);
        for (let i = 0; i < this.columns.length; i++) {
          const c = this.columns[i];
          let value = Array.isArray(row) ? row[i] : row[c.objName];
          if (!this.bulkLoad.firstRowWritten) {
            try {
              value = c.type.validate(value, c.collation);
            } catch (error) {
              return callback(error);
            }
          }
          const parameter = {
            length: c.length,
            scale: c.scale,
            precision: c.precision,
            value
          };
          if (c.type.name === "Text" || c.type.name === "Image" || c.type.name === "NText") {
            if (value == null) {
              this.push(textPointerNullBuffer);
              continue;
            }
            this.push(textPointerAndTimestampBuffer);
          }
          this.push(c.type.generateParameterLength(parameter, this.mainOptions));
          for (const chunk of c.type.generateParameterData(parameter, this.mainOptions)) {
            this.push(chunk);
          }
        }
        process.nextTick(callback);
      }
      /**
       * @private
       */
      _flush(callback) {
        this.push(this.bulkLoad.createDoneToken());
        process.nextTick(callback);
      }
    };
    var BulkLoad = class extends _events.EventEmitter {
      /**
       * @private
       */
      constructor(table, collation, connectionOptions, {
        checkConstraints = false,
        fireTriggers = false,
        keepNulls = false,
        lockTable = false,
        order = {}
      }, callback) {
        if (typeof checkConstraints !== "boolean") {
          throw new TypeError('The "options.checkConstraints" property must be of type boolean.');
        }
        if (typeof fireTriggers !== "boolean") {
          throw new TypeError('The "options.fireTriggers" property must be of type boolean.');
        }
        if (typeof keepNulls !== "boolean") {
          throw new TypeError('The "options.keepNulls" property must be of type boolean.');
        }
        if (typeof lockTable !== "boolean") {
          throw new TypeError('The "options.lockTable" property must be of type boolean.');
        }
        if (typeof order !== "object" || order === null) {
          throw new TypeError('The "options.order" property must be of type object.');
        }
        for (const [column, direction] of Object.entries(order)) {
          if (direction !== "ASC" && direction !== "DESC") {
            throw new TypeError('The value of the "' + column + '" key in the "options.order" object must be either "ASC" or "DESC".');
          }
        }
        super();
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "error");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "canceled");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "executionStarted");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "streamingMode");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "table");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "timeout");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "options");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "callback");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "columns");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "columnsByName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "firstRowWritten");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "rowToPacketTransform");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "bulkOptions");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "connection");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "rows");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "rst");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "rowCount");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "collation");
        this.error = void 0;
        this.canceled = false;
        this.executionStarted = false;
        this.collation = collation;
        this.table = table;
        this.options = connectionOptions;
        this.callback = callback;
        this.columns = [];
        this.columnsByName = {};
        this.firstRowWritten = false;
        this.streamingMode = false;
        this.rowToPacketTransform = new RowTransform(this);
        this.bulkOptions = {
          checkConstraints,
          fireTriggers,
          keepNulls,
          lockTable,
          order
        };
      }
      /**
       * Adds a column to the bulk load.
       *
       * The column definitions should match the table you are trying to insert into.
       * Attempting to call addColumn after the first row has been added will throw an exception.
       *
       * ```js
       * bulkLoad.addColumn('MyIntColumn', TYPES.Int, { nullable: false });
       * ```
       *
       * @param name The name of the column.
       * @param type One of the supported `data types`.
       * @param __namedParameters Additional column type information. At a minimum, `nullable` must be set to true or false.
       * @param length For VarChar, NVarChar, VarBinary. Use length as `Infinity` for VarChar(max), NVarChar(max) and VarBinary(max).
       * @param nullable Indicates whether the column accepts NULL values.
       * @param objName If the name of the column is different from the name of the property found on `rowObj` arguments passed to [[addRow]] or [[Connection.execBulkLoad]], then you can use this option to specify the property name.
       * @param precision For Numeric, Decimal.
       * @param scale For Numeric, Decimal, Time, DateTime2, DateTimeOffset.
      */
      addColumn(name3, type2, {
        output = false,
        length,
        precision,
        scale,
        objName = name3,
        nullable = true
      }) {
        if (this.firstRowWritten) {
          throw new Error("Columns cannot be added to bulk insert after the first row has been written.");
        }
        if (this.executionStarted) {
          throw new Error("Columns cannot be added to bulk insert after execution has started.");
        }
        const column = {
          type: type2,
          name: name3,
          value: null,
          output,
          length,
          precision,
          scale,
          objName,
          nullable,
          collation: this.collation
        };
        if ((type2.id & 48) === 32) {
          if (column.length == null && type2.resolveLength) {
            column.length = type2.resolveLength(column);
          }
        }
        if (type2.resolvePrecision && column.precision == null) {
          column.precision = type2.resolvePrecision(column);
        }
        if (type2.resolveScale && column.scale == null) {
          column.scale = type2.resolveScale(column);
        }
        this.columns.push(column);
        this.columnsByName[name3] = column;
      }
      /**
       * @private
       */
      getOptionsSql() {
        const addOptions = [];
        if (this.bulkOptions.checkConstraints) {
          addOptions.push("CHECK_CONSTRAINTS");
        }
        if (this.bulkOptions.fireTriggers) {
          addOptions.push("FIRE_TRIGGERS");
        }
        if (this.bulkOptions.keepNulls) {
          addOptions.push("KEEP_NULLS");
        }
        if (this.bulkOptions.lockTable) {
          addOptions.push("TABLOCK");
        }
        if (this.bulkOptions.order) {
          const orderColumns = [];
          for (const [column, direction] of Object.entries(this.bulkOptions.order)) {
            orderColumns.push(`${column} ${direction}`);
          }
          if (orderColumns.length) {
            addOptions.push(`ORDER (${orderColumns.join(", ")})`);
          }
        }
        if (addOptions.length > 0) {
          return ` WITH (${addOptions.join(",")})`;
        } else {
          return "";
        }
      }
      /**
       * @private
       */
      getBulkInsertSql() {
        let sql = "insert bulk " + this.table + "(";
        for (let i = 0, len = this.columns.length; i < len; i++) {
          const c = this.columns[i];
          if (i !== 0) {
            sql += ", ";
          }
          sql += "[" + c.name + "] " + c.type.declaration(c);
        }
        sql += ")";
        sql += this.getOptionsSql();
        return sql;
      }
      /**
       * This is simply a helper utility function which returns a `CREATE TABLE SQL` statement based on the columns added to the bulkLoad object.
       * This may be particularly handy when you want to insert into a temporary table (a table which starts with `#`).
       *
       * ```js
       * var sql = bulkLoad.getTableCreationSql();
       * ```
       *
       * A side note on bulk inserting into temporary tables: if you want to access a local temporary table after executing the bulk load,
       * you'll need to use the same connection and execute your requests using [[Connection.execSqlBatch]] instead of [[Connection.execSql]]
       */
      getTableCreationSql() {
        let sql = "CREATE TABLE " + this.table + "(\n";
        for (let i = 0, len = this.columns.length; i < len; i++) {
          const c = this.columns[i];
          if (i !== 0) {
            sql += ",\n";
          }
          sql += "[" + c.name + "] " + c.type.declaration(c);
          if (c.nullable !== void 0) {
            sql += " " + (c.nullable ? "NULL" : "NOT NULL");
          }
        }
        sql += "\n)";
        return sql;
      }
      /**
       * @private
       */
      getColMetaData() {
        const tBuf = new _writableTrackingBuffer.default(100, null, true);
        tBuf.writeUInt8(_token.TYPE.COLMETADATA);
        tBuf.writeUInt16LE(this.columns.length);
        for (let j = 0, len = this.columns.length; j < len; j++) {
          const c = this.columns[j];
          if (this.options.tdsVersion < "7_2") {
            tBuf.writeUInt16LE(0);
          } else {
            tBuf.writeUInt32LE(0);
          }
          let flags = FLAGS.updateableReadWrite;
          if (c.nullable) {
            flags |= FLAGS.nullable;
          } else if (c.nullable === void 0 && this.options.tdsVersion >= "7_2") {
            flags |= FLAGS.nullableUnknown;
          }
          tBuf.writeUInt16LE(flags);
          tBuf.writeBuffer(c.type.generateTypeInfo(c, this.options));
          if (c.type.hasTableName) {
            tBuf.writeUsVarchar(this.table, "ucs2");
          }
          tBuf.writeBVarchar(c.name, "ucs2");
        }
        return tBuf.data;
      }
      /**
       * Sets a timeout for this bulk load.
       *
       * ```js
       * bulkLoad.setTimeout(timeout);
       * ```
       *
       * @param timeout The number of milliseconds before the bulk load is considered failed, or 0 for no timeout.
       *   When no timeout is set for the bulk load, the [[ConnectionOptions.requestTimeout]] of the Connection is used.
       */
      setTimeout(timeout) {
        this.timeout = timeout;
      }
      /**
       * @private
       */
      createDoneToken() {
        const tBuf = new _writableTrackingBuffer.default(this.options.tdsVersion < "7_2" ? 9 : 13);
        tBuf.writeUInt8(_token.TYPE.DONE);
        const status = DONE_STATUS.FINAL;
        tBuf.writeUInt16LE(status);
        tBuf.writeUInt16LE(0);
        tBuf.writeUInt32LE(0);
        if (this.options.tdsVersion >= "7_2") {
          tBuf.writeUInt32LE(0);
        }
        return tBuf.data;
      }
      /**
       * @private
       */
      cancel() {
        if (this.canceled) {
          return;
        }
        this.canceled = true;
        this.emit("cancel");
      }
    };
    var _default = BulkLoad;
    exports.default = _default;
    module2.exports = BulkLoad;
  }
});
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t[1]) {
              _2.label = t[1];
              t = op;
              break;
            }
            if (t && _2.label < t[2]) {
              _2.label = t[2];
              _2.ops.push(op);
              break;
            }
            if (t[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
var extendStatics, __assign;
var init_tslib = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/_virtual/_tslib.js"() {
    "use strict";
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});
var Constants, OIDC_DEFAULT_SCOPES, OIDC_SCOPES, HeaderNames, PersistentCacheKeys, AADAuthorityConstants, AADServerParamKeys, ClaimsRequestKeys, PromptValue, SSOTypes, CodeChallengeMethodValues, ResponseMode, GrantType, CacheAccountType, Separators, CredentialType, CacheSchemaType, CacheType, APP_METADATA, CLIENT_INFO, THE_FAMILY_ID, AUTHORITY_METADATA_CONSTANTS, AuthorityMetadataSource, SERVER_TELEM_CONSTANTS, AuthenticationScheme, ThrottlingConstants, Errors, PasswordGrantConstants, ResponseCodes, RegionDiscoverySources, RegionDiscoveryOutcomes, CacheOutcome, JsonTypes;
var init_Constants = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/utils/Constants.js"() {
    "use strict";
    init_tslib();
    Constants = {
      LIBRARY_NAME: "MSAL.JS",
      SKU: "msal.js.common",
      // Prefix for all library cache entries
      CACHE_PREFIX: "msal",
      // default authority
      DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
      DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
      DEFAULT_COMMON_TENANT: "common",
      // ADFS String
      ADFS: "adfs",
      DSTS: "dstsv2",
      // Default AAD Instance Discovery Endpoint
      AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
      // Resource delimiter - used for certain cache entries
      RESOURCE_DELIM: "|",
      // Placeholder for non-existent account ids/objects
      NO_ACCOUNT: "NO_ACCOUNT",
      // Claims
      CLAIMS: "claims",
      // Consumer UTID
      CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
      // Default scopes
      OPENID_SCOPE: "openid",
      PROFILE_SCOPE: "profile",
      OFFLINE_ACCESS_SCOPE: "offline_access",
      EMAIL_SCOPE: "email",
      // Default response type for authorization code flow
      CODE_RESPONSE_TYPE: "code",
      CODE_GRANT_TYPE: "authorization_code",
      RT_GRANT_TYPE: "refresh_token",
      FRAGMENT_RESPONSE_MODE: "fragment",
      S256_CODE_CHALLENGE_METHOD: "S256",
      URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
      AUTHORIZATION_PENDING: "authorization_pending",
      NOT_DEFINED: "not_defined",
      EMPTY_STRING: "",
      FORWARD_SLASH: "/",
      IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
      IMDS_VERSION: "2020-06-01",
      IMDS_TIMEOUT: 2e3,
      AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
      REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
      REGIONAL_AUTH_NON_MSI_QUERY_STRING: "allowestsrnonmsi=true",
      KNOWN_PUBLIC_CLOUDS: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"],
      TOKEN_RESPONSE_TYPE: "token",
      ID_TOKEN_RESPONSE_TYPE: "id_token",
      SHR_NONCE_VALIDITY: 240
    };
    OIDC_DEFAULT_SCOPES = [
      Constants.OPENID_SCOPE,
      Constants.PROFILE_SCOPE,
      Constants.OFFLINE_ACCESS_SCOPE
    ];
    OIDC_SCOPES = __spreadArrays(OIDC_DEFAULT_SCOPES, [
      Constants.EMAIL_SCOPE
    ]);
    (function(HeaderNames2) {
      HeaderNames2["CONTENT_TYPE"] = "Content-Type";
      HeaderNames2["RETRY_AFTER"] = "Retry-After";
      HeaderNames2["CCS_HEADER"] = "X-AnchorMailbox";
      HeaderNames2["WWWAuthenticate"] = "WWW-Authenticate";
      HeaderNames2["AuthenticationInfo"] = "Authentication-Info";
      HeaderNames2["X_MS_REQUEST_ID"] = "x-ms-request-id";
    })(HeaderNames || (HeaderNames = {}));
    (function(PersistentCacheKeys2) {
      PersistentCacheKeys2["ID_TOKEN"] = "idtoken";
      PersistentCacheKeys2["CLIENT_INFO"] = "client.info";
      PersistentCacheKeys2["ADAL_ID_TOKEN"] = "adal.idtoken";
      PersistentCacheKeys2["ERROR"] = "error";
      PersistentCacheKeys2["ERROR_DESC"] = "error.description";
      PersistentCacheKeys2["ACTIVE_ACCOUNT"] = "active-account";
      PersistentCacheKeys2["ACTIVE_ACCOUNT_FILTERS"] = "active-account-filters";
    })(PersistentCacheKeys || (PersistentCacheKeys = {}));
    (function(AADAuthorityConstants2) {
      AADAuthorityConstants2["COMMON"] = "common";
      AADAuthorityConstants2["ORGANIZATIONS"] = "organizations";
      AADAuthorityConstants2["CONSUMERS"] = "consumers";
    })(AADAuthorityConstants || (AADAuthorityConstants = {}));
    (function(AADServerParamKeys2) {
      AADServerParamKeys2["CLIENT_ID"] = "client_id";
      AADServerParamKeys2["REDIRECT_URI"] = "redirect_uri";
      AADServerParamKeys2["RESPONSE_TYPE"] = "response_type";
      AADServerParamKeys2["RESPONSE_MODE"] = "response_mode";
      AADServerParamKeys2["GRANT_TYPE"] = "grant_type";
      AADServerParamKeys2["CLAIMS"] = "claims";
      AADServerParamKeys2["SCOPE"] = "scope";
      AADServerParamKeys2["ERROR"] = "error";
      AADServerParamKeys2["ERROR_DESCRIPTION"] = "error_description";
      AADServerParamKeys2["ACCESS_TOKEN"] = "access_token";
      AADServerParamKeys2["ID_TOKEN"] = "id_token";
      AADServerParamKeys2["REFRESH_TOKEN"] = "refresh_token";
      AADServerParamKeys2["EXPIRES_IN"] = "expires_in";
      AADServerParamKeys2["STATE"] = "state";
      AADServerParamKeys2["NONCE"] = "nonce";
      AADServerParamKeys2["PROMPT"] = "prompt";
      AADServerParamKeys2["SESSION_STATE"] = "session_state";
      AADServerParamKeys2["CLIENT_INFO"] = "client_info";
      AADServerParamKeys2["CODE"] = "code";
      AADServerParamKeys2["CODE_CHALLENGE"] = "code_challenge";
      AADServerParamKeys2["CODE_CHALLENGE_METHOD"] = "code_challenge_method";
      AADServerParamKeys2["CODE_VERIFIER"] = "code_verifier";
      AADServerParamKeys2["CLIENT_REQUEST_ID"] = "client-request-id";
      AADServerParamKeys2["X_CLIENT_SKU"] = "x-client-SKU";
      AADServerParamKeys2["X_CLIENT_VER"] = "x-client-VER";
      AADServerParamKeys2["X_CLIENT_OS"] = "x-client-OS";
      AADServerParamKeys2["X_CLIENT_CPU"] = "x-client-CPU";
      AADServerParamKeys2["X_CLIENT_CURR_TELEM"] = "x-client-current-telemetry";
      AADServerParamKeys2["X_CLIENT_LAST_TELEM"] = "x-client-last-telemetry";
      AADServerParamKeys2["X_MS_LIB_CAPABILITY"] = "x-ms-lib-capability";
      AADServerParamKeys2["X_APP_NAME"] = "x-app-name";
      AADServerParamKeys2["X_APP_VER"] = "x-app-ver";
      AADServerParamKeys2["POST_LOGOUT_URI"] = "post_logout_redirect_uri";
      AADServerParamKeys2["ID_TOKEN_HINT"] = "id_token_hint";
      AADServerParamKeys2["DEVICE_CODE"] = "device_code";
      AADServerParamKeys2["CLIENT_SECRET"] = "client_secret";
      AADServerParamKeys2["CLIENT_ASSERTION"] = "client_assertion";
      AADServerParamKeys2["CLIENT_ASSERTION_TYPE"] = "client_assertion_type";
      AADServerParamKeys2["TOKEN_TYPE"] = "token_type";
      AADServerParamKeys2["REQ_CNF"] = "req_cnf";
      AADServerParamKeys2["OBO_ASSERTION"] = "assertion";
      AADServerParamKeys2["REQUESTED_TOKEN_USE"] = "requested_token_use";
      AADServerParamKeys2["ON_BEHALF_OF"] = "on_behalf_of";
      AADServerParamKeys2["FOCI"] = "foci";
      AADServerParamKeys2["CCS_HEADER"] = "X-AnchorMailbox";
      AADServerParamKeys2["RETURN_SPA_CODE"] = "return_spa_code";
      AADServerParamKeys2["NATIVE_BROKER"] = "nativebroker";
      AADServerParamKeys2["LOGOUT_HINT"] = "logout_hint";
    })(AADServerParamKeys || (AADServerParamKeys = {}));
    (function(ClaimsRequestKeys2) {
      ClaimsRequestKeys2["ACCESS_TOKEN"] = "access_token";
      ClaimsRequestKeys2["XMS_CC"] = "xms_cc";
    })(ClaimsRequestKeys || (ClaimsRequestKeys = {}));
    PromptValue = {
      LOGIN: "login",
      SELECT_ACCOUNT: "select_account",
      CONSENT: "consent",
      NONE: "none",
      CREATE: "create",
      NO_SESSION: "no_session"
    };
    (function(SSOTypes2) {
      SSOTypes2["ACCOUNT"] = "account";
      SSOTypes2["SID"] = "sid";
      SSOTypes2["LOGIN_HINT"] = "login_hint";
      SSOTypes2["ID_TOKEN"] = "id_token";
      SSOTypes2["DOMAIN_HINT"] = "domain_hint";
      SSOTypes2["ORGANIZATIONS"] = "organizations";
      SSOTypes2["CONSUMERS"] = "consumers";
      SSOTypes2["ACCOUNT_ID"] = "accountIdentifier";
      SSOTypes2["HOMEACCOUNT_ID"] = "homeAccountIdentifier";
    })(SSOTypes || (SSOTypes = {}));
    CodeChallengeMethodValues = {
      PLAIN: "plain",
      S256: "S256"
    };
    (function(ResponseMode2) {
      ResponseMode2["QUERY"] = "query";
      ResponseMode2["FRAGMENT"] = "fragment";
      ResponseMode2["FORM_POST"] = "form_post";
    })(ResponseMode || (ResponseMode = {}));
    (function(GrantType2) {
      GrantType2["IMPLICIT_GRANT"] = "implicit";
      GrantType2["AUTHORIZATION_CODE_GRANT"] = "authorization_code";
      GrantType2["CLIENT_CREDENTIALS_GRANT"] = "client_credentials";
      GrantType2["RESOURCE_OWNER_PASSWORD_GRANT"] = "password";
      GrantType2["REFRESH_TOKEN_GRANT"] = "refresh_token";
      GrantType2["DEVICE_CODE_GRANT"] = "device_code";
      GrantType2["JWT_BEARER"] = "urn:ietf:params:oauth:grant-type:jwt-bearer";
    })(GrantType || (GrantType = {}));
    (function(CacheAccountType2) {
      CacheAccountType2["MSSTS_ACCOUNT_TYPE"] = "MSSTS";
      CacheAccountType2["ADFS_ACCOUNT_TYPE"] = "ADFS";
      CacheAccountType2["MSAV1_ACCOUNT_TYPE"] = "MSA";
      CacheAccountType2["GENERIC_ACCOUNT_TYPE"] = "Generic";
    })(CacheAccountType || (CacheAccountType = {}));
    (function(Separators2) {
      Separators2["CACHE_KEY_SEPARATOR"] = "-";
      Separators2["CLIENT_INFO_SEPARATOR"] = ".";
    })(Separators || (Separators = {}));
    (function(CredentialType2) {
      CredentialType2["ID_TOKEN"] = "IdToken";
      CredentialType2["ACCESS_TOKEN"] = "AccessToken";
      CredentialType2["ACCESS_TOKEN_WITH_AUTH_SCHEME"] = "AccessToken_With_AuthScheme";
      CredentialType2["REFRESH_TOKEN"] = "RefreshToken";
    })(CredentialType || (CredentialType = {}));
    (function(CacheSchemaType2) {
      CacheSchemaType2["ACCOUNT"] = "Account";
      CacheSchemaType2["CREDENTIAL"] = "Credential";
      CacheSchemaType2["ID_TOKEN"] = "IdToken";
      CacheSchemaType2["ACCESS_TOKEN"] = "AccessToken";
      CacheSchemaType2["REFRESH_TOKEN"] = "RefreshToken";
      CacheSchemaType2["APP_METADATA"] = "AppMetadata";
      CacheSchemaType2["TEMPORARY"] = "TempCache";
      CacheSchemaType2["TELEMETRY"] = "Telemetry";
      CacheSchemaType2["UNDEFINED"] = "Undefined";
      CacheSchemaType2["THROTTLING"] = "Throttling";
    })(CacheSchemaType || (CacheSchemaType = {}));
    (function(CacheType2) {
      CacheType2[CacheType2["ADFS"] = 1001] = "ADFS";
      CacheType2[CacheType2["MSA"] = 1002] = "MSA";
      CacheType2[CacheType2["MSSTS"] = 1003] = "MSSTS";
      CacheType2[CacheType2["GENERIC"] = 1004] = "GENERIC";
      CacheType2[CacheType2["ACCESS_TOKEN"] = 2001] = "ACCESS_TOKEN";
      CacheType2[CacheType2["REFRESH_TOKEN"] = 2002] = "REFRESH_TOKEN";
      CacheType2[CacheType2["ID_TOKEN"] = 2003] = "ID_TOKEN";
      CacheType2[CacheType2["APP_METADATA"] = 3001] = "APP_METADATA";
      CacheType2[CacheType2["UNDEFINED"] = 9999] = "UNDEFINED";
    })(CacheType || (CacheType = {}));
    APP_METADATA = "appmetadata";
    CLIENT_INFO = "client_info";
    THE_FAMILY_ID = "1";
    AUTHORITY_METADATA_CONSTANTS = {
      CACHE_KEY: "authority-metadata",
      REFRESH_TIME_SECONDS: 3600 * 24
      // 24 Hours
    };
    (function(AuthorityMetadataSource2) {
      AuthorityMetadataSource2["CONFIG"] = "config";
      AuthorityMetadataSource2["CACHE"] = "cache";
      AuthorityMetadataSource2["NETWORK"] = "network";
      AuthorityMetadataSource2["HARDCODED_VALUES"] = "hardcoded_values";
    })(AuthorityMetadataSource || (AuthorityMetadataSource = {}));
    SERVER_TELEM_CONSTANTS = {
      SCHEMA_VERSION: 5,
      MAX_CUR_HEADER_BYTES: 80,
      MAX_LAST_HEADER_BYTES: 330,
      MAX_CACHED_ERRORS: 50,
      CACHE_KEY: "server-telemetry",
      CATEGORY_SEPARATOR: "|",
      VALUE_SEPARATOR: ",",
      OVERFLOW_TRUE: "1",
      OVERFLOW_FALSE: "0",
      UNKNOWN_ERROR: "unknown_error"
    };
    (function(AuthenticationScheme2) {
      AuthenticationScheme2["BEARER"] = "Bearer";
      AuthenticationScheme2["POP"] = "pop";
      AuthenticationScheme2["SSH"] = "ssh-cert";
    })(AuthenticationScheme || (AuthenticationScheme = {}));
    ThrottlingConstants = {
      // Default time to throttle RequestThumbprint in seconds
      DEFAULT_THROTTLE_TIME_SECONDS: 60,
      // Default maximum time to throttle in seconds, overrides what the server sends back
      DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
      // Prefix for storing throttling entries
      THROTTLING_PREFIX: "throttling",
      // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
      X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
    };
    Errors = {
      INVALID_GRANT_ERROR: "invalid_grant",
      CLIENT_MISMATCH_ERROR: "client_mismatch"
    };
    (function(PasswordGrantConstants2) {
      PasswordGrantConstants2["username"] = "username";
      PasswordGrantConstants2["password"] = "password";
    })(PasswordGrantConstants || (PasswordGrantConstants = {}));
    (function(ResponseCodes2) {
      ResponseCodes2[ResponseCodes2["httpSuccess"] = 200] = "httpSuccess";
      ResponseCodes2[ResponseCodes2["httpBadRequest"] = 400] = "httpBadRequest";
    })(ResponseCodes || (ResponseCodes = {}));
    (function(RegionDiscoverySources2) {
      RegionDiscoverySources2["FAILED_AUTO_DETECTION"] = "1";
      RegionDiscoverySources2["INTERNAL_CACHE"] = "2";
      RegionDiscoverySources2["ENVIRONMENT_VARIABLE"] = "3";
      RegionDiscoverySources2["IMDS"] = "4";
    })(RegionDiscoverySources || (RegionDiscoverySources = {}));
    (function(RegionDiscoveryOutcomes2) {
      RegionDiscoveryOutcomes2["CONFIGURED_MATCHES_DETECTED"] = "1";
      RegionDiscoveryOutcomes2["CONFIGURED_NO_AUTO_DETECTION"] = "2";
      RegionDiscoveryOutcomes2["CONFIGURED_NOT_DETECTED"] = "3";
      RegionDiscoveryOutcomes2["AUTO_DETECTION_REQUESTED_SUCCESSFUL"] = "4";
      RegionDiscoveryOutcomes2["AUTO_DETECTION_REQUESTED_FAILED"] = "5";
    })(RegionDiscoveryOutcomes || (RegionDiscoveryOutcomes = {}));
    (function(CacheOutcome2) {
      CacheOutcome2["NO_CACHE_HIT"] = "0";
      CacheOutcome2["FORCE_REFRESH"] = "1";
      CacheOutcome2["NO_CACHED_ACCESS_TOKEN"] = "2";
      CacheOutcome2["CACHED_ACCESS_TOKEN_EXPIRED"] = "3";
      CacheOutcome2["REFRESH_CACHED_ACCESS_TOKEN"] = "4";
    })(CacheOutcome || (CacheOutcome = {}));
    (function(JsonTypes2) {
      JsonTypes2["Jwt"] = "JWT";
      JsonTypes2["Jwk"] = "JWK";
    })(JsonTypes || (JsonTypes = {}));
  }
});
var AuthErrorMessage, AuthError;
var init_AuthError = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/error/AuthError.js"() {
    "use strict";
    init_tslib();
    init_Constants();
    AuthErrorMessage = {
      unexpectedError: {
        code: "unexpected_error",
        desc: "Unexpected error in authentication."
      },
      postRequestFailed: {
        code: "post_request_failed",
        desc: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
      }
    };
    AuthError = /** @class */
    function(_super) {
      __extends(AuthError2, _super);
      function AuthError2(errorCode, errorMessage, suberror) {
        var _this = this;
        var errorString = errorMessage ? errorCode + ": " + errorMessage : errorCode;
        _this = _super.call(this, errorString) || this;
        Object.setPrototypeOf(_this, AuthError2.prototype);
        _this.errorCode = errorCode || Constants.EMPTY_STRING;
        _this.errorMessage = errorMessage || Constants.EMPTY_STRING;
        _this.subError = suberror || Constants.EMPTY_STRING;
        _this.name = "AuthError";
        return _this;
      }
      AuthError2.prototype.setCorrelationId = function(correlationId) {
        this.correlationId = correlationId;
      };
      AuthError2.createUnexpectedError = function(errDesc) {
        return new AuthError2(AuthErrorMessage.unexpectedError.code, AuthErrorMessage.unexpectedError.desc + ": " + errDesc);
      };
      AuthError2.createPostRequestFailed = function(errDesc) {
        return new AuthError2(AuthErrorMessage.postRequestFailed.code, AuthErrorMessage.postRequestFailed.desc + ": " + errDesc);
      };
      return AuthError2;
    }(Error);
  }
});
var DEFAULT_CRYPTO_IMPLEMENTATION;
var init_ICrypto = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/crypto/ICrypto.js"() {
    "use strict";
    init_tslib();
    init_AuthError();
    DEFAULT_CRYPTO_IMPLEMENTATION = {
      createNewGuid: function() {
        var notImplErr = "Crypto interface - createNewGuid() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      },
      base64Decode: function() {
        var notImplErr = "Crypto interface - base64Decode() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      },
      base64Encode: function() {
        var notImplErr = "Crypto interface - base64Encode() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      },
      generatePkceCodes: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a2) {
            notImplErr = "Crypto interface - generatePkceCodes() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      },
      getPublicKeyThumbprint: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a2) {
            notImplErr = "Crypto interface - getPublicKeyThumbprint() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      },
      removeTokenBindingKey: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a2) {
            notImplErr = "Crypto interface - removeTokenBindingKey() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      },
      clearKeystore: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a2) {
            notImplErr = "Crypto interface - clearKeystore() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      },
      signJwt: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a2) {
            notImplErr = "Crypto interface - signJwt() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      },
      hashString: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a2) {
            notImplErr = "Crypto interface - hashString() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      }
    };
  }
});
var ClientAuthErrorMessage, ClientAuthError;
var init_ClientAuthError = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/error/ClientAuthError.js"() {
    "use strict";
    init_tslib();
    init_AuthError();
    ClientAuthErrorMessage = {
      clientInfoDecodingError: {
        code: "client_info_decoding_error",
        desc: "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause."
      },
      clientInfoEmptyError: {
        code: "client_info_empty_error",
        desc: "The client info was empty. Please review the trace to determine the root cause."
      },
      tokenParsingError: {
        code: "token_parsing_error",
        desc: "Token cannot be parsed. Please review stack trace to determine root cause."
      },
      nullOrEmptyToken: {
        code: "null_or_empty_token",
        desc: "The token is null or empty. Please review the trace to determine the root cause."
      },
      endpointResolutionError: {
        code: "endpoints_resolution_error",
        desc: "Error: could not resolve endpoints. Please check network and try again."
      },
      networkError: {
        code: "network_error",
        desc: "Network request failed. Please check network trace to determine root cause."
      },
      unableToGetOpenidConfigError: {
        code: "openid_config_error",
        desc: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints."
      },
      hashNotDeserialized: {
        code: "hash_not_deserialized",
        desc: "The hash parameters could not be deserialized. Please review the trace to determine the root cause."
      },
      blankGuidGenerated: {
        code: "blank_guid_generated",
        desc: "The guid generated was blank. Please review the trace to determine the root cause."
      },
      invalidStateError: {
        code: "invalid_state",
        desc: "State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState()."
      },
      stateMismatchError: {
        code: "state_mismatch",
        desc: "State mismatch error. Please check your network. Continued requests may cause cache overflow."
      },
      stateNotFoundError: {
        code: "state_not_found",
        desc: "State not found"
      },
      nonceMismatchError: {
        code: "nonce_mismatch",
        desc: "Nonce mismatch error. This may be caused by a race condition in concurrent requests."
      },
      nonceNotFoundError: {
        code: "nonce_not_found",
        desc: "nonce not found"
      },
      authTimeNotFoundError: {
        code: "auth_time_not_found",
        desc: "Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information."
      },
      maxAgeTranspiredError: {
        code: "max_age_transpired",
        desc: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication."
      },
      noTokensFoundError: {
        code: "no_tokens_found",
        desc: "No tokens were found for the given scopes, and no authorization code was passed to acquireToken. You must retrieve an authorization code before making a call to acquireToken()."
      },
      multipleMatchingTokens: {
        code: "multiple_matching_tokens",
        desc: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account."
      },
      multipleMatchingAccounts: {
        code: "multiple_matching_accounts",
        desc: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account"
      },
      multipleMatchingAppMetadata: {
        code: "multiple_matching_appMetadata",
        desc: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata"
      },
      tokenRequestCannotBeMade: {
        code: "request_cannot_be_made",
        desc: "Token request cannot be made without authorization code or refresh token."
      },
      appendEmptyScopeError: {
        code: "cannot_append_empty_scope",
        desc: "Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info."
      },
      removeEmptyScopeError: {
        code: "cannot_remove_empty_scope",
        desc: "Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info."
      },
      appendScopeSetError: {
        code: "cannot_append_scopeset",
        desc: "Cannot append ScopeSet due to error."
      },
      emptyInputScopeSetError: {
        code: "empty_input_scopeset",
        desc: "Empty input ScopeSet cannot be processed."
      },
      DeviceCodePollingCancelled: {
        code: "device_code_polling_cancelled",
        desc: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true."
      },
      DeviceCodeExpired: {
        code: "device_code_expired",
        desc: "Device code is expired."
      },
      DeviceCodeUnknownError: {
        code: "device_code_unknown_error",
        desc: "Device code stopped polling for unknown reasons."
      },
      NoAccountInSilentRequest: {
        code: "no_account_in_silent_request",
        desc: "Please pass an account object, silent flow is not supported without account information"
      },
      invalidCacheRecord: {
        code: "invalid_cache_record",
        desc: "Cache record object was null or undefined."
      },
      invalidCacheEnvironment: {
        code: "invalid_cache_environment",
        desc: "Invalid environment when attempting to create cache entry"
      },
      noAccountFound: {
        code: "no_account_found",
        desc: "No account found in cache for given key."
      },
      CachePluginError: {
        code: "no cache plugin set on CacheManager",
        desc: "ICachePlugin needs to be set before using readFromStorage or writeFromStorage"
      },
      noCryptoObj: {
        code: "no_crypto_object",
        desc: "No crypto object detected. This is required for the following operation: "
      },
      invalidCacheType: {
        code: "invalid_cache_type",
        desc: "Invalid cache type"
      },
      unexpectedAccountType: {
        code: "unexpected_account_type",
        desc: "Unexpected account type."
      },
      unexpectedCredentialType: {
        code: "unexpected_credential_type",
        desc: "Unexpected credential type."
      },
      invalidAssertion: {
        code: "invalid_assertion",
        desc: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515"
      },
      invalidClientCredential: {
        code: "invalid_client_credential",
        desc: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential"
      },
      tokenRefreshRequired: {
        code: "token_refresh_required",
        desc: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired."
      },
      userTimeoutReached: {
        code: "user_timeout_reached",
        desc: "User defined timeout for device code polling reached"
      },
      tokenClaimsRequired: {
        code: "token_claims_cnf_required_for_signedjwt",
        desc: "Cannot generate a POP jwt if the token_claims are not populated"
      },
      noAuthorizationCodeFromServer: {
        code: "authorization_code_missing_from_server_response",
        desc: "Server response does not contain an authorization code to proceed"
      },
      noAzureRegionDetected: {
        code: "no_azure_region_detected",
        desc: "No azure region was detected and no fallback was made available"
      },
      accessTokenEntityNullError: {
        code: "access_token_entity_null",
        desc: "Access token entity is null, please check logs and cache to ensure a valid access token is present."
      },
      bindingKeyNotRemovedError: {
        code: "binding_key_not_removed",
        desc: "Could not remove the credential's binding key from storage."
      },
      logoutNotSupported: {
        code: "end_session_endpoint_not_supported",
        desc: "Provided authority does not support logout."
      },
      keyIdMissing: {
        code: "key_id_missing",
        desc: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key."
      }
    };
    ClientAuthError = /** @class */
    function(_super) {
      __extends(ClientAuthError2, _super);
      function ClientAuthError2(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "ClientAuthError";
        Object.setPrototypeOf(_this, ClientAuthError2.prototype);
        return _this;
      }
      ClientAuthError2.createClientInfoDecodingError = function(caughtError) {
        return new ClientAuthError2(ClientAuthErrorMessage.clientInfoDecodingError.code, ClientAuthErrorMessage.clientInfoDecodingError.desc + " Failed with error: " + caughtError);
      };
      ClientAuthError2.createClientInfoEmptyError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.clientInfoEmptyError.code, "" + ClientAuthErrorMessage.clientInfoEmptyError.desc);
      };
      ClientAuthError2.createTokenParsingError = function(caughtExtractionError) {
        return new ClientAuthError2(ClientAuthErrorMessage.tokenParsingError.code, ClientAuthErrorMessage.tokenParsingError.desc + " Failed with error: " + caughtExtractionError);
      };
      ClientAuthError2.createTokenNullOrEmptyError = function(invalidRawTokenString) {
        return new ClientAuthError2(ClientAuthErrorMessage.nullOrEmptyToken.code, ClientAuthErrorMessage.nullOrEmptyToken.desc + " Raw Token Value: " + invalidRawTokenString);
      };
      ClientAuthError2.createEndpointDiscoveryIncompleteError = function(errDetail) {
        return new ClientAuthError2(ClientAuthErrorMessage.endpointResolutionError.code, ClientAuthErrorMessage.endpointResolutionError.desc + " Detail: " + errDetail);
      };
      ClientAuthError2.createNetworkError = function(endpoint, errDetail) {
        return new ClientAuthError2(ClientAuthErrorMessage.networkError.code, ClientAuthErrorMessage.networkError.desc + " | Fetch client threw: " + errDetail + " | Attempted to reach: " + endpoint.split("?")[0]);
      };
      ClientAuthError2.createUnableToGetOpenidConfigError = function(errDetail) {
        return new ClientAuthError2(ClientAuthErrorMessage.unableToGetOpenidConfigError.code, ClientAuthErrorMessage.unableToGetOpenidConfigError.desc + " Attempted to retrieve endpoints from: " + errDetail);
      };
      ClientAuthError2.createHashNotDeserializedError = function(hashParamObj) {
        return new ClientAuthError2(ClientAuthErrorMessage.hashNotDeserialized.code, ClientAuthErrorMessage.hashNotDeserialized.desc + " Given Object: " + hashParamObj);
      };
      ClientAuthError2.createInvalidStateError = function(invalidState, errorString) {
        return new ClientAuthError2(ClientAuthErrorMessage.invalidStateError.code, ClientAuthErrorMessage.invalidStateError.desc + " Invalid State: " + invalidState + ", Root Err: " + errorString);
      };
      ClientAuthError2.createStateMismatchError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.stateMismatchError.code, ClientAuthErrorMessage.stateMismatchError.desc);
      };
      ClientAuthError2.createStateNotFoundError = function(missingState) {
        return new ClientAuthError2(ClientAuthErrorMessage.stateNotFoundError.code, ClientAuthErrorMessage.stateNotFoundError.desc + ":  " + missingState);
      };
      ClientAuthError2.createNonceMismatchError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.nonceMismatchError.code, ClientAuthErrorMessage.nonceMismatchError.desc);
      };
      ClientAuthError2.createAuthTimeNotFoundError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.authTimeNotFoundError.code, ClientAuthErrorMessage.authTimeNotFoundError.desc);
      };
      ClientAuthError2.createMaxAgeTranspiredError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.maxAgeTranspiredError.code, ClientAuthErrorMessage.maxAgeTranspiredError.desc);
      };
      ClientAuthError2.createNonceNotFoundError = function(missingNonce) {
        return new ClientAuthError2(ClientAuthErrorMessage.nonceNotFoundError.code, ClientAuthErrorMessage.nonceNotFoundError.desc + ":  " + missingNonce);
      };
      ClientAuthError2.createMultipleMatchingTokensInCacheError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.multipleMatchingTokens.code, ClientAuthErrorMessage.multipleMatchingTokens.desc + ".");
      };
      ClientAuthError2.createMultipleMatchingAccountsInCacheError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.multipleMatchingAccounts.code, ClientAuthErrorMessage.multipleMatchingAccounts.desc);
      };
      ClientAuthError2.createMultipleMatchingAppMetadataInCacheError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.multipleMatchingAppMetadata.code, ClientAuthErrorMessage.multipleMatchingAppMetadata.desc);
      };
      ClientAuthError2.createTokenRequestCannotBeMadeError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.tokenRequestCannotBeMade.code, ClientAuthErrorMessage.tokenRequestCannotBeMade.desc);
      };
      ClientAuthError2.createAppendEmptyScopeToSetError = function(givenScope) {
        return new ClientAuthError2(ClientAuthErrorMessage.appendEmptyScopeError.code, ClientAuthErrorMessage.appendEmptyScopeError.desc + " Given Scope: " + givenScope);
      };
      ClientAuthError2.createRemoveEmptyScopeFromSetError = function(givenScope) {
        return new ClientAuthError2(ClientAuthErrorMessage.removeEmptyScopeError.code, ClientAuthErrorMessage.removeEmptyScopeError.desc + " Given Scope: " + givenScope);
      };
      ClientAuthError2.createAppendScopeSetError = function(appendError) {
        return new ClientAuthError2(ClientAuthErrorMessage.appendScopeSetError.code, ClientAuthErrorMessage.appendScopeSetError.desc + " Detail Error: " + appendError);
      };
      ClientAuthError2.createEmptyInputScopeSetError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.emptyInputScopeSetError.code, "" + ClientAuthErrorMessage.emptyInputScopeSetError.desc);
      };
      ClientAuthError2.createDeviceCodeCancelledError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.DeviceCodePollingCancelled.code, "" + ClientAuthErrorMessage.DeviceCodePollingCancelled.desc);
      };
      ClientAuthError2.createDeviceCodeExpiredError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.DeviceCodeExpired.code, "" + ClientAuthErrorMessage.DeviceCodeExpired.desc);
      };
      ClientAuthError2.createDeviceCodeUnknownError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.DeviceCodeUnknownError.code, "" + ClientAuthErrorMessage.DeviceCodeUnknownError.desc);
      };
      ClientAuthError2.createNoAccountInSilentRequestError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.NoAccountInSilentRequest.code, "" + ClientAuthErrorMessage.NoAccountInSilentRequest.desc);
      };
      ClientAuthError2.createNullOrUndefinedCacheRecord = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.invalidCacheRecord.code, ClientAuthErrorMessage.invalidCacheRecord.desc);
      };
      ClientAuthError2.createInvalidCacheEnvironmentError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.invalidCacheEnvironment.code, ClientAuthErrorMessage.invalidCacheEnvironment.desc);
      };
      ClientAuthError2.createNoAccountFoundError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.noAccountFound.code, ClientAuthErrorMessage.noAccountFound.desc);
      };
      ClientAuthError2.createCachePluginError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.CachePluginError.code, "" + ClientAuthErrorMessage.CachePluginError.desc);
      };
      ClientAuthError2.createNoCryptoObjectError = function(operationName) {
        return new ClientAuthError2(ClientAuthErrorMessage.noCryptoObj.code, "" + ClientAuthErrorMessage.noCryptoObj.desc + operationName);
      };
      ClientAuthError2.createInvalidCacheTypeError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.invalidCacheType.code, "" + ClientAuthErrorMessage.invalidCacheType.desc);
      };
      ClientAuthError2.createUnexpectedAccountTypeError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.unexpectedAccountType.code, "" + ClientAuthErrorMessage.unexpectedAccountType.desc);
      };
      ClientAuthError2.createUnexpectedCredentialTypeError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.unexpectedCredentialType.code, "" + ClientAuthErrorMessage.unexpectedCredentialType.desc);
      };
      ClientAuthError2.createInvalidAssertionError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.invalidAssertion.code, "" + ClientAuthErrorMessage.invalidAssertion.desc);
      };
      ClientAuthError2.createInvalidCredentialError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.invalidClientCredential.code, "" + ClientAuthErrorMessage.invalidClientCredential.desc);
      };
      ClientAuthError2.createRefreshRequiredError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.tokenRefreshRequired.code, ClientAuthErrorMessage.tokenRefreshRequired.desc);
      };
      ClientAuthError2.createUserTimeoutReachedError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.userTimeoutReached.code, ClientAuthErrorMessage.userTimeoutReached.desc);
      };
      ClientAuthError2.createTokenClaimsRequiredError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.tokenClaimsRequired.code, ClientAuthErrorMessage.tokenClaimsRequired.desc);
      };
      ClientAuthError2.createNoAuthCodeInServerResponseError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.noAuthorizationCodeFromServer.code, ClientAuthErrorMessage.noAuthorizationCodeFromServer.desc);
      };
      ClientAuthError2.createBindingKeyNotRemovedError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.bindingKeyNotRemovedError.code, ClientAuthErrorMessage.bindingKeyNotRemovedError.desc);
      };
      ClientAuthError2.createLogoutNotSupportedError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.logoutNotSupported.code, ClientAuthErrorMessage.logoutNotSupported.desc);
      };
      ClientAuthError2.createKeyIdMissingError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.keyIdMissing.code, ClientAuthErrorMessage.keyIdMissing.desc);
      };
      return ClientAuthError2;
    }(AuthError);
  }
});
var StringUtils;
var init_StringUtils = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/utils/StringUtils.js"() {
    "use strict";
    init_ClientAuthError();
    StringUtils = /** @class */
    function() {
      function StringUtils2() {
      }
      StringUtils2.decodeAuthToken = function(authToken) {
        if (StringUtils2.isEmpty(authToken)) {
          throw ClientAuthError.createTokenNullOrEmptyError(authToken);
        }
        var tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
        var matches = tokenPartsRegex.exec(authToken);
        if (!matches || matches.length < 4) {
          throw ClientAuthError.createTokenParsingError("Given token is malformed: " + JSON.stringify(authToken));
        }
        var crackedToken = {
          header: matches[1],
          JWSPayload: matches[2],
          JWSSig: matches[3]
        };
        return crackedToken;
      };
      StringUtils2.isEmpty = function(str) {
        return typeof str === "undefined" || !str || 0 === str.length;
      };
      StringUtils2.isEmptyObj = function(strObj) {
        if (strObj && !StringUtils2.isEmpty(strObj)) {
          try {
            var obj = JSON.parse(strObj);
            return Object.keys(obj).length === 0;
          } catch (e) {
          }
        }
        return true;
      };
      StringUtils2.startsWith = function(str, search) {
        return str.indexOf(search) === 0;
      };
      StringUtils2.endsWith = function(str, search) {
        return str.length >= search.length && str.lastIndexOf(search) === str.length - search.length;
      };
      StringUtils2.queryStringToObject = function(query) {
        var obj = {};
        var params = query.split("&");
        var decode = function(s) {
          return decodeURIComponent(s.replace(/\+/g, " "));
        };
        params.forEach(function(pair) {
          if (pair.trim()) {
            var _a2 = pair.split(/=(.+)/g, 2), key = _a2[0], value = _a2[1];
            if (key && value) {
              obj[decode(key)] = decode(value);
            }
          }
        });
        return obj;
      };
      StringUtils2.trimArrayEntries = function(arr) {
        return arr.map(function(entry) {
          return entry.trim();
        });
      };
      StringUtils2.removeEmptyStringsFromArray = function(arr) {
        return arr.filter(function(entry) {
          return !StringUtils2.isEmpty(entry);
        });
      };
      StringUtils2.jsonParseHelper = function(str) {
        try {
          return JSON.parse(str);
        } catch (e) {
          return null;
        }
      };
      StringUtils2.matchPattern = function(pattern, input) {
        var regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?"));
        return regex.test(input);
      };
      return StringUtils2;
    }();
  }
});
var LogLevel, Logger;
var init_Logger = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/logger/Logger.js"() {
    "use strict";
    init_StringUtils();
    init_Constants();
    (function(LogLevel2) {
      LogLevel2[LogLevel2["Error"] = 0] = "Error";
      LogLevel2[LogLevel2["Warning"] = 1] = "Warning";
      LogLevel2[LogLevel2["Info"] = 2] = "Info";
      LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
      LogLevel2[LogLevel2["Trace"] = 4] = "Trace";
    })(LogLevel || (LogLevel = {}));
    Logger = /** @class */
    function() {
      function Logger2(loggerOptions, packageName, packageVersion) {
        this.level = LogLevel.Info;
        var defaultLoggerCallback2 = function() {
          return;
        };
        this.localCallback = loggerOptions.loggerCallback || defaultLoggerCallback2;
        this.piiLoggingEnabled = loggerOptions.piiLoggingEnabled || false;
        this.level = typeof loggerOptions.logLevel === "number" ? loggerOptions.logLevel : LogLevel.Info;
        this.correlationId = loggerOptions.correlationId || Constants.EMPTY_STRING;
        this.packageName = packageName || Constants.EMPTY_STRING;
        this.packageVersion = packageVersion || Constants.EMPTY_STRING;
      }
      Logger2.prototype.clone = function(packageName, packageVersion, correlationId) {
        return new Logger2({ loggerCallback: this.localCallback, piiLoggingEnabled: this.piiLoggingEnabled, logLevel: this.level, correlationId: correlationId || this.correlationId }, packageName, packageVersion);
      };
      Logger2.prototype.logMessage = function(logMessage, options) {
        if (options.logLevel > this.level || !this.piiLoggingEnabled && options.containsPii) {
          return;
        }
        var timestamp = (/* @__PURE__ */ new Date()).toUTCString();
        var logHeader;
        if (!StringUtils.isEmpty(options.correlationId)) {
          logHeader = "[" + timestamp + "] : [" + options.correlationId + "]";
        } else if (!StringUtils.isEmpty(this.correlationId)) {
          logHeader = "[" + timestamp + "] : [" + this.correlationId + "]";
        } else {
          logHeader = "[" + timestamp + "]";
        }
        var log2 = logHeader + " : " + this.packageName + "@" + this.packageVersion + " : " + LogLevel[options.logLevel] + " - " + logMessage;
        this.executeCallback(options.logLevel, log2, options.containsPii || false);
      };
      Logger2.prototype.executeCallback = function(level, message, containsPii) {
        if (this.localCallback) {
          this.localCallback(level, message, containsPii);
        }
      };
      Logger2.prototype.error = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Error,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.errorPii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Error,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.warning = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Warning,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.warningPii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Warning,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.info = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Info,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.infoPii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Info,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.verbose = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Verbose,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.verbosePii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Verbose,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.trace = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Trace,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.tracePii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Trace,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.isPiiLoggingEnabled = function() {
        return this.piiLoggingEnabled || false;
      };
      return Logger2;
    }();
  }
});
var name, version;
var init_packageMetadata = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/packageMetadata.js"() {
    "use strict";
    name = "@azure/msal-common";
    version = "7.6.0";
  }
});
var AzureCloudInstance;
var init_AuthorityOptions = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/authority/AuthorityOptions.js"() {
    "use strict";
    (function(AzureCloudInstance2) {
      AzureCloudInstance2[AzureCloudInstance2["None"] = 0] = "None";
      AzureCloudInstance2["AzurePublic"] = "https://login.microsoftonline.com";
      AzureCloudInstance2["AzurePpe"] = "https://login.windows-ppe.net";
      AzureCloudInstance2["AzureChina"] = "https://login.chinacloudapi.cn";
      AzureCloudInstance2["AzureGermany"] = "https://login.microsoftonline.de";
      AzureCloudInstance2["AzureUsGovernment"] = "https://login.microsoftonline.us";
    })(AzureCloudInstance || (AzureCloudInstance = {}));
  }
});
var CredentialEntity;
var init_CredentialEntity = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/cache/entities/CredentialEntity.js"() {
    "use strict";
    init_Constants();
    init_ClientAuthError();
    CredentialEntity = /** @class */
    function() {
      function CredentialEntity2() {
      }
      CredentialEntity2.prototype.generateAccountId = function() {
        return CredentialEntity2.generateAccountIdForCacheKey(this.homeAccountId, this.environment);
      };
      CredentialEntity2.prototype.generateCredentialId = function() {
        return CredentialEntity2.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);
      };
      CredentialEntity2.prototype.generateTarget = function() {
        return CredentialEntity2.generateTargetForCacheKey(this.target);
      };
      CredentialEntity2.prototype.generateCredentialKey = function() {
        return CredentialEntity2.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash);
      };
      CredentialEntity2.prototype.generateType = function() {
        switch (this.credentialType) {
          case CredentialType.ID_TOKEN:
            return CacheType.ID_TOKEN;
          case CredentialType.ACCESS_TOKEN:
          case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
            return CacheType.ACCESS_TOKEN;
          case CredentialType.REFRESH_TOKEN:
            return CacheType.REFRESH_TOKEN;
          default: {
            throw ClientAuthError.createUnexpectedCredentialTypeError();
          }
        }
      };
      CredentialEntity2.getCredentialType = function(key) {
        if (key.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) !== -1) {
          if (key.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) !== -1) {
            return CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
          }
          return CredentialType.ACCESS_TOKEN;
        } else if (key.indexOf(CredentialType.ID_TOKEN.toLowerCase()) !== -1) {
          return CredentialType.ID_TOKEN;
        } else if (key.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) !== -1) {
          return CredentialType.REFRESH_TOKEN;
        }
        return Constants.NOT_DEFINED;
      };
      CredentialEntity2.generateCredentialCacheKey = function(homeAccountId, environment, credentialType, clientId, realm, target, familyId, tokenType, requestedClaimsHash) {
        var credentialKey = [
          this.generateAccountIdForCacheKey(homeAccountId, environment),
          this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId),
          this.generateTargetForCacheKey(target),
          this.generateClaimsHashForCacheKey(requestedClaimsHash),
          this.generateSchemeForCacheKey(tokenType)
        ];
        return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      };
      CredentialEntity2.generateAccountIdForCacheKey = function(homeAccountId, environment) {
        var accountId = [homeAccountId, environment];
        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      };
      CredentialEntity2.generateCredentialIdForCacheKey = function(credentialType, clientId, realm, familyId) {
        var clientOrFamilyId = credentialType === CredentialType.REFRESH_TOKEN ? familyId || clientId : clientId;
        var credentialId = [
          credentialType,
          clientOrFamilyId,
          realm || Constants.EMPTY_STRING
        ];
        return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      };
      CredentialEntity2.generateTargetForCacheKey = function(scopes) {
        return (scopes || Constants.EMPTY_STRING).toLowerCase();
      };
      CredentialEntity2.generateClaimsHashForCacheKey = function(requestedClaimsHash) {
        return (requestedClaimsHash || Constants.EMPTY_STRING).toLowerCase();
      };
      CredentialEntity2.generateSchemeForCacheKey = function(tokenType) {
        return tokenType && tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? tokenType.toLowerCase() : Constants.EMPTY_STRING;
      };
      return CredentialEntity2;
    }();
  }
});
var ClientConfigurationErrorMessage, ClientConfigurationError;
var init_ClientConfigurationError = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/error/ClientConfigurationError.js"() {
    "use strict";
    init_tslib();
    init_ClientAuthError();
    ClientConfigurationErrorMessage = {
      redirectUriNotSet: {
        code: "redirect_uri_empty",
        desc: "A redirect URI is required for all calls, and none has been set."
      },
      postLogoutUriNotSet: {
        code: "post_logout_uri_empty",
        desc: "A post logout redirect has not been set."
      },
      claimsRequestParsingError: {
        code: "claims_request_parsing_error",
        desc: "Could not parse the given claims request object."
      },
      authorityUriInsecure: {
        code: "authority_uri_insecure",
        desc: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options"
      },
      urlParseError: {
        code: "url_parse_error",
        desc: "URL could not be parsed into appropriate segments."
      },
      urlEmptyError: {
        code: "empty_url_error",
        desc: "URL was empty or null."
      },
      emptyScopesError: {
        code: "empty_input_scopes_error",
        desc: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token."
      },
      nonArrayScopesError: {
        code: "nonarray_input_scopes_error",
        desc: "Scopes cannot be passed as non-array."
      },
      clientIdSingleScopeError: {
        code: "clientid_input_scopes_error",
        desc: "Client ID can only be provided as a single scope."
      },
      invalidPrompt: {
        code: "invalid_prompt_value",
        desc: "Supported prompt values are 'login', 'select_account', 'consent', 'create', 'none' and 'no_session'.  Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest"
      },
      invalidClaimsRequest: {
        code: "invalid_claims",
        desc: "Given claims parameter must be a stringified JSON object."
      },
      tokenRequestEmptyError: {
        code: "token_request_empty",
        desc: "Token request was empty and not found in cache."
      },
      logoutRequestEmptyError: {
        code: "logout_request_empty",
        desc: "The logout request was null or undefined."
      },
      invalidCodeChallengeMethod: {
        code: "invalid_code_challenge_method",
        desc: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".'
      },
      invalidCodeChallengeParams: {
        code: "pkce_params_missing",
        desc: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request"
      },
      invalidCloudDiscoveryMetadata: {
        code: "invalid_cloud_discovery_metadata",
        desc: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields"
      },
      invalidAuthorityMetadata: {
        code: "invalid_authority_metadata",
        desc: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields."
      },
      untrustedAuthority: {
        code: "untrusted_authority",
        desc: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter."
      },
      invalidAzureCloudInstance: {
        code: "invalid_azure_cloud_instance",
        desc: "Invalid AzureCloudInstance provided. Please refer MSAL JS docs: aks.ms/msaljs/azure_cloud_instance for valid values"
      },
      missingSshJwk: {
        code: "missing_ssh_jwk",
        desc: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme."
      },
      missingSshKid: {
        code: "missing_ssh_kid",
        desc: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme."
      },
      missingNonceAuthenticationHeader: {
        code: "missing_nonce_authentication_header",
        desc: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce."
      },
      invalidAuthenticationHeader: {
        code: "invalid_authentication_header",
        desc: "Invalid authentication header provided"
      }
    };
    ClientConfigurationError = /** @class */
    function(_super) {
      __extends(ClientConfigurationError2, _super);
      function ClientConfigurationError2(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "ClientConfigurationError";
        Object.setPrototypeOf(_this, ClientConfigurationError2.prototype);
        return _this;
      }
      ClientConfigurationError2.createRedirectUriEmptyError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.redirectUriNotSet.code, ClientConfigurationErrorMessage.redirectUriNotSet.desc);
      };
      ClientConfigurationError2.createPostLogoutRedirectUriEmptyError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.postLogoutUriNotSet.code, ClientConfigurationErrorMessage.postLogoutUriNotSet.desc);
      };
      ClientConfigurationError2.createClaimsRequestParsingError = function(claimsRequestParseError) {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.claimsRequestParsingError.code, ClientConfigurationErrorMessage.claimsRequestParsingError.desc + " Given value: " + claimsRequestParseError);
      };
      ClientConfigurationError2.createInsecureAuthorityUriError = function(urlString) {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.authorityUriInsecure.code, ClientConfigurationErrorMessage.authorityUriInsecure.desc + " Given URI: " + urlString);
      };
      ClientConfigurationError2.createUrlParseError = function(urlParseError) {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.urlParseError.code, ClientConfigurationErrorMessage.urlParseError.desc + " Given Error: " + urlParseError);
      };
      ClientConfigurationError2.createUrlEmptyError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.urlEmptyError.code, ClientConfigurationErrorMessage.urlEmptyError.desc);
      };
      ClientConfigurationError2.createEmptyScopesArrayError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.emptyScopesError.code, "" + ClientConfigurationErrorMessage.emptyScopesError.desc);
      };
      ClientConfigurationError2.createClientIdSingleScopeError = function(inputScopes) {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.clientIdSingleScopeError.code, ClientConfigurationErrorMessage.clientIdSingleScopeError.desc + " Given Scopes: " + inputScopes);
      };
      ClientConfigurationError2.createInvalidPromptError = function(promptValue) {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidPrompt.code, ClientConfigurationErrorMessage.invalidPrompt.desc + " Given value: " + promptValue);
      };
      ClientConfigurationError2.createInvalidClaimsRequestError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidClaimsRequest.code, ClientConfigurationErrorMessage.invalidClaimsRequest.desc);
      };
      ClientConfigurationError2.createEmptyLogoutRequestError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.logoutRequestEmptyError.code, ClientConfigurationErrorMessage.logoutRequestEmptyError.desc);
      };
      ClientConfigurationError2.createEmptyTokenRequestError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.tokenRequestEmptyError.code, ClientConfigurationErrorMessage.tokenRequestEmptyError.desc);
      };
      ClientConfigurationError2.createInvalidCodeChallengeMethodError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCodeChallengeMethod.code, ClientConfigurationErrorMessage.invalidCodeChallengeMethod.desc);
      };
      ClientConfigurationError2.createInvalidCodeChallengeParamsError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCodeChallengeParams.code, ClientConfigurationErrorMessage.invalidCodeChallengeParams.desc);
      };
      ClientConfigurationError2.createInvalidCloudDiscoveryMetadataError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.code, ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.desc);
      };
      ClientConfigurationError2.createInvalidAuthorityMetadataError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAuthorityMetadata.code, ClientConfigurationErrorMessage.invalidAuthorityMetadata.desc);
      };
      ClientConfigurationError2.createUntrustedAuthorityError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.untrustedAuthority.code, ClientConfigurationErrorMessage.untrustedAuthority.desc);
      };
      ClientConfigurationError2.createInvalidAzureCloudInstanceError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAzureCloudInstance.code, ClientConfigurationErrorMessage.invalidAzureCloudInstance.desc);
      };
      ClientConfigurationError2.createMissingSshJwkError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.missingSshJwk.code, ClientConfigurationErrorMessage.missingSshJwk.desc);
      };
      ClientConfigurationError2.createMissingSshKidError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.missingSshKid.code, ClientConfigurationErrorMessage.missingSshKid.desc);
      };
      ClientConfigurationError2.createMissingNonceAuthenticationHeadersError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.code, ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.desc);
      };
      ClientConfigurationError2.createInvalidAuthenticationHeaderError = function(invalidHeaderName, details) {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAuthenticationHeader.code, ClientConfigurationErrorMessage.invalidAuthenticationHeader.desc + ". Invalid header: " + invalidHeaderName + ". Details: " + details);
      };
      return ClientConfigurationError2;
    }(ClientAuthError);
  }
});
var ScopeSet;
var init_ScopeSet = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/request/ScopeSet.js"() {
    "use strict";
    init_tslib();
    init_ClientConfigurationError();
    init_StringUtils();
    init_ClientAuthError();
    init_Constants();
    ScopeSet = /** @class */
    function() {
      function ScopeSet2(inputScopes) {
        var _this = this;
        var scopeArr = inputScopes ? StringUtils.trimArrayEntries(__spreadArrays(inputScopes)) : [];
        var filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
        this.validateInputScopes(filteredInput);
        this.scopes = /* @__PURE__ */ new Set();
        filteredInput.forEach(function(scope) {
          return _this.scopes.add(scope);
        });
      }
      ScopeSet2.fromString = function(inputScopeString) {
        var scopeString = inputScopeString || Constants.EMPTY_STRING;
        var inputScopes = scopeString.split(" ");
        return new ScopeSet2(inputScopes);
      };
      ScopeSet2.prototype.validateInputScopes = function(inputScopes) {
        if (!inputScopes || inputScopes.length < 1) {
          throw ClientConfigurationError.createEmptyScopesArrayError();
        }
      };
      ScopeSet2.prototype.containsScope = function(scope) {
        var lowerCaseScopes = this.printScopesLowerCase().split(" ");
        var lowerCaseScopesSet = new ScopeSet2(lowerCaseScopes);
        return !StringUtils.isEmpty(scope) ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
      };
      ScopeSet2.prototype.containsScopeSet = function(scopeSet) {
        var _this = this;
        if (!scopeSet || scopeSet.scopes.size <= 0) {
          return false;
        }
        return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every(function(scope) {
          return _this.containsScope(scope);
        });
      };
      ScopeSet2.prototype.containsOnlyOIDCScopes = function() {
        var _this = this;
        var defaultScopeCount = 0;
        OIDC_SCOPES.forEach(function(defaultScope) {
          if (_this.containsScope(defaultScope)) {
            defaultScopeCount += 1;
          }
        });
        return this.scopes.size === defaultScopeCount;
      };
      ScopeSet2.prototype.appendScope = function(newScope) {
        if (!StringUtils.isEmpty(newScope)) {
          this.scopes.add(newScope.trim());
        }
      };
      ScopeSet2.prototype.appendScopes = function(newScopes) {
        var _this = this;
        try {
          newScopes.forEach(function(newScope) {
            return _this.appendScope(newScope);
          });
        } catch (e) {
          throw ClientAuthError.createAppendScopeSetError(e);
        }
      };
      ScopeSet2.prototype.removeScope = function(scope) {
        if (StringUtils.isEmpty(scope)) {
          throw ClientAuthError.createRemoveEmptyScopeFromSetError(scope);
        }
        this.scopes.delete(scope.trim());
      };
      ScopeSet2.prototype.removeOIDCScopes = function() {
        var _this = this;
        OIDC_SCOPES.forEach(function(defaultScope) {
          _this.scopes.delete(defaultScope);
        });
      };
      ScopeSet2.prototype.unionScopeSets = function(otherScopes) {
        if (!otherScopes) {
          throw ClientAuthError.createEmptyInputScopeSetError();
        }
        var unionScopes = /* @__PURE__ */ new Set();
        otherScopes.scopes.forEach(function(scope) {
          return unionScopes.add(scope.toLowerCase());
        });
        this.scopes.forEach(function(scope) {
          return unionScopes.add(scope.toLowerCase());
        });
        return unionScopes;
      };
      ScopeSet2.prototype.intersectingScopeSets = function(otherScopes) {
        if (!otherScopes) {
          throw ClientAuthError.createEmptyInputScopeSetError();
        }
        if (!otherScopes.containsOnlyOIDCScopes()) {
          otherScopes.removeOIDCScopes();
        }
        var unionScopes = this.unionScopeSets(otherScopes);
        var sizeOtherScopes = otherScopes.getScopeCount();
        var sizeThisScopes = this.getScopeCount();
        var sizeUnionScopes = unionScopes.size;
        return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
      };
      ScopeSet2.prototype.getScopeCount = function() {
        return this.scopes.size;
      };
      ScopeSet2.prototype.asArray = function() {
        var array = [];
        this.scopes.forEach(function(val) {
          return array.push(val);
        });
        return array;
      };
      ScopeSet2.prototype.printScopes = function() {
        if (this.scopes) {
          var scopeArr = this.asArray();
          return scopeArr.join(" ");
        }
        return Constants.EMPTY_STRING;
      };
      ScopeSet2.prototype.printScopesLowerCase = function() {
        return this.printScopes().toLowerCase();
      };
      return ScopeSet2;
    }();
  }
});
function buildClientInfo(rawClientInfo, crypto3) {
  if (StringUtils.isEmpty(rawClientInfo)) {
    throw ClientAuthError.createClientInfoEmptyError();
  }
  try {
    var decodedClientInfo = crypto3.base64Decode(rawClientInfo);
    return JSON.parse(decodedClientInfo);
  } catch (e) {
    throw ClientAuthError.createClientInfoDecodingError(e.message);
  }
}
function buildClientInfoFromHomeAccountId(homeAccountId) {
  if (StringUtils.isEmpty(homeAccountId)) {
    throw ClientAuthError.createClientInfoDecodingError("Home account ID was empty.");
  }
  var clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
  return {
    uid: clientInfoParts[0],
    utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1]
  };
}
var init_ClientInfo = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/account/ClientInfo.js"() {
    "use strict";
    init_ClientAuthError();
    init_StringUtils();
    init_Constants();
  }
});
var AuthorityType;
var init_AuthorityType = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/authority/AuthorityType.js"() {
    "use strict";
    (function(AuthorityType2) {
      AuthorityType2[AuthorityType2["Default"] = 0] = "Default";
      AuthorityType2[AuthorityType2["Adfs"] = 1] = "Adfs";
      AuthorityType2[AuthorityType2["Dsts"] = 2] = "Dsts";
    })(AuthorityType || (AuthorityType = {}));
  }
});
var AccountEntity;
var init_AccountEntity = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.js"() {
    "use strict";
    init_Constants();
    init_ClientInfo();
    init_StringUtils();
    init_ClientAuthError();
    init_AuthorityType();
    AccountEntity = /** @class */
    function() {
      function AccountEntity2() {
      }
      AccountEntity2.prototype.generateAccountId = function() {
        var accountId = [this.homeAccountId, this.environment];
        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      };
      AccountEntity2.prototype.generateAccountKey = function() {
        return AccountEntity2.generateAccountCacheKey({
          homeAccountId: this.homeAccountId,
          environment: this.environment,
          tenantId: this.realm,
          username: this.username,
          localAccountId: this.localAccountId
        });
      };
      AccountEntity2.prototype.generateType = function() {
        switch (this.authorityType) {
          case CacheAccountType.ADFS_ACCOUNT_TYPE:
            return CacheType.ADFS;
          case CacheAccountType.MSAV1_ACCOUNT_TYPE:
            return CacheType.MSA;
          case CacheAccountType.MSSTS_ACCOUNT_TYPE:
            return CacheType.MSSTS;
          case CacheAccountType.GENERIC_ACCOUNT_TYPE:
            return CacheType.GENERIC;
          default: {
            throw ClientAuthError.createUnexpectedAccountTypeError();
          }
        }
      };
      AccountEntity2.prototype.getAccountInfo = function() {
        return {
          homeAccountId: this.homeAccountId,
          environment: this.environment,
          tenantId: this.realm,
          username: this.username,
          localAccountId: this.localAccountId,
          name: this.name,
          idTokenClaims: this.idTokenClaims,
          nativeAccountId: this.nativeAccountId
        };
      };
      AccountEntity2.generateAccountCacheKey = function(accountInterface) {
        var accountKey = [
          accountInterface.homeAccountId,
          accountInterface.environment || Constants.EMPTY_STRING,
          accountInterface.tenantId || Constants.EMPTY_STRING
        ];
        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      };
      AccountEntity2.createAccount = function(clientInfo, homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment, nativeAccountId) {
        var _a2, _b, _c, _d, _e, _f;
        var account = new AccountEntity2();
        account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
        account.clientInfo = clientInfo;
        account.homeAccountId = homeAccountId;
        account.nativeAccountId = nativeAccountId;
        var env = environment || authority && authority.getPreferredCache();
        if (!env) {
          throw ClientAuthError.createInvalidCacheEnvironmentError();
        }
        account.environment = env;
        account.realm = ((_a2 = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a2 === void 0 ? void 0 : _a2.tid) || Constants.EMPTY_STRING;
        if (idToken) {
          account.idTokenClaims = idToken.claims;
          account.localAccountId = ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.oid) || ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.sub) || Constants.EMPTY_STRING;
          var preferredUsername = (_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.preferred_username;
          var email = ((_e = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _e === void 0 ? void 0 : _e.emails) ? idToken.claims.emails[0] : null;
          account.username = preferredUsername || email || Constants.EMPTY_STRING;
          account.name = (_f = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _f === void 0 ? void 0 : _f.name;
        }
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        return account;
      };
      AccountEntity2.createGenericAccount = function(homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment) {
        var _a2, _b, _c, _d;
        var account = new AccountEntity2();
        account.authorityType = authority && authority.authorityType === AuthorityType.Adfs ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE;
        account.homeAccountId = homeAccountId;
        account.realm = Constants.EMPTY_STRING;
        var env = environment || authority && authority.getPreferredCache();
        if (!env) {
          throw ClientAuthError.createInvalidCacheEnvironmentError();
        }
        if (idToken) {
          account.localAccountId = ((_a2 = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a2 === void 0 ? void 0 : _a2.oid) || ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.sub) || Constants.EMPTY_STRING;
          account.username = ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.upn) || Constants.EMPTY_STRING;
          account.name = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.name) || Constants.EMPTY_STRING;
          account.idTokenClaims = idToken === null || idToken === void 0 ? void 0 : idToken.claims;
        }
        account.environment = env;
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        return account;
      };
      AccountEntity2.generateHomeAccountId = function(serverClientInfo, authType, logger25, cryptoObj, idToken) {
        var _a2;
        var accountId = ((_a2 = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a2 === void 0 ? void 0 : _a2.sub) ? idToken.claims.sub : Constants.EMPTY_STRING;
        if (authType === AuthorityType.Adfs || authType === AuthorityType.Dsts) {
          return accountId;
        }
        if (serverClientInfo) {
          try {
            var clientInfo = buildClientInfo(serverClientInfo, cryptoObj);
            if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {
              return "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid;
            }
          } catch (e) {
          }
        }
        logger25.verbose("No client info in response");
        return accountId;
      };
      AccountEntity2.isAccountEntity = function(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType");
      };
      AccountEntity2.accountInfoIsEqual = function(accountA, accountB, compareClaims) {
        if (!accountA || !accountB) {
          return false;
        }
        var claimsMatch = true;
        if (compareClaims) {
          var accountAClaims = accountA.idTokenClaims || {};
          var accountBClaims = accountB.idTokenClaims || {};
          claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;
        }
        return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;
      };
      return AccountEntity2;
    }();
  }
});
var AuthToken;
var init_AuthToken = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/account/AuthToken.js"() {
    "use strict";
    init_ClientAuthError();
    init_StringUtils();
    AuthToken = /** @class */
    function() {
      function AuthToken2(rawToken, crypto3) {
        if (StringUtils.isEmpty(rawToken)) {
          throw ClientAuthError.createTokenNullOrEmptyError(rawToken);
        }
        this.rawToken = rawToken;
        this.claims = AuthToken2.extractTokenClaims(rawToken, crypto3);
      }
      AuthToken2.extractTokenClaims = function(encodedToken, crypto3) {
        var decodedToken = StringUtils.decodeAuthToken(encodedToken);
        try {
          var base64TokenPayload = decodedToken.JWSPayload;
          var base64Decoded = crypto3.base64Decode(base64TokenPayload);
          return JSON.parse(base64Decoded);
        } catch (err) {
          throw ClientAuthError.createTokenParsingError(err);
        }
      };
      AuthToken2.checkMaxAge = function(authTime, maxAge) {
        var fiveMinuteSkew = 3e5;
        if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
          throw ClientAuthError.createMaxAgeTranspiredError();
        }
      };
      return AuthToken2;
    }();
  }
});
var CacheManager, DefaultStorageClass;
var init_CacheManager = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/cache/CacheManager.js"() {
    "use strict";
    init_tslib();
    init_Constants();
    init_CredentialEntity();
    init_ScopeSet();
    init_AccountEntity();
    init_AuthError();
    init_ClientAuthError();
    init_AuthToken();
    CacheManager = /** @class */
    function() {
      function CacheManager2(clientId, cryptoImpl) {
        this.clientId = clientId;
        this.cryptoImpl = cryptoImpl;
      }
      CacheManager2.prototype.getAllAccounts = function() {
        var _this = this;
        var currentAccounts = this.getAccountsFilteredBy();
        var accountValues = Object.keys(currentAccounts).map(function(accountKey) {
          return currentAccounts[accountKey];
        });
        var numAccounts = accountValues.length;
        if (numAccounts < 1) {
          return [];
        } else {
          var allAccounts = accountValues.map(function(value) {
            var accountEntity = CacheManager2.toObject(new AccountEntity(), value);
            var accountInfo = accountEntity.getAccountInfo();
            var idToken = _this.readIdTokenFromCache(_this.clientId, accountInfo);
            if (idToken && !accountInfo.idTokenClaims) {
              accountInfo.idToken = idToken.secret;
              accountInfo.idTokenClaims = new AuthToken(idToken.secret, _this.cryptoImpl).claims;
            }
            return accountInfo;
          });
          return allAccounts;
        }
      };
      CacheManager2.prototype.saveCacheRecord = function(cacheRecord) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!cacheRecord) {
                  throw ClientAuthError.createNullOrUndefinedCacheRecord();
                }
                if (!!cacheRecord.account) {
                  this.setAccount(cacheRecord.account);
                }
                if (!!cacheRecord.idToken) {
                  this.setIdTokenCredential(cacheRecord.idToken);
                }
                if (!!!cacheRecord.accessToken)
                  return [3, 2];
                return [4, this.saveAccessToken(cacheRecord.accessToken)];
              case 1:
                _a2.sent();
                _a2.label = 2;
              case 2:
                if (!!cacheRecord.refreshToken) {
                  this.setRefreshTokenCredential(cacheRecord.refreshToken);
                }
                if (!!cacheRecord.appMetadata) {
                  this.setAppMetadata(cacheRecord.appMetadata);
                }
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CacheManager2.prototype.saveAccessToken = function(credential) {
        return __awaiter(this, void 0, void 0, function() {
          var currentTokenCache, currentScopes, currentAccessTokens, removedAccessTokens_1;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                currentTokenCache = this.getCredentialsFilteredBy({
                  clientId: credential.clientId,
                  credentialType: credential.credentialType,
                  environment: credential.environment,
                  homeAccountId: credential.homeAccountId,
                  realm: credential.realm,
                  tokenType: credential.tokenType,
                  requestedClaimsHash: credential.requestedClaimsHash
                });
                currentScopes = ScopeSet.fromString(credential.target);
                currentAccessTokens = Object.keys(currentTokenCache.accessTokens).map(function(key) {
                  return currentTokenCache.accessTokens[key];
                });
                if (!currentAccessTokens)
                  return [3, 2];
                removedAccessTokens_1 = [];
                currentAccessTokens.forEach(function(tokenEntity) {
                  var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
                  if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
                    removedAccessTokens_1.push(_this.removeCredential(tokenEntity));
                  }
                });
                return [4, Promise.all(removedAccessTokens_1)];
              case 1:
                _a2.sent();
                _a2.label = 2;
              case 2:
                this.setAccessTokenCredential(credential);
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CacheManager2.prototype.getAccountsFilteredBy = function(accountFilter) {
        return this.getAccountsFilteredByInternal(accountFilter ? accountFilter.homeAccountId : Constants.EMPTY_STRING, accountFilter ? accountFilter.environment : Constants.EMPTY_STRING, accountFilter ? accountFilter.realm : Constants.EMPTY_STRING, accountFilter ? accountFilter.nativeAccountId : Constants.EMPTY_STRING);
      };
      CacheManager2.prototype.getAccountsFilteredByInternal = function(homeAccountId, environment, realm, nativeAccountId) {
        var _this = this;
        var allCacheKeys = this.getKeys();
        var matchingAccounts = {};
        allCacheKeys.forEach(function(cacheKey) {
          var entity = _this.getAccount(cacheKey);
          if (!entity) {
            return;
          }
          if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {
            return;
          }
          if (!!environment && !_this.matchEnvironment(entity, environment)) {
            return;
          }
          if (!!realm && !_this.matchRealm(entity, realm)) {
            return;
          }
          if (!!nativeAccountId && !_this.matchNativeAccountId(entity, nativeAccountId)) {
            return;
          }
          matchingAccounts[cacheKey] = entity;
        });
        return matchingAccounts;
      };
      CacheManager2.prototype.getCredentialsFilteredBy = function(filter) {
        return this.getCredentialsFilteredByInternal(filter.homeAccountId, filter.environment, filter.credentialType, filter.clientId, filter.familyId, filter.realm, filter.target, filter.userAssertionHash, filter.tokenType, filter.keyId, filter.requestedClaimsHash);
      };
      CacheManager2.prototype.getCredentialsFilteredByInternal = function(homeAccountId, environment, credentialType, clientId, familyId, realm, target, userAssertionHash, tokenType, keyId, requestedClaimsHash) {
        var _this = this;
        var allCacheKeys = this.getKeys();
        var matchingCredentials = {
          idTokens: {},
          accessTokens: {},
          refreshTokens: {}
        };
        allCacheKeys.forEach(function(cacheKey) {
          var credType = CredentialEntity.getCredentialType(cacheKey);
          if (credType === Constants.NOT_DEFINED) {
            return;
          }
          var entity = _this.getSpecificCredential(cacheKey, credType);
          if (!entity) {
            return;
          }
          if (!!userAssertionHash && !_this.matchUserAssertionHash(entity, userAssertionHash)) {
            return;
          }
          if (typeof homeAccountId === "string" && !_this.matchHomeAccountId(entity, homeAccountId)) {
            return;
          }
          if (!!environment && !_this.matchEnvironment(entity, environment)) {
            return;
          }
          if (!!realm && !_this.matchRealm(entity, realm)) {
            return;
          }
          if (!!credentialType && !_this.matchCredentialType(entity, credentialType)) {
            return;
          }
          if (!!clientId && !_this.matchClientId(entity, clientId)) {
            return;
          }
          if (!!familyId && !_this.matchFamilyId(entity, familyId)) {
            return;
          }
          if (!!target && !_this.matchTarget(entity, target)) {
            return;
          }
          if (requestedClaimsHash || entity.requestedClaimsHash) {
            if (entity.requestedClaimsHash !== requestedClaimsHash) {
              return;
            }
          }
          if (credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
            if (!!tokenType && !_this.matchTokenType(entity, tokenType)) {
              return;
            }
            if (tokenType === AuthenticationScheme.SSH) {
              if (keyId && !_this.matchKeyId(entity, keyId)) {
                return;
              }
            }
          }
          var updatedCacheKey = _this.updateCredentialCacheKey(cacheKey, entity);
          switch (credType) {
            case CredentialType.ID_TOKEN:
              matchingCredentials.idTokens[updatedCacheKey] = entity;
              break;
            case CredentialType.ACCESS_TOKEN:
            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
              matchingCredentials.accessTokens[updatedCacheKey] = entity;
              break;
            case CredentialType.REFRESH_TOKEN:
              matchingCredentials.refreshTokens[updatedCacheKey] = entity;
              break;
          }
        });
        return matchingCredentials;
      };
      CacheManager2.prototype.getAppMetadataFilteredBy = function(filter) {
        return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);
      };
      CacheManager2.prototype.getAppMetadataFilteredByInternal = function(environment, clientId) {
        var _this = this;
        var allCacheKeys = this.getKeys();
        var matchingAppMetadata = {};
        allCacheKeys.forEach(function(cacheKey) {
          if (!_this.isAppMetadata(cacheKey)) {
            return;
          }
          var entity = _this.getAppMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (!!environment && !_this.matchEnvironment(entity, environment)) {
            return;
          }
          if (!!clientId && !_this.matchClientId(entity, clientId)) {
            return;
          }
          matchingAppMetadata[cacheKey] = entity;
        });
        return matchingAppMetadata;
      };
      CacheManager2.prototype.getAuthorityMetadataByAlias = function(host) {
        var _this = this;
        var allCacheKeys = this.getAuthorityMetadataKeys();
        var matchedEntity = null;
        allCacheKeys.forEach(function(cacheKey) {
          if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {
            return;
          }
          var entity = _this.getAuthorityMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (entity.aliases.indexOf(host) === -1) {
            return;
          }
          matchedEntity = entity;
        });
        return matchedEntity;
      };
      CacheManager2.prototype.removeAllAccounts = function() {
        return __awaiter(this, void 0, void 0, function() {
          var allCacheKeys, removedAccounts;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                allCacheKeys = this.getKeys();
                removedAccounts = [];
                allCacheKeys.forEach(function(cacheKey) {
                  var entity = _this.getAccount(cacheKey);
                  if (!entity) {
                    return;
                  }
                  removedAccounts.push(_this.removeAccount(cacheKey));
                });
                return [4, Promise.all(removedAccounts)];
              case 1:
                _a2.sent();
                return [2, true];
            }
          });
        });
      };
      CacheManager2.prototype.removeAccount = function(accountKey) {
        return __awaiter(this, void 0, void 0, function() {
          var account;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                account = this.getAccount(accountKey);
                if (!account) {
                  throw ClientAuthError.createNoAccountFoundError();
                }
                return [4, this.removeAccountContext(account)];
              case 1:
                return [2, _a2.sent() && this.removeItem(accountKey, CacheSchemaType.ACCOUNT)];
            }
          });
        });
      };
      CacheManager2.prototype.removeAccountContext = function(account) {
        return __awaiter(this, void 0, void 0, function() {
          var allCacheKeys, accountId, removedCredentials;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                allCacheKeys = this.getKeys();
                accountId = account.generateAccountId();
                removedCredentials = [];
                allCacheKeys.forEach(function(cacheKey) {
                  var credType = CredentialEntity.getCredentialType(cacheKey);
                  if (credType === Constants.NOT_DEFINED) {
                    return;
                  }
                  var cacheEntity = _this.getSpecificCredential(cacheKey, credType);
                  if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {
                    removedCredentials.push(_this.removeCredential(cacheEntity));
                  }
                });
                return [4, Promise.all(removedCredentials)];
              case 1:
                _a2.sent();
                return [2, true];
            }
          });
        });
      };
      CacheManager2.prototype.removeCredential = function(credential) {
        return __awaiter(this, void 0, void 0, function() {
          var key, accessTokenWithAuthSchemeEntity, kid;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                key = credential.generateCredentialKey();
                if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()))
                  return [3, 4];
                if (!(credential.tokenType === AuthenticationScheme.POP))
                  return [3, 4];
                accessTokenWithAuthSchemeEntity = credential;
                kid = accessTokenWithAuthSchemeEntity.keyId;
                if (!kid)
                  return [3, 4];
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, this.cryptoImpl.removeTokenBindingKey(kid)];
              case 2:
                _a2.sent();
                return [3, 4];
              case 3:
                _a2.sent();
                throw ClientAuthError.createBindingKeyNotRemovedError();
              case 4:
                return [2, this.removeItem(key, CacheSchemaType.CREDENTIAL)];
            }
          });
        });
      };
      CacheManager2.prototype.removeAppMetadata = function() {
        var _this = this;
        var allCacheKeys = this.getKeys();
        allCacheKeys.forEach(function(cacheKey) {
          if (_this.isAppMetadata(cacheKey)) {
            _this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);
          }
        });
        return true;
      };
      CacheManager2.prototype.readCacheRecord = function(account, clientId, request3, environment) {
        var cachedAccount = this.readAccountFromCache(account);
        var cachedIdToken = this.readIdTokenFromCache(clientId, account);
        var cachedAccessToken = this.readAccessTokenFromCache(clientId, account, request3);
        var cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);
        var cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);
        if (cachedAccount && cachedIdToken) {
          cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;
        }
        return {
          account: cachedAccount,
          idToken: cachedIdToken,
          accessToken: cachedAccessToken,
          refreshToken: cachedRefreshToken,
          appMetadata: cachedAppMetadata
        };
      };
      CacheManager2.prototype.readAccountFromCache = function(account) {
        var accountKey = AccountEntity.generateAccountCacheKey(account);
        return this.getAccount(accountKey);
      };
      CacheManager2.prototype.readAccountFromCacheWithNativeAccountId = function(nativeAccountId) {
        var accountFilter = {
          nativeAccountId
        };
        var accountCache = this.getAccountsFilteredBy(accountFilter);
        var accounts = Object.keys(accountCache).map(function(key) {
          return accountCache[key];
        });
        if (accounts.length < 1) {
          return null;
        } else if (accounts.length > 1) {
          throw ClientAuthError.createMultipleMatchingAccountsInCacheError();
        }
        return accountCache[0];
      };
      CacheManager2.prototype.readIdTokenFromCache = function(clientId, account) {
        var idTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.ID_TOKEN,
          clientId,
          realm: account.tenantId
        };
        var credentialCache = this.getCredentialsFilteredBy(idTokenFilter);
        var idTokens = Object.keys(credentialCache.idTokens).map(function(key) {
          return credentialCache.idTokens[key];
        });
        var numIdTokens = idTokens.length;
        if (numIdTokens < 1) {
          return null;
        } else if (numIdTokens > 1) {
          throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return idTokens[0];
      };
      CacheManager2.prototype.readAccessTokenFromCache = function(clientId, account, request3) {
        var scopes = new ScopeSet(request3.scopes || []);
        var authScheme = request3.authenticationScheme || AuthenticationScheme.BEARER;
        var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
        var accessTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType,
          clientId,
          realm: account.tenantId,
          target: scopes.printScopesLowerCase(),
          tokenType: authScheme,
          keyId: request3.sshKid,
          requestedClaimsHash: request3.requestedClaimsHash
        };
        var credentialCache = this.getCredentialsFilteredBy(accessTokenFilter);
        var accessTokens = Object.keys(credentialCache.accessTokens).map(function(key) {
          return credentialCache.accessTokens[key];
        });
        var numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          return null;
        } else if (numAccessTokens > 1) {
          throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return accessTokens[0];
      };
      CacheManager2.prototype.readRefreshTokenFromCache = function(clientId, account, familyRT) {
        var id = familyRT ? THE_FAMILY_ID : void 0;
        var refreshTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.REFRESH_TOKEN,
          clientId,
          familyId: id
        };
        var credentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);
        var refreshTokens = Object.keys(credentialCache.refreshTokens).map(function(key) {
          return credentialCache.refreshTokens[key];
        });
        var numRefreshTokens = refreshTokens.length;
        if (numRefreshTokens < 1) {
          return null;
        }
        return refreshTokens[0];
      };
      CacheManager2.prototype.readAppMetadataFromCache = function(environment, clientId) {
        var appMetadataFilter = {
          environment,
          clientId
        };
        var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
        var appMetadataEntries = Object.keys(appMetadata).map(function(key) {
          return appMetadata[key];
        });
        var numAppMetadata = appMetadataEntries.length;
        if (numAppMetadata < 1) {
          return null;
        } else if (numAppMetadata > 1) {
          throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();
        }
        return appMetadataEntries[0];
      };
      CacheManager2.prototype.isAppMetadataFOCI = function(environment, clientId) {
        var appMetadata = this.readAppMetadataFromCache(environment, clientId);
        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
      };
      CacheManager2.prototype.matchHomeAccountId = function(entity, homeAccountId) {
        return !!(typeof entity.homeAccountId === "string" && homeAccountId === entity.homeAccountId);
      };
      CacheManager2.prototype.matchUserAssertionHash = function(entity, userAssertionHash) {
        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
      };
      CacheManager2.prototype.matchEnvironment = function(entity, environment) {
        var cloudMetadata = this.getAuthorityMetadataByAlias(environment);
        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
          return true;
        }
        return false;
      };
      CacheManager2.prototype.matchCredentialType = function(entity, credentialType) {
        return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();
      };
      CacheManager2.prototype.matchClientId = function(entity, clientId) {
        return !!(entity.clientId && clientId === entity.clientId);
      };
      CacheManager2.prototype.matchFamilyId = function(entity, familyId) {
        return !!(entity.familyId && familyId === entity.familyId);
      };
      CacheManager2.prototype.matchRealm = function(entity, realm) {
        return !!(entity.realm && realm === entity.realm);
      };
      CacheManager2.prototype.matchNativeAccountId = function(entity, nativeAccountId) {
        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
      };
      CacheManager2.prototype.matchTarget = function(entity, target) {
        var isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
        if (isNotAccessTokenCredential || !entity.target) {
          return false;
        }
        var entityScopeSet = ScopeSet.fromString(entity.target);
        var requestTargetScopeSet = ScopeSet.fromString(target);
        if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {
          requestTargetScopeSet.removeOIDCScopes();
        } else {
          requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
        }
        return entityScopeSet.containsScopeSet(requestTargetScopeSet);
      };
      CacheManager2.prototype.matchTokenType = function(entity, tokenType) {
        return !!(entity.tokenType && entity.tokenType === tokenType);
      };
      CacheManager2.prototype.matchKeyId = function(entity, keyId) {
        return !!(entity.keyId && entity.keyId === keyId);
      };
      CacheManager2.prototype.isAppMetadata = function(key) {
        return key.indexOf(APP_METADATA) !== -1;
      };
      CacheManager2.prototype.isAuthorityMetadata = function(key) {
        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
      };
      CacheManager2.prototype.generateAuthorityMetadataCacheKey = function(authority) {
        return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + "-" + this.clientId + "-" + authority;
      };
      CacheManager2.prototype.getSpecificCredential = function(key, credType) {
        switch (credType) {
          case CredentialType.ID_TOKEN: {
            return this.getIdTokenCredential(key);
          }
          case CredentialType.ACCESS_TOKEN:
          case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME: {
            return this.getAccessTokenCredential(key);
          }
          case CredentialType.REFRESH_TOKEN: {
            return this.getRefreshTokenCredential(key);
          }
          default:
            return null;
        }
      };
      CacheManager2.toObject = function(obj, json) {
        for (var propertyName in json) {
          obj[propertyName] = json[propertyName];
        }
        return obj;
      };
      return CacheManager2;
    }();
    DefaultStorageClass = /** @class */
    function(_super) {
      __extends(DefaultStorageClass2, _super);
      function DefaultStorageClass2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DefaultStorageClass2.prototype.setAccount = function() {
        var notImplErr = "Storage interface - setAccount() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getAccount = function() {
        var notImplErr = "Storage interface - getAccount() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setIdTokenCredential = function() {
        var notImplErr = "Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getIdTokenCredential = function() {
        var notImplErr = "Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setAccessTokenCredential = function() {
        var notImplErr = "Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getAccessTokenCredential = function() {
        var notImplErr = "Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setRefreshTokenCredential = function() {
        var notImplErr = "Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getRefreshTokenCredential = function() {
        var notImplErr = "Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setAppMetadata = function() {
        var notImplErr = "Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getAppMetadata = function() {
        var notImplErr = "Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setServerTelemetry = function() {
        var notImplErr = "Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getServerTelemetry = function() {
        var notImplErr = "Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setAuthorityMetadata = function() {
        var notImplErr = "Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getAuthorityMetadata = function() {
        var notImplErr = "Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getAuthorityMetadataKeys = function() {
        var notImplErr = "Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setThrottlingCache = function() {
        var notImplErr = "Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getThrottlingCache = function() {
        var notImplErr = "Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.removeItem = function() {
        var notImplErr = "Storage interface - removeItem() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.containsKey = function() {
        var notImplErr = "Storage interface - containsKey() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getKeys = function() {
        var notImplErr = "Storage interface - getKeys() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.clear = function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a2) {
            notImplErr = "Storage interface - clear() has not been implemented for the cacheStorage interface.";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      };
      DefaultStorageClass2.prototype.updateCredentialCacheKey = function() {
        var notImplErr = "Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      return DefaultStorageClass2;
    }(CacheManager);
  }
});
function buildClientConfiguration(_a2) {
  var userAuthOptions = _a2.authOptions, userSystemOptions = _a2.systemOptions, userLoggerOption = _a2.loggerOptions, storageImplementation = _a2.storageInterface, networkImplementation = _a2.networkInterface, cryptoImplementation = _a2.cryptoInterface, clientCredentials = _a2.clientCredentials, libraryInfo = _a2.libraryInfo, telemetry = _a2.telemetry, serverTelemetryManager = _a2.serverTelemetryManager, persistencePlugin = _a2.persistencePlugin, serializableCache = _a2.serializableCache;
  var loggerOptions = __assign(__assign({}, DEFAULT_LOGGER_IMPLEMENTATION), userLoggerOption);
  return {
    authOptions: buildAuthOptions(userAuthOptions),
    systemOptions: __assign(__assign({}, DEFAULT_SYSTEM_OPTIONS), userSystemOptions),
    loggerOptions,
    storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION),
    networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
    cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
    clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
    libraryInfo: __assign(__assign({}, DEFAULT_LIBRARY_INFO), libraryInfo),
    telemetry: __assign(__assign({}, DEFAULT_TELEMETRY_OPTIONS), telemetry),
    serverTelemetryManager: serverTelemetryManager || null,
    persistencePlugin: persistencePlugin || null,
    serializableCache: serializableCache || null
  };
}
function buildAuthOptions(authOptions) {
  return __assign({ clientCapabilities: [], azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS, skipAuthorityMetadataCache: false }, authOptions);
}
var DEFAULT_TOKEN_RENEWAL_OFFSET_SEC, DEFAULT_SYSTEM_OPTIONS, DEFAULT_LOGGER_IMPLEMENTATION, DEFAULT_NETWORK_IMPLEMENTATION, DEFAULT_LIBRARY_INFO, DEFAULT_CLIENT_CREDENTIALS, DEFAULT_AZURE_CLOUD_OPTIONS, DEFAULT_TELEMETRY_OPTIONS;
var init_ClientConfiguration = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/config/ClientConfiguration.js"() {
    "use strict";
    init_tslib();
    init_ICrypto();
    init_AuthError();
    init_Logger();
    init_Constants();
    init_packageMetadata();
    init_AuthorityOptions();
    init_CacheManager();
    DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
    DEFAULT_SYSTEM_OPTIONS = {
      tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
      preventCorsPreflight: false,
      proxyUrl: Constants.EMPTY_STRING
    };
    DEFAULT_LOGGER_IMPLEMENTATION = {
      loggerCallback: function() {
      },
      piiLoggingEnabled: false,
      logLevel: LogLevel.Info,
      correlationId: Constants.EMPTY_STRING
    };
    DEFAULT_NETWORK_IMPLEMENTATION = {
      sendGetRequestAsync: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a2) {
            notImplErr = "Network interface - sendGetRequestAsync() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      },
      sendPostRequestAsync: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a2) {
            notImplErr = "Network interface - sendPostRequestAsync() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      }
    };
    DEFAULT_LIBRARY_INFO = {
      sku: Constants.SKU,
      version,
      cpu: Constants.EMPTY_STRING,
      os: Constants.EMPTY_STRING
    };
    DEFAULT_CLIENT_CREDENTIALS = {
      clientSecret: Constants.EMPTY_STRING,
      clientAssertion: void 0
    };
    DEFAULT_AZURE_CLOUD_OPTIONS = {
      azureCloudInstance: AzureCloudInstance.None,
      tenant: "" + Constants.DEFAULT_COMMON_TENANT
    };
    DEFAULT_TELEMETRY_OPTIONS = {
      application: {
        appName: "",
        appVersion: ""
      }
    };
  }
});
var ServerError;
var init_ServerError = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/error/ServerError.js"() {
    "use strict";
    init_tslib();
    init_AuthError();
    ServerError = /** @class */
    function(_super) {
      __extends(ServerError2, _super);
      function ServerError2(errorCode, errorMessage, subError) {
        var _this = _super.call(this, errorCode, errorMessage, subError) || this;
        _this.name = "ServerError";
        Object.setPrototypeOf(_this, ServerError2.prototype);
        return _this;
      }
      return ServerError2;
    }(AuthError);
  }
});
var ThrottlingUtils;
var init_ThrottlingUtils = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/network/ThrottlingUtils.js"() {
    "use strict";
    init_Constants();
    init_ServerError();
    ThrottlingUtils = /** @class */
    function() {
      function ThrottlingUtils2() {
      }
      ThrottlingUtils2.generateThrottlingStorageKey = function(thumbprint) {
        return ThrottlingConstants.THROTTLING_PREFIX + "." + JSON.stringify(thumbprint);
      };
      ThrottlingUtils2.preProcess = function(cacheManager, thumbprint) {
        var _a2;
        var key = ThrottlingUtils2.generateThrottlingStorageKey(thumbprint);
        var value = cacheManager.getThrottlingCache(key);
        if (value) {
          if (value.throttleTime < Date.now()) {
            cacheManager.removeItem(key, CacheSchemaType.THROTTLING);
            return;
          }
          throw new ServerError(((_a2 = value.errorCodes) === null || _a2 === void 0 ? void 0 : _a2.join(" ")) || Constants.EMPTY_STRING, value.errorMessage, value.subError);
        }
      };
      ThrottlingUtils2.postProcess = function(cacheManager, thumbprint, response) {
        if (ThrottlingUtils2.checkResponseStatus(response) || ThrottlingUtils2.checkResponseForRetryAfter(response)) {
          var thumbprintValue = {
            throttleTime: ThrottlingUtils2.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
            error: response.body.error,
            errorCodes: response.body.error_codes,
            errorMessage: response.body.error_description,
            subError: response.body.suberror
          };
          cacheManager.setThrottlingCache(ThrottlingUtils2.generateThrottlingStorageKey(thumbprint), thumbprintValue);
        }
      };
      ThrottlingUtils2.checkResponseStatus = function(response) {
        return response.status === 429 || response.status >= 500 && response.status < 600;
      };
      ThrottlingUtils2.checkResponseForRetryAfter = function(response) {
        if (response.headers) {
          return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
        }
        return false;
      };
      ThrottlingUtils2.calculateThrottleTime = function(throttleTime) {
        var time = throttleTime <= 0 ? 0 : throttleTime;
        var currentSeconds = Date.now() / 1e3;
        return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1e3);
      };
      ThrottlingUtils2.removeThrottle = function(cacheManager, clientId, request3, homeAccountIdentifier) {
        var thumbprint = {
          clientId,
          authority: request3.authority,
          scopes: request3.scopes,
          homeAccountIdentifier,
          claims: request3.claims,
          authenticationScheme: request3.authenticationScheme,
          resourceRequestMethod: request3.resourceRequestMethod,
          resourceRequestUri: request3.resourceRequestUri,
          shrClaims: request3.shrClaims,
          sshKid: request3.sshKid
        };
        var key = this.generateThrottlingStorageKey(thumbprint);
        return cacheManager.removeItem(key, CacheSchemaType.THROTTLING);
      };
      return ThrottlingUtils2;
    }();
  }
});
var NetworkManager;
var init_NetworkManager = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/network/NetworkManager.js"() {
    "use strict";
    init_tslib();
    init_ThrottlingUtils();
    init_AuthError();
    init_ClientAuthError();
    NetworkManager = /** @class */
    function() {
      function NetworkManager2(networkClient, cacheManager) {
        this.networkClient = networkClient;
        this.cacheManager = cacheManager;
      }
      NetworkManager2.prototype.sendPostRequest = function(thumbprint, tokenEndpoint, options) {
        return __awaiter(this, void 0, void 0, function() {
          var response, e_1;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                ThrottlingUtils.preProcess(this.cacheManager, thumbprint);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, this.networkClient.sendPostRequestAsync(tokenEndpoint, options)];
              case 2:
                response = _a2.sent();
                return [3, 4];
              case 3:
                e_1 = _a2.sent();
                if (e_1 instanceof AuthError) {
                  throw e_1;
                } else {
                  throw ClientAuthError.createNetworkError(tokenEndpoint, e_1);
                }
              case 4:
                ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response);
                return [2, response];
            }
          });
        });
      };
      return NetworkManager2;
    }();
  }
});
var CcsCredentialType;
var init_CcsCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/account/CcsCredential.js"() {
    "use strict";
    (function(CcsCredentialType2) {
      CcsCredentialType2["HOME_ACCOUNT_ID"] = "home_account_id";
      CcsCredentialType2["UPN"] = "UPN";
    })(CcsCredentialType || (CcsCredentialType = {}));
  }
});
var BaseClient;
var init_BaseClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/client/BaseClient.js"() {
    "use strict";
    init_tslib();
    init_ClientConfiguration();
    init_NetworkManager();
    init_Logger();
    init_Constants();
    init_packageMetadata();
    init_ClientAuthError();
    init_CcsCredential();
    init_ClientInfo();
    BaseClient = /** @class */
    function() {
      function BaseClient2(configuration, performanceClient) {
        this.config = buildClientConfiguration(configuration);
        this.logger = new Logger(this.config.loggerOptions, name, version);
        this.cryptoUtils = this.config.cryptoInterface;
        this.cacheManager = this.config.storageInterface;
        this.networkClient = this.config.networkInterface;
        this.networkManager = new NetworkManager(this.networkClient, this.cacheManager);
        this.serverTelemetryManager = this.config.serverTelemetryManager;
        this.authority = this.config.authOptions.authority;
        this.performanceClient = performanceClient;
      }
      BaseClient2.prototype.createTokenRequestHeaders = function(ccsCred) {
        var headers = {};
        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                var clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                headers[HeaderNames.CCS_HEADER] = "Oid:" + clientInfo.uid + "@" + clientInfo.utid;
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              headers[HeaderNames.CCS_HEADER] = "UPN: " + ccsCred.credential;
              break;
          }
        }
        return headers;
      };
      BaseClient2.prototype.executePostToTokenEndpoint = function(tokenEndpoint, queryString, headers, thumbprint) {
        return __awaiter(this, void 0, void 0, function() {
          var response;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.networkManager.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers, proxyUrl: this.config.systemOptions.proxyUrl })];
              case 1:
                response = _a2.sent();
                if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
                  this.config.serverTelemetryManager.clearTelemetryCache();
                }
                return [2, response];
            }
          });
        });
      };
      BaseClient2.prototype.updateAuthority = function(updatedAuthority) {
        if (!updatedAuthority.discoveryComplete()) {
          throw ClientAuthError.createEndpointDiscoveryIncompleteError("Updated authority has not completed endpoint discovery.");
        }
        this.authority = updatedAuthority;
      };
      return BaseClient2;
    }();
  }
});
var RequestValidator;
var init_RequestValidator = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/request/RequestValidator.js"() {
    "use strict";
    init_StringUtils();
    init_ClientConfigurationError();
    init_Constants();
    RequestValidator = /** @class */
    function() {
      function RequestValidator2() {
      }
      RequestValidator2.validateRedirectUri = function(redirectUri) {
        if (StringUtils.isEmpty(redirectUri)) {
          throw ClientConfigurationError.createRedirectUriEmptyError();
        }
      };
      RequestValidator2.validatePrompt = function(prompt) {
        var promptValues = [];
        for (var value in PromptValue) {
          promptValues.push(PromptValue[value]);
        }
        if (promptValues.indexOf(prompt) < 0) {
          throw ClientConfigurationError.createInvalidPromptError(prompt);
        }
      };
      RequestValidator2.validateClaims = function(claims) {
        try {
          JSON.parse(claims);
        } catch (e) {
          throw ClientConfigurationError.createInvalidClaimsRequestError();
        }
      };
      RequestValidator2.validateCodeChallengeParams = function(codeChallenge, codeChallengeMethod) {
        if (StringUtils.isEmpty(codeChallenge) || StringUtils.isEmpty(codeChallengeMethod)) {
          throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
        } else {
          this.validateCodeChallengeMethod(codeChallengeMethod);
        }
      };
      RequestValidator2.validateCodeChallengeMethod = function(codeChallengeMethod) {
        if ([
          CodeChallengeMethodValues.PLAIN,
          CodeChallengeMethodValues.S256
        ].indexOf(codeChallengeMethod) < 0) {
          throw ClientConfigurationError.createInvalidCodeChallengeMethodError();
        }
      };
      RequestValidator2.sanitizeEQParams = function(eQParams, queryParams) {
        if (!eQParams) {
          return {};
        }
        queryParams.forEach(function(value, key) {
          if (eQParams[key]) {
            delete eQParams[key];
          }
        });
        return eQParams;
      };
      return RequestValidator2;
    }();
  }
});
var RequestParameterBuilder;
var init_RequestParameterBuilder = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.js"() {
    "use strict";
    init_tslib();
    init_Constants();
    init_ScopeSet();
    init_ClientConfigurationError();
    init_RequestValidator();
    init_StringUtils();
    RequestParameterBuilder = /** @class */
    function() {
      function RequestParameterBuilder2() {
        this.parameters = /* @__PURE__ */ new Map();
      }
      RequestParameterBuilder2.prototype.addResponseTypeCode = function() {
        this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.CODE_RESPONSE_TYPE));
      };
      RequestParameterBuilder2.prototype.addResponseTypeForTokenAndIdToken = function() {
        this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.TOKEN_RESPONSE_TYPE + " " + Constants.ID_TOKEN_RESPONSE_TYPE));
      };
      RequestParameterBuilder2.prototype.addResponseMode = function(responseMode) {
        this.parameters.set(AADServerParamKeys.RESPONSE_MODE, encodeURIComponent(responseMode ? responseMode : ResponseMode.QUERY));
      };
      RequestParameterBuilder2.prototype.addNativeBroker = function() {
        this.parameters.set(AADServerParamKeys.NATIVE_BROKER, encodeURIComponent("1"));
      };
      RequestParameterBuilder2.prototype.addScopes = function(scopes, addOidcScopes) {
        if (addOidcScopes === void 0) {
          addOidcScopes = true;
        }
        var requestScopes = addOidcScopes ? __spreadArrays(scopes || [], OIDC_DEFAULT_SCOPES) : scopes || [];
        var scopeSet = new ScopeSet(requestScopes);
        this.parameters.set(AADServerParamKeys.SCOPE, encodeURIComponent(scopeSet.printScopes()));
      };
      RequestParameterBuilder2.prototype.addClientId = function(clientId) {
        this.parameters.set(AADServerParamKeys.CLIENT_ID, encodeURIComponent(clientId));
      };
      RequestParameterBuilder2.prototype.addRedirectUri = function(redirectUri) {
        RequestValidator.validateRedirectUri(redirectUri);
        this.parameters.set(AADServerParamKeys.REDIRECT_URI, encodeURIComponent(redirectUri));
      };
      RequestParameterBuilder2.prototype.addPostLogoutRedirectUri = function(redirectUri) {
        RequestValidator.validateRedirectUri(redirectUri);
        this.parameters.set(AADServerParamKeys.POST_LOGOUT_URI, encodeURIComponent(redirectUri));
      };
      RequestParameterBuilder2.prototype.addIdTokenHint = function(idTokenHint) {
        this.parameters.set(AADServerParamKeys.ID_TOKEN_HINT, encodeURIComponent(idTokenHint));
      };
      RequestParameterBuilder2.prototype.addDomainHint = function(domainHint) {
        this.parameters.set(SSOTypes.DOMAIN_HINT, encodeURIComponent(domainHint));
      };
      RequestParameterBuilder2.prototype.addLoginHint = function(loginHint) {
        this.parameters.set(SSOTypes.LOGIN_HINT, encodeURIComponent(loginHint));
      };
      RequestParameterBuilder2.prototype.addCcsUpn = function(loginHint) {
        this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("UPN:" + loginHint));
      };
      RequestParameterBuilder2.prototype.addCcsOid = function(clientInfo) {
        this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("Oid:" + clientInfo.uid + "@" + clientInfo.utid));
      };
      RequestParameterBuilder2.prototype.addSid = function(sid) {
        this.parameters.set(SSOTypes.SID, encodeURIComponent(sid));
      };
      RequestParameterBuilder2.prototype.addClaims = function(claims, clientCapabilities) {
        var mergedClaims = this.addClientCapabilitiesToClaims(claims, clientCapabilities);
        RequestValidator.validateClaims(mergedClaims);
        this.parameters.set(AADServerParamKeys.CLAIMS, encodeURIComponent(mergedClaims));
      };
      RequestParameterBuilder2.prototype.addCorrelationId = function(correlationId) {
        this.parameters.set(AADServerParamKeys.CLIENT_REQUEST_ID, encodeURIComponent(correlationId));
      };
      RequestParameterBuilder2.prototype.addLibraryInfo = function(libraryInfo) {
        this.parameters.set(AADServerParamKeys.X_CLIENT_SKU, libraryInfo.sku);
        this.parameters.set(AADServerParamKeys.X_CLIENT_VER, libraryInfo.version);
        if (libraryInfo.os) {
          this.parameters.set(AADServerParamKeys.X_CLIENT_OS, libraryInfo.os);
        }
        if (libraryInfo.cpu) {
          this.parameters.set(AADServerParamKeys.X_CLIENT_CPU, libraryInfo.cpu);
        }
      };
      RequestParameterBuilder2.prototype.addApplicationTelemetry = function(appTelemetry) {
        if (appTelemetry === null || appTelemetry === void 0 ? void 0 : appTelemetry.appName) {
          this.parameters.set(AADServerParamKeys.X_APP_NAME, appTelemetry.appName);
        }
        if (appTelemetry === null || appTelemetry === void 0 ? void 0 : appTelemetry.appVersion) {
          this.parameters.set(AADServerParamKeys.X_APP_VER, appTelemetry.appVersion);
        }
      };
      RequestParameterBuilder2.prototype.addPrompt = function(prompt) {
        RequestValidator.validatePrompt(prompt);
        this.parameters.set("" + AADServerParamKeys.PROMPT, encodeURIComponent(prompt));
      };
      RequestParameterBuilder2.prototype.addState = function(state) {
        if (!StringUtils.isEmpty(state)) {
          this.parameters.set(AADServerParamKeys.STATE, encodeURIComponent(state));
        }
      };
      RequestParameterBuilder2.prototype.addNonce = function(nonce) {
        this.parameters.set(AADServerParamKeys.NONCE, encodeURIComponent(nonce));
      };
      RequestParameterBuilder2.prototype.addCodeChallengeParams = function(codeChallenge, codeChallengeMethod) {
        RequestValidator.validateCodeChallengeParams(codeChallenge, codeChallengeMethod);
        if (codeChallenge && codeChallengeMethod) {
          this.parameters.set(AADServerParamKeys.CODE_CHALLENGE, encodeURIComponent(codeChallenge));
          this.parameters.set(AADServerParamKeys.CODE_CHALLENGE_METHOD, encodeURIComponent(codeChallengeMethod));
        } else {
          throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
        }
      };
      RequestParameterBuilder2.prototype.addAuthorizationCode = function(code) {
        this.parameters.set(AADServerParamKeys.CODE, encodeURIComponent(code));
      };
      RequestParameterBuilder2.prototype.addDeviceCode = function(code) {
        this.parameters.set(AADServerParamKeys.DEVICE_CODE, encodeURIComponent(code));
      };
      RequestParameterBuilder2.prototype.addRefreshToken = function(refreshToken) {
        this.parameters.set(AADServerParamKeys.REFRESH_TOKEN, encodeURIComponent(refreshToken));
      };
      RequestParameterBuilder2.prototype.addCodeVerifier = function(codeVerifier) {
        this.parameters.set(AADServerParamKeys.CODE_VERIFIER, encodeURIComponent(codeVerifier));
      };
      RequestParameterBuilder2.prototype.addClientSecret = function(clientSecret) {
        this.parameters.set(AADServerParamKeys.CLIENT_SECRET, encodeURIComponent(clientSecret));
      };
      RequestParameterBuilder2.prototype.addClientAssertion = function(clientAssertion) {
        if (!StringUtils.isEmpty(clientAssertion)) {
          this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION, encodeURIComponent(clientAssertion));
        }
      };
      RequestParameterBuilder2.prototype.addClientAssertionType = function(clientAssertionType) {
        if (!StringUtils.isEmpty(clientAssertionType)) {
          this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION_TYPE, encodeURIComponent(clientAssertionType));
        }
      };
      RequestParameterBuilder2.prototype.addOboAssertion = function(oboAssertion) {
        this.parameters.set(AADServerParamKeys.OBO_ASSERTION, encodeURIComponent(oboAssertion));
      };
      RequestParameterBuilder2.prototype.addRequestTokenUse = function(tokenUse) {
        this.parameters.set(AADServerParamKeys.REQUESTED_TOKEN_USE, encodeURIComponent(tokenUse));
      };
      RequestParameterBuilder2.prototype.addGrantType = function(grantType) {
        this.parameters.set(AADServerParamKeys.GRANT_TYPE, encodeURIComponent(grantType));
      };
      RequestParameterBuilder2.prototype.addClientInfo = function() {
        this.parameters.set(CLIENT_INFO, "1");
      };
      RequestParameterBuilder2.prototype.addExtraQueryParameters = function(eQparams) {
        var _this = this;
        RequestValidator.sanitizeEQParams(eQparams, this.parameters);
        Object.keys(eQparams).forEach(function(key) {
          _this.parameters.set(key, eQparams[key]);
        });
      };
      RequestParameterBuilder2.prototype.addClientCapabilitiesToClaims = function(claims, clientCapabilities) {
        var mergedClaims;
        if (!claims) {
          mergedClaims = {};
        } else {
          try {
            mergedClaims = JSON.parse(claims);
          } catch (e) {
            throw ClientConfigurationError.createInvalidClaimsRequestError();
          }
        }
        if (clientCapabilities && clientCapabilities.length > 0) {
          if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
            mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
          }
          mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
            values: clientCapabilities
          };
        }
        return JSON.stringify(mergedClaims);
      };
      RequestParameterBuilder2.prototype.addUsername = function(username) {
        this.parameters.set(PasswordGrantConstants.username, encodeURIComponent(username));
      };
      RequestParameterBuilder2.prototype.addPassword = function(password) {
        this.parameters.set(PasswordGrantConstants.password, encodeURIComponent(password));
      };
      RequestParameterBuilder2.prototype.addPopToken = function(cnfString) {
        if (!StringUtils.isEmpty(cnfString)) {
          this.parameters.set(AADServerParamKeys.TOKEN_TYPE, AuthenticationScheme.POP);
          this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(cnfString));
        }
      };
      RequestParameterBuilder2.prototype.addSshJwk = function(sshJwkString) {
        if (!StringUtils.isEmpty(sshJwkString)) {
          this.parameters.set(AADServerParamKeys.TOKEN_TYPE, AuthenticationScheme.SSH);
          this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(sshJwkString));
        }
      };
      RequestParameterBuilder2.prototype.addServerTelemetry = function(serverTelemetryManager) {
        this.parameters.set(AADServerParamKeys.X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
        this.parameters.set(AADServerParamKeys.X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
      };
      RequestParameterBuilder2.prototype.addThrottling = function() {
        this.parameters.set(AADServerParamKeys.X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
      };
      RequestParameterBuilder2.prototype.addLogoutHint = function(logoutHint) {
        this.parameters.set(AADServerParamKeys.LOGOUT_HINT, encodeURIComponent(logoutHint));
      };
      RequestParameterBuilder2.prototype.createQueryString = function() {
        var queryParameterArray = new Array();
        this.parameters.forEach(function(value, key) {
          queryParameterArray.push(key + "=" + value);
        });
        return queryParameterArray.join("&");
      };
      return RequestParameterBuilder2;
    }();
  }
});
var IdTokenEntity;
var init_IdTokenEntity = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/cache/entities/IdTokenEntity.js"() {
    "use strict";
    init_tslib();
    init_CredentialEntity();
    init_Constants();
    IdTokenEntity = /** @class */
    function(_super) {
      __extends(IdTokenEntity2, _super);
      function IdTokenEntity2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      IdTokenEntity2.createIdTokenEntity = function(homeAccountId, environment, idToken, clientId, tenantId) {
        var idTokenEntity = new IdTokenEntity2();
        idTokenEntity.credentialType = CredentialType.ID_TOKEN;
        idTokenEntity.homeAccountId = homeAccountId;
        idTokenEntity.environment = environment;
        idTokenEntity.clientId = clientId;
        idTokenEntity.secret = idToken;
        idTokenEntity.realm = tenantId;
        return idTokenEntity;
      };
      IdTokenEntity2.isIdTokenEntity = function(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity["credentialType"] === CredentialType.ID_TOKEN;
      };
      return IdTokenEntity2;
    }(CredentialEntity);
  }
});
var TimeUtils;
var init_TimeUtils = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/utils/TimeUtils.js"() {
    "use strict";
    TimeUtils = /** @class */
    function() {
      function TimeUtils2() {
      }
      TimeUtils2.nowSeconds = function() {
        return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
      };
      TimeUtils2.isTokenExpired = function(expiresOn, offset) {
        var expirationSec = Number(expiresOn) || 0;
        var offsetCurrentTimeSec = TimeUtils2.nowSeconds() + offset;
        return offsetCurrentTimeSec > expirationSec;
      };
      TimeUtils2.wasClockTurnedBack = function(cachedAt) {
        var cachedAtSec = Number(cachedAt);
        return cachedAtSec > TimeUtils2.nowSeconds();
      };
      TimeUtils2.delay = function(t, value) {
        return new Promise(function(resolve) {
          return setTimeout(function() {
            return resolve(value);
          }, t);
        });
      };
      return TimeUtils2;
    }();
  }
});
var AccessTokenEntity;
var init_AccessTokenEntity = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/cache/entities/AccessTokenEntity.js"() {
    "use strict";
    init_tslib();
    init_CredentialEntity();
    init_Constants();
    init_TimeUtils();
    init_StringUtils();
    init_AuthToken();
    init_ClientAuthError();
    AccessTokenEntity = /** @class */
    function(_super) {
      __extends(AccessTokenEntity2, _super);
      function AccessTokenEntity2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AccessTokenEntity2.createAccessTokenEntity = function(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
        var _a2, _b;
        var atEntity = new AccessTokenEntity2();
        atEntity.homeAccountId = homeAccountId;
        atEntity.credentialType = CredentialType.ACCESS_TOKEN;
        atEntity.secret = accessToken;
        var currentTime = TimeUtils.nowSeconds();
        atEntity.cachedAt = currentTime.toString();
        atEntity.expiresOn = expiresOn.toString();
        atEntity.extendedExpiresOn = extExpiresOn.toString();
        if (refreshOn) {
          atEntity.refreshOn = refreshOn.toString();
        }
        atEntity.environment = environment;
        atEntity.clientId = clientId;
        atEntity.realm = tenantId;
        atEntity.target = scopes;
        atEntity.userAssertionHash = userAssertionHash;
        atEntity.tokenType = StringUtils.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType;
        if (requestedClaims) {
          atEntity.requestedClaims = requestedClaims;
          atEntity.requestedClaimsHash = requestedClaimsHash;
        }
        if (((_a2 = atEntity.tokenType) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) {
          atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
          switch (atEntity.tokenType) {
            case AuthenticationScheme.POP:
              var tokenClaims = AuthToken.extractTokenClaims(accessToken, cryptoUtils);
              if (!((_b = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _b === void 0 ? void 0 : _b.kid)) {
                throw ClientAuthError.createTokenClaimsRequiredError();
              }
              atEntity.keyId = tokenClaims.cnf.kid;
              break;
            case AuthenticationScheme.SSH:
              atEntity.keyId = keyId;
          }
        }
        return atEntity;
      };
      AccessTokenEntity2.isAccessTokenEntity = function(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity.hasOwnProperty("target") && (entity["credentialType"] === CredentialType.ACCESS_TOKEN || entity["credentialType"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
      };
      return AccessTokenEntity2;
    }(CredentialEntity);
  }
});
var RefreshTokenEntity;
var init_RefreshTokenEntity = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/cache/entities/RefreshTokenEntity.js"() {
    "use strict";
    init_tslib();
    init_CredentialEntity();
    init_Constants();
    RefreshTokenEntity = /** @class */
    function(_super) {
      __extends(RefreshTokenEntity2, _super);
      function RefreshTokenEntity2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      RefreshTokenEntity2.createRefreshTokenEntity = function(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash) {
        var rtEntity = new RefreshTokenEntity2();
        rtEntity.clientId = clientId;
        rtEntity.credentialType = CredentialType.REFRESH_TOKEN;
        rtEntity.environment = environment;
        rtEntity.homeAccountId = homeAccountId;
        rtEntity.secret = refreshToken;
        rtEntity.userAssertionHash = userAssertionHash;
        if (familyId)
          rtEntity.familyId = familyId;
        return rtEntity;
      };
      RefreshTokenEntity2.isRefreshTokenEntity = function(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity["credentialType"] === CredentialType.REFRESH_TOKEN;
      };
      return RefreshTokenEntity2;
    }(CredentialEntity);
  }
});
var InteractionRequiredServerErrorMessage, InteractionRequiredAuthSubErrorMessage, InteractionRequiredAuthErrorMessage, InteractionRequiredAuthError;
var init_InteractionRequiredAuthError = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.js"() {
    "use strict";
    init_tslib();
    init_AuthError();
    InteractionRequiredServerErrorMessage = [
      "interaction_required",
      "consent_required",
      "login_required"
    ];
    InteractionRequiredAuthSubErrorMessage = [
      "message_only",
      "additional_action",
      "basic_action",
      "user_password_expired",
      "consent_required"
    ];
    InteractionRequiredAuthErrorMessage = {
      noTokensFoundError: {
        code: "no_tokens_found",
        desc: "No refresh token found in the cache. Please sign-in."
      },
      native_account_unavailable: {
        code: "native_account_unavailable",
        desc: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API."
      }
    };
    InteractionRequiredAuthError = /** @class */
    function(_super) {
      __extends(InteractionRequiredAuthError2, _super);
      function InteractionRequiredAuthError2(errorCode, errorMessage, subError) {
        var _this = _super.call(this, errorCode, errorMessage, subError) || this;
        _this.name = "InteractionRequiredAuthError";
        Object.setPrototypeOf(_this, InteractionRequiredAuthError2.prototype);
        return _this;
      }
      InteractionRequiredAuthError2.isInteractionRequiredError = function(errorCode, errorString, subError) {
        var isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
        var isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
        var isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some(function(irErrorCode) {
          return errorString.indexOf(irErrorCode) > -1;
        });
        return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
      };
      InteractionRequiredAuthError2.createNoTokensFoundError = function() {
        return new InteractionRequiredAuthError2(InteractionRequiredAuthErrorMessage.noTokensFoundError.code, InteractionRequiredAuthErrorMessage.noTokensFoundError.desc);
      };
      InteractionRequiredAuthError2.createNativeAccountUnavailableError = function() {
        return new InteractionRequiredAuthError2(InteractionRequiredAuthErrorMessage.native_account_unavailable.code, InteractionRequiredAuthErrorMessage.native_account_unavailable.desc);
      };
      return InteractionRequiredAuthError2;
    }(AuthError);
  }
});
var CacheRecord;
var init_CacheRecord = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/cache/entities/CacheRecord.js"() {
    "use strict";
    CacheRecord = /** @class */
    /* @__PURE__ */ function() {
      function CacheRecord2(accountEntity, idTokenEntity, accessTokenEntity, refreshTokenEntity, appMetadataEntity) {
        this.account = accountEntity || null;
        this.idToken = idTokenEntity || null;
        this.accessToken = accessTokenEntity || null;
        this.refreshToken = refreshTokenEntity || null;
        this.appMetadata = appMetadataEntity || null;
      }
      return CacheRecord2;
    }();
  }
});
var ProtocolUtils;
var init_ProtocolUtils = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/utils/ProtocolUtils.js"() {
    "use strict";
    init_StringUtils();
    init_Constants();
    init_ClientAuthError();
    ProtocolUtils = /** @class */
    function() {
      function ProtocolUtils2() {
      }
      ProtocolUtils2.setRequestState = function(cryptoObj, userState, meta) {
        var libraryState = ProtocolUtils2.generateLibraryState(cryptoObj, meta);
        return !StringUtils.isEmpty(userState) ? "" + libraryState + Constants.RESOURCE_DELIM + userState : libraryState;
      };
      ProtocolUtils2.generateLibraryState = function(cryptoObj, meta) {
        if (!cryptoObj) {
          throw ClientAuthError.createNoCryptoObjectError("generateLibraryState");
        }
        var stateObj = {
          id: cryptoObj.createNewGuid()
        };
        if (meta) {
          stateObj.meta = meta;
        }
        var stateString = JSON.stringify(stateObj);
        return cryptoObj.base64Encode(stateString);
      };
      ProtocolUtils2.parseRequestState = function(cryptoObj, state) {
        if (!cryptoObj) {
          throw ClientAuthError.createNoCryptoObjectError("parseRequestState");
        }
        if (StringUtils.isEmpty(state)) {
          throw ClientAuthError.createInvalidStateError(state, "Null, undefined or empty state");
        }
        try {
          var splitState = state.split(Constants.RESOURCE_DELIM);
          var libraryState = splitState[0];
          var userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;
          var libraryStateString = cryptoObj.base64Decode(libraryState);
          var libraryStateObj = JSON.parse(libraryStateString);
          return {
            userRequestState: !StringUtils.isEmpty(userState) ? userState : Constants.EMPTY_STRING,
            libraryState: libraryStateObj
          };
        } catch (e) {
          throw ClientAuthError.createInvalidStateError(state, e);
        }
      };
      return ProtocolUtils2;
    }();
  }
});
var UrlString;
var init_UrlString = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/url/UrlString.js"() {
    "use strict";
    init_ClientConfigurationError();
    init_ClientAuthError();
    init_StringUtils();
    init_Constants();
    UrlString = /** @class */
    function() {
      function UrlString2(url) {
        this._urlString = url;
        if (StringUtils.isEmpty(this._urlString)) {
          throw ClientConfigurationError.createUrlEmptyError();
        }
        if (StringUtils.isEmpty(this.getHash())) {
          this._urlString = UrlString2.canonicalizeUri(url);
        }
      }
      Object.defineProperty(UrlString2.prototype, "urlString", {
        get: function() {
          return this._urlString;
        },
        enumerable: false,
        configurable: true
      });
      UrlString2.canonicalizeUri = function(url) {
        if (url) {
          var lowerCaseUrl = url.toLowerCase();
          if (StringUtils.endsWith(lowerCaseUrl, "?")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -1);
          } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -2);
          }
          if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
            lowerCaseUrl += "/";
          }
          return lowerCaseUrl;
        }
        return url;
      };
      UrlString2.prototype.validateAsUri = function() {
        var components;
        try {
          components = this.getUrlComponents();
        } catch (e) {
          throw ClientConfigurationError.createUrlParseError(e);
        }
        if (!components.HostNameAndPort || !components.PathSegments) {
          throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
        }
        if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
          throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);
        }
      };
      UrlString2.appendQueryString = function(url, queryString) {
        if (StringUtils.isEmpty(queryString)) {
          return url;
        }
        return url.indexOf("?") < 0 ? url + "?" + queryString : url + "&" + queryString;
      };
      UrlString2.removeHashFromUrl = function(url) {
        return UrlString2.canonicalizeUri(url.split("#")[0]);
      };
      UrlString2.prototype.replaceTenantPath = function(tenantId) {
        var urlObject = this.getUrlComponents();
        var pathArray = urlObject.PathSegments;
        if (tenantId && (pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS))) {
          pathArray[0] = tenantId;
        }
        return UrlString2.constructAuthorityUriFromObject(urlObject);
      };
      UrlString2.prototype.getHash = function() {
        return UrlString2.parseHash(this.urlString);
      };
      UrlString2.prototype.getUrlComponents = function() {
        var regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
        var match = this.urlString.match(regEx);
        if (!match) {
          throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
        }
        var urlComponents = {
          Protocol: match[1],
          HostNameAndPort: match[4],
          AbsolutePath: match[5],
          QueryString: match[7]
        };
        var pathSegments = urlComponents.AbsolutePath.split("/");
        pathSegments = pathSegments.filter(function(val) {
          return val && val.length > 0;
        });
        urlComponents.PathSegments = pathSegments;
        if (!StringUtils.isEmpty(urlComponents.QueryString) && urlComponents.QueryString.endsWith("/")) {
          urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
        }
        return urlComponents;
      };
      UrlString2.getDomainFromUrl = function(url) {
        var regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
        var match = url.match(regEx);
        if (!match) {
          throw ClientConfigurationError.createUrlParseError("Given url string: " + url);
        }
        return match[2];
      };
      UrlString2.getAbsoluteUrl = function(relativeUrl, baseUrl) {
        if (relativeUrl[0] === Constants.FORWARD_SLASH) {
          var url = new UrlString2(baseUrl);
          var baseComponents = url.getUrlComponents();
          return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
        }
        return relativeUrl;
      };
      UrlString2.parseHash = function(hashString) {
        var hashIndex1 = hashString.indexOf("#");
        var hashIndex2 = hashString.indexOf("#/");
        if (hashIndex2 > -1) {
          return hashString.substring(hashIndex2 + 2);
        } else if (hashIndex1 > -1) {
          return hashString.substring(hashIndex1 + 1);
        }
        return Constants.EMPTY_STRING;
      };
      UrlString2.parseQueryString = function(queryString) {
        var queryIndex1 = queryString.indexOf("?");
        var queryIndex2 = queryString.indexOf("/?");
        if (queryIndex2 > -1) {
          return queryString.substring(queryIndex2 + 2);
        } else if (queryIndex1 > -1) {
          return queryString.substring(queryIndex1 + 1);
        }
        return Constants.EMPTY_STRING;
      };
      UrlString2.constructAuthorityUriFromObject = function(urlObject) {
        return new UrlString2(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
      };
      UrlString2.getDeserializedHash = function(hash) {
        if (StringUtils.isEmpty(hash)) {
          return {};
        }
        var parsedHash = UrlString2.parseHash(hash);
        var deserializedHash = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedHash) ? hash : parsedHash);
        if (!deserializedHash) {
          throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));
        }
        return deserializedHash;
      };
      UrlString2.getDeserializedQueryString = function(query) {
        if (StringUtils.isEmpty(query)) {
          return {};
        }
        var parsedQueryString = UrlString2.parseQueryString(query);
        var deserializedQueryString = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedQueryString) ? query : parsedQueryString);
        if (!deserializedQueryString) {
          throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedQueryString));
        }
        return deserializedQueryString;
      };
      UrlString2.hashContainsKnownProperties = function(hash) {
        if (StringUtils.isEmpty(hash) || hash.indexOf("=") < 0) {
          return false;
        }
        var parameters = UrlString2.getDeserializedHash(hash);
        return !!(parameters.code || parameters.error_description || parameters.error || parameters.state);
      };
      return UrlString2;
    }();
  }
});
var KeyLocation, PopTokenGenerator;
var init_PopTokenGenerator = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.js"() {
    "use strict";
    init_tslib();
    init_TimeUtils();
    init_UrlString();
    (function(KeyLocation2) {
      KeyLocation2["SW"] = "sw";
      KeyLocation2["UHW"] = "uhw";
    })(KeyLocation || (KeyLocation = {}));
    PopTokenGenerator = /** @class */
    function() {
      function PopTokenGenerator2(cryptoUtils) {
        this.cryptoUtils = cryptoUtils;
      }
      PopTokenGenerator2.prototype.generateCnf = function(request3) {
        return __awaiter(this, void 0, void 0, function() {
          var reqCnf, reqCnfString, _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.generateKid(request3)];
              case 1:
                reqCnf = _b.sent();
                reqCnfString = this.cryptoUtils.base64Encode(JSON.stringify(reqCnf));
                _a2 = {
                  kid: reqCnf.kid,
                  reqCnfString
                };
                return [4, this.cryptoUtils.hashString(reqCnfString)];
              case 2:
                return [2, (_a2.reqCnfHash = _b.sent(), _a2)];
            }
          });
        });
      };
      PopTokenGenerator2.prototype.generateKid = function(request3) {
        return __awaiter(this, void 0, void 0, function() {
          var kidThumbprint;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.cryptoUtils.getPublicKeyThumbprint(request3)];
              case 1:
                kidThumbprint = _a2.sent();
                return [2, {
                  kid: kidThumbprint,
                  xms_ksl: KeyLocation.SW
                }];
            }
          });
        });
      };
      PopTokenGenerator2.prototype.signPopToken = function(accessToken, keyId, request3) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            return [2, this.signPayload(accessToken, keyId, request3)];
          });
        });
      };
      PopTokenGenerator2.prototype.signPayload = function(payload, keyId, request3, claims) {
        return __awaiter(this, void 0, void 0, function() {
          var resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, resourceUrlString, resourceUrlComponents;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                resourceRequestMethod = request3.resourceRequestMethod, resourceRequestUri = request3.resourceRequestUri, shrClaims = request3.shrClaims, shrNonce = request3.shrNonce;
                resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : void 0;
                resourceUrlComponents = resourceUrlString === null || resourceUrlString === void 0 ? void 0 : resourceUrlString.getUrlComponents();
                return [4, this.cryptoUtils.signJwt(__assign({ at: payload, ts: TimeUtils.nowSeconds(), m: resourceRequestMethod === null || resourceRequestMethod === void 0 ? void 0 : resourceRequestMethod.toUpperCase(), u: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.HostNameAndPort, nonce: shrNonce || this.cryptoUtils.createNewGuid(), p: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.AbsolutePath, q: (resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.QueryString) ? [[], resourceUrlComponents.QueryString] : void 0, client_claims: shrClaims || void 0 }, claims), keyId, request3.correlationId)];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      return PopTokenGenerator2;
    }();
  }
});
var AppMetadataEntity;
var init_AppMetadataEntity = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/cache/entities/AppMetadataEntity.js"() {
    "use strict";
    init_Constants();
    AppMetadataEntity = /** @class */
    function() {
      function AppMetadataEntity2() {
      }
      AppMetadataEntity2.prototype.generateAppMetadataKey = function() {
        return AppMetadataEntity2.generateAppMetadataCacheKey(this.environment, this.clientId);
      };
      AppMetadataEntity2.generateAppMetadataCacheKey = function(environment, clientId) {
        var appMetaDataKeyArray = [
          APP_METADATA,
          environment,
          clientId
        ];
        return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      };
      AppMetadataEntity2.createAppMetadataEntity = function(clientId, environment, familyId) {
        var appMetadata = new AppMetadataEntity2();
        appMetadata.clientId = clientId;
        appMetadata.environment = environment;
        if (familyId) {
          appMetadata.familyId = familyId;
        }
        return appMetadata;
      };
      AppMetadataEntity2.isAppMetadataEntity = function(key, entity) {
        if (!entity) {
          return false;
        }
        return key.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("environment");
      };
      return AppMetadataEntity2;
    }();
  }
});
var TokenCacheContext;
var init_TokenCacheContext = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.js"() {
    "use strict";
    TokenCacheContext = /** @class */
    function() {
      function TokenCacheContext2(tokenCache, hasChanged) {
        this.cache = tokenCache;
        this.hasChanged = hasChanged;
      }
      Object.defineProperty(TokenCacheContext2.prototype, "cacheHasChanged", {
        /**
         * boolean which indicates the changes in cache
         */
        get: function() {
          return this.hasChanged;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TokenCacheContext2.prototype, "tokenCache", {
        /**
         * function to retrieve the token cache
         */
        get: function() {
          return this.cache;
        },
        enumerable: false,
        configurable: true
      });
      return TokenCacheContext2;
    }();
  }
});
var ResponseHandler;
var init_ResponseHandler = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/response/ResponseHandler.js"() {
    "use strict";
    init_tslib();
    init_ClientInfo();
    init_ClientAuthError();
    init_StringUtils();
    init_ServerError();
    init_AuthToken();
    init_ScopeSet();
    init_AccountEntity();
    init_AuthorityType();
    init_IdTokenEntity();
    init_AccessTokenEntity();
    init_RefreshTokenEntity();
    init_InteractionRequiredAuthError();
    init_CacheRecord();
    init_ProtocolUtils();
    init_Constants();
    init_PopTokenGenerator();
    init_AppMetadataEntity();
    init_TokenCacheContext();
    ResponseHandler = /** @class */
    function() {
      function ResponseHandler2(clientId, cacheStorage, cryptoObj, logger25, serializableCache, persistencePlugin) {
        this.clientId = clientId;
        this.cacheStorage = cacheStorage;
        this.cryptoObj = cryptoObj;
        this.logger = logger25;
        this.serializableCache = serializableCache;
        this.persistencePlugin = persistencePlugin;
      }
      ResponseHandler2.prototype.validateServerAuthorizationCodeResponse = function(serverResponseHash, cachedState, cryptoObj) {
        if (!serverResponseHash.state || !cachedState) {
          throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError("Server State") : ClientAuthError.createStateNotFoundError("Cached State");
        }
        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {
          throw ClientAuthError.createStateMismatchError();
        }
        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {
          if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {
            throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);
          }
          throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);
        }
        if (serverResponseHash.client_info) {
          buildClientInfo(serverResponseHash.client_info, cryptoObj);
        }
      };
      ResponseHandler2.prototype.validateTokenResponse = function(serverResponse) {
        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
          if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
            throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror);
          }
          var errString = serverResponse.error_codes + " - [" + serverResponse.timestamp + "]: " + serverResponse.error_description + " - Correlation ID: " + serverResponse.correlation_id + " - Trace ID: " + serverResponse.trace_id;
          throw new ServerError(serverResponse.error, errString, serverResponse.suberror);
        }
      };
      ResponseHandler2.prototype.handleServerTokenResponse = function(serverTokenResponse, authority, reqTimestamp, request3, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
        return __awaiter(this, void 0, void 0, function() {
          var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key, account;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (serverTokenResponse.id_token) {
                  idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);
                  if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {
                    if (idTokenObj.claims.nonce !== authCodePayload.nonce) {
                      throw ClientAuthError.createNonceMismatchError();
                    }
                  }
                  if (request3.maxAge || request3.maxAge === 0) {
                    authTime = idTokenObj.claims.auth_time;
                    if (!authTime) {
                      throw ClientAuthError.createAuthTimeNotFoundError();
                    }
                    AuthToken.checkMaxAge(authTime, request3.maxAge);
                  }
                }
                this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);
                if (!!authCodePayload && !!authCodePayload.state) {
                  requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
                }
                serverTokenResponse.key_id = serverTokenResponse.key_id || request3.sshKid || void 0;
                cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request3, idTokenObj, userAssertionHash, authCodePayload);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, , 5, 8]);
                if (!(this.persistencePlugin && this.serializableCache))
                  return [3, 3];
                this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
                cacheContext = new TokenCacheContext(this.serializableCache, true);
                return [4, this.persistencePlugin.beforeCacheAccess(cacheContext)];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
                  key = cacheRecord.account.generateAccountKey();
                  account = this.cacheStorage.getAccount(key);
                  if (!account) {
                    this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
                    return [2, ResponseHandler2.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request3, idTokenObj, requestStateObj, void 0, serverRequestId)];
                  }
                }
                return [4, this.cacheStorage.saveCacheRecord(cacheRecord)];
              case 4:
                _a2.sent();
                return [3, 8];
              case 5:
                if (!(this.persistencePlugin && this.serializableCache && cacheContext))
                  return [3, 7];
                this.logger.verbose("Persistence enabled, calling afterCacheAccess");
                return [4, this.persistencePlugin.afterCacheAccess(cacheContext)];
              case 6:
                _a2.sent();
                _a2.label = 7;
              case 7:
                return [
                  7
                  /*endfinally*/
                ];
              case 8:
                return [2, ResponseHandler2.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request3, idTokenObj, requestStateObj, serverTokenResponse.spa_code, serverRequestId)];
            }
          });
        });
      };
      ResponseHandler2.prototype.generateCacheRecord = function(serverTokenResponse, authority, reqTimestamp, request3, idTokenObj, userAssertionHash, authCodePayload) {
        var env = authority.getPreferredCache();
        if (StringUtils.isEmpty(env)) {
          throw ClientAuthError.createInvalidCacheEnvironmentError();
        }
        var cachedIdToken;
        var cachedAccount;
        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {
          cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);
          cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);
        }
        var cachedAccessToken = null;
        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {
          var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request3.scopes || []);
          var expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
          var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
          var refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || void 0;
          var tokenExpirationSeconds = reqTimestamp + expiresIn;
          var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
          var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : void 0;
          cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request3.claims, request3.requestedClaimsHash);
        }
        var cachedRefreshToken = null;
        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {
          cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);
        }
        var cachedAppMetadata = null;
        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {
          cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);
        }
        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);
      };
      ResponseHandler2.prototype.generateAccountEntity = function(serverTokenResponse, idToken, authority, authCodePayload) {
        var authorityType = authority.authorityType;
        var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;
        var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;
        if (authorityType === AuthorityType.Adfs) {
          this.logger.verbose("Authority type is ADFS, creating ADFS account");
          return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);
        }
        if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === "AAD") {
          throw ClientAuthError.createClientInfoEmptyError();
        }
        return serverTokenResponse.client_info ? AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) : AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);
      };
      ResponseHandler2.generateAuthenticationResult = function(cryptoObj, authority, cacheRecord, fromTokenCache, request3, idTokenObj, requestState, code, requestId) {
        var _a2, _b, _c;
        return __awaiter(this, void 0, void 0, function() {
          var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;
          return __generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                accessToken = Constants.EMPTY_STRING;
                responseScopes = [];
                expiresOn = null;
                familyId = Constants.EMPTY_STRING;
                if (!cacheRecord.accessToken)
                  return [3, 4];
                if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP))
                  return [3, 2];
                popTokenGenerator = new PopTokenGenerator(cryptoObj);
                _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;
                if (!keyId) {
                  throw ClientAuthError.createKeyIdMissingError();
                }
                return [4, popTokenGenerator.signPopToken(secret, keyId, request3)];
              case 1:
                accessToken = _e.sent();
                return [3, 3];
              case 2:
                accessToken = cacheRecord.accessToken.secret;
                _e.label = 3;
              case 3:
                responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
                expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1e3);
                extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1e3);
                _e.label = 4;
              case 4:
                if (cacheRecord.appMetadata) {
                  familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;
                }
                uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;
                tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;
                return [2, {
                  authority: authority.canonicalAuthority,
                  uniqueId: uid,
                  tenantId: tid,
                  scopes: responseScopes,
                  account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,
                  idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,
                  idTokenClaims: idTokenObj ? idTokenObj.claims : {},
                  accessToken,
                  fromCache: fromTokenCache,
                  expiresOn,
                  correlationId: request3.correlationId,
                  requestId: requestId || Constants.EMPTY_STRING,
                  extExpiresOn,
                  familyId,
                  tokenType: ((_a2 = cacheRecord.accessToken) === null || _a2 === void 0 ? void 0 : _a2.tokenType) || Constants.EMPTY_STRING,
                  state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,
                  cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,
                  msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,
                  code,
                  fromNativeBroker: false
                }];
            }
          });
        });
      };
      return ResponseHandler2;
    }();
  }
});
var AuthorizationCodeClient;
var init_AuthorizationCodeClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.js"() {
    "use strict";
    init_tslib();
    init_BaseClient();
    init_RequestParameterBuilder();
    init_Constants();
    init_ResponseHandler();
    init_StringUtils();
    init_ClientAuthError();
    init_UrlString();
    init_PopTokenGenerator();
    init_TimeUtils();
    init_ClientInfo();
    init_CcsCredential();
    init_ClientConfigurationError();
    init_RequestValidator();
    AuthorizationCodeClient = /** @class */
    function(_super) {
      __extends(AuthorizationCodeClient2, _super);
      function AuthorizationCodeClient2(configuration) {
        var _this = _super.call(this, configuration) || this;
        _this.includeRedirectUri = true;
        return _this;
      }
      AuthorizationCodeClient2.prototype.getAuthCodeUrl = function(request3) {
        return __awaiter(this, void 0, void 0, function() {
          var queryString;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.createAuthCodeUrlQueryString(request3)];
              case 1:
                queryString = _a2.sent();
                return [2, UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString)];
            }
          });
        });
      };
      AuthorizationCodeClient2.prototype.acquireToken = function(request3, authCodePayload) {
        var _a2;
        return __awaiter(this, void 0, void 0, function() {
          var reqTimestamp, response, requestId, responseHandler;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                this.logger.info("in acquireToken call");
                if (!request3 || StringUtils.isEmpty(request3.code)) {
                  throw ClientAuthError.createTokenRequestCannotBeMadeError();
                }
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.executeTokenRequest(this.authority, request3)];
              case 1:
                response = _b.sent();
                requestId = (_a2 = response.headers) === null || _a2 === void 0 ? void 0 : _a2[HeaderNames.X_MS_REQUEST_ID];
                responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                responseHandler.validateTokenResponse(response.body);
                return [4, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request3, authCodePayload, void 0, void 0, void 0, requestId)];
              case 2:
                return [2, _b.sent()];
            }
          });
        });
      };
      AuthorizationCodeClient2.prototype.handleFragmentResponse = function(hashFragment, cachedState) {
        var responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);
        var hashUrlString = new UrlString(hashFragment);
        var serverParams = UrlString.getDeserializedHash(hashUrlString.getHash());
        responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);
        if (!serverParams.code) {
          throw ClientAuthError.createNoAuthCodeInServerResponseError();
        }
        return __assign(__assign({}, serverParams), {
          // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod
          code: serverParams.code
        });
      };
      AuthorizationCodeClient2.prototype.getLogoutUri = function(logoutRequest) {
        if (!logoutRequest) {
          throw ClientConfigurationError.createEmptyLogoutRequestError();
        }
        var queryString = this.createLogoutUrlQueryString(logoutRequest);
        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
      };
      AuthorizationCodeClient2.prototype.executeTokenRequest = function(authority, request3) {
        return __awaiter(this, void 0, void 0, function() {
          var thumbprint, requestBody, queryParameters, ccsCredential, clientInfo, headers, endpoint;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                thumbprint = {
                  clientId: this.config.authOptions.clientId,
                  authority: authority.canonicalAuthority,
                  scopes: request3.scopes,
                  claims: request3.claims,
                  authenticationScheme: request3.authenticationScheme,
                  resourceRequestMethod: request3.resourceRequestMethod,
                  resourceRequestUri: request3.resourceRequestUri,
                  shrClaims: request3.shrClaims,
                  sshKid: request3.sshKid
                };
                return [4, this.createTokenRequestBody(request3)];
              case 1:
                requestBody = _a2.sent();
                queryParameters = this.createTokenQueryParameters(request3);
                ccsCredential = void 0;
                if (request3.clientInfo) {
                  try {
                    clientInfo = buildClientInfo(request3.clientInfo, this.cryptoUtils);
                    ccsCredential = {
                      credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,
                      type: CcsCredentialType.HOME_ACCOUNT_ID
                    };
                  } catch (e) {
                    this.logger.verbose("Could not parse client info for CCS Header: " + e);
                  }
                }
                headers = this.createTokenRequestHeaders(ccsCredential || request3.ccsCredential);
                endpoint = StringUtils.isEmpty(queryParameters) ? authority.tokenEndpoint : authority.tokenEndpoint + "?" + queryParameters;
                return [2, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];
            }
          });
        });
      };
      AuthorizationCodeClient2.prototype.createTokenQueryParameters = function(request3) {
        var parameterBuilder = new RequestParameterBuilder();
        if (request3.tokenQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request3.tokenQueryParameters);
        }
        return parameterBuilder.createQueryString();
      };
      AuthorizationCodeClient2.prototype.createTokenRequestBody = function(request3) {
        return __awaiter(this, void 0, void 0, function() {
          var parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, correlationId, ccsCred, clientInfo, clientInfo;
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                parameterBuilder = new RequestParameterBuilder();
                parameterBuilder.addClientId(this.config.authOptions.clientId);
                if (!this.includeRedirectUri) {
                  RequestValidator.validateRedirectUri(request3.redirectUri);
                } else {
                  parameterBuilder.addRedirectUri(request3.redirectUri);
                }
                parameterBuilder.addScopes(request3.scopes);
                parameterBuilder.addAuthorizationCode(request3.code);
                parameterBuilder.addLibraryInfo(this.config.libraryInfo);
                parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
                parameterBuilder.addThrottling();
                if (this.serverTelemetryManager) {
                  parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
                }
                if (request3.codeVerifier) {
                  parameterBuilder.addCodeVerifier(request3.codeVerifier);
                }
                if (this.config.clientCredentials.clientSecret) {
                  parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
                }
                if (this.config.clientCredentials.clientAssertion) {
                  clientAssertion = this.config.clientCredentials.clientAssertion;
                  parameterBuilder.addClientAssertion(clientAssertion.assertion);
                  parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
                }
                parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);
                parameterBuilder.addClientInfo();
                if (!(request3.authenticationScheme === AuthenticationScheme.POP))
                  return [3, 2];
                popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
                return [4, popTokenGenerator.generateCnf(request3)];
              case 1:
                reqCnfData = _b.sent();
                parameterBuilder.addPopToken(reqCnfData.reqCnfString);
                return [3, 3];
              case 2:
                if (request3.authenticationScheme === AuthenticationScheme.SSH) {
                  if (request3.sshJwk) {
                    parameterBuilder.addSshJwk(request3.sshJwk);
                  } else {
                    throw ClientConfigurationError.createMissingSshJwkError();
                  }
                }
                _b.label = 3;
              case 3:
                correlationId = request3.correlationId || this.config.cryptoInterface.createNewGuid();
                parameterBuilder.addCorrelationId(correlationId);
                if (!StringUtils.isEmptyObj(request3.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                  parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
                }
                ccsCred = void 0;
                if (request3.clientInfo) {
                  try {
                    clientInfo = buildClientInfo(request3.clientInfo, this.cryptoUtils);
                    ccsCred = {
                      credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,
                      type: CcsCredentialType.HOME_ACCOUNT_ID
                    };
                  } catch (e) {
                    this.logger.verbose("Could not parse client info for CCS Header: " + e);
                  }
                } else {
                  ccsCred = request3.ccsCredential;
                }
                if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
                  switch (ccsCred.type) {
                    case CcsCredentialType.HOME_ACCOUNT_ID:
                      try {
                        clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                        parameterBuilder.addCcsOid(clientInfo);
                      } catch (e) {
                        this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                      }
                      break;
                    case CcsCredentialType.UPN:
                      parameterBuilder.addCcsUpn(ccsCred.credential);
                      break;
                  }
                }
                if (request3.tokenBodyParameters) {
                  parameterBuilder.addExtraQueryParameters(request3.tokenBodyParameters);
                }
                if (request3.enableSpaAuthorizationCode && (!request3.tokenBodyParameters || !request3.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {
                  parameterBuilder.addExtraQueryParameters((_a2 = {}, _a2[AADServerParamKeys.RETURN_SPA_CODE] = "1", _a2));
                }
                return [2, parameterBuilder.createQueryString()];
            }
          });
        });
      };
      AuthorizationCodeClient2.prototype.createAuthCodeUrlQueryString = function(request3) {
        return __awaiter(this, void 0, void 0, function() {
          var parameterBuilder, requestScopes, correlationId, accountSid, accountLoginHintClaim, clientInfo, clientInfo, clientInfo, popTokenGenerator, reqCnfData;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                parameterBuilder = new RequestParameterBuilder();
                parameterBuilder.addClientId(this.config.authOptions.clientId);
                requestScopes = __spreadArrays(request3.scopes || [], request3.extraScopesToConsent || []);
                parameterBuilder.addScopes(requestScopes);
                parameterBuilder.addRedirectUri(request3.redirectUri);
                correlationId = request3.correlationId || this.config.cryptoInterface.createNewGuid();
                parameterBuilder.addCorrelationId(correlationId);
                parameterBuilder.addResponseMode(request3.responseMode);
                parameterBuilder.addResponseTypeCode();
                parameterBuilder.addLibraryInfo(this.config.libraryInfo);
                parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
                parameterBuilder.addClientInfo();
                if (request3.codeChallenge && request3.codeChallengeMethod) {
                  parameterBuilder.addCodeChallengeParams(request3.codeChallenge, request3.codeChallengeMethod);
                }
                if (request3.prompt) {
                  parameterBuilder.addPrompt(request3.prompt);
                }
                if (request3.domainHint) {
                  parameterBuilder.addDomainHint(request3.domainHint);
                }
                if (request3.prompt !== PromptValue.SELECT_ACCOUNT) {
                  if (request3.sid && request3.prompt === PromptValue.NONE) {
                    this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
                    parameterBuilder.addSid(request3.sid);
                  } else if (request3.account) {
                    accountSid = this.extractAccountSid(request3.account);
                    accountLoginHintClaim = this.extractLoginHint(request3.account);
                    if (accountLoginHintClaim) {
                      this.logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
                      parameterBuilder.addLoginHint(accountLoginHintClaim);
                      try {
                        clientInfo = buildClientInfoFromHomeAccountId(request3.account.homeAccountId);
                        parameterBuilder.addCcsOid(clientInfo);
                      } catch (e) {
                        this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                      }
                    } else if (accountSid && request3.prompt === PromptValue.NONE) {
                      this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
                      parameterBuilder.addSid(accountSid);
                      try {
                        clientInfo = buildClientInfoFromHomeAccountId(request3.account.homeAccountId);
                        parameterBuilder.addCcsOid(clientInfo);
                      } catch (e) {
                        this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                      }
                    } else if (request3.loginHint) {
                      this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
                      parameterBuilder.addLoginHint(request3.loginHint);
                      parameterBuilder.addCcsUpn(request3.loginHint);
                    } else if (request3.account.username) {
                      this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
                      parameterBuilder.addLoginHint(request3.account.username);
                      try {
                        clientInfo = buildClientInfoFromHomeAccountId(request3.account.homeAccountId);
                        parameterBuilder.addCcsOid(clientInfo);
                      } catch (e) {
                        this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                      }
                    }
                  } else if (request3.loginHint) {
                    this.logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
                    parameterBuilder.addLoginHint(request3.loginHint);
                    parameterBuilder.addCcsUpn(request3.loginHint);
                  }
                } else {
                  this.logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
                }
                if (request3.nonce) {
                  parameterBuilder.addNonce(request3.nonce);
                }
                if (request3.state) {
                  parameterBuilder.addState(request3.state);
                }
                if (!StringUtils.isEmpty(request3.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                  parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
                }
                if (request3.extraQueryParameters) {
                  parameterBuilder.addExtraQueryParameters(request3.extraQueryParameters);
                }
                if (!request3.nativeBroker)
                  return [3, 2];
                parameterBuilder.addNativeBroker();
                if (!(request3.authenticationScheme === AuthenticationScheme.POP))
                  return [3, 2];
                popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
                return [4, popTokenGenerator.generateCnf(request3)];
              case 1:
                reqCnfData = _a2.sent();
                parameterBuilder.addPopToken(reqCnfData.reqCnfHash);
                _a2.label = 2;
              case 2:
                return [2, parameterBuilder.createQueryString()];
            }
          });
        });
      };
      AuthorizationCodeClient2.prototype.createLogoutUrlQueryString = function(request3) {
        var parameterBuilder = new RequestParameterBuilder();
        if (request3.postLogoutRedirectUri) {
          parameterBuilder.addPostLogoutRedirectUri(request3.postLogoutRedirectUri);
        }
        if (request3.correlationId) {
          parameterBuilder.addCorrelationId(request3.correlationId);
        }
        if (request3.idTokenHint) {
          parameterBuilder.addIdTokenHint(request3.idTokenHint);
        }
        if (request3.state) {
          parameterBuilder.addState(request3.state);
        }
        if (request3.logoutHint) {
          parameterBuilder.addLogoutHint(request3.logoutHint);
        }
        if (request3.extraQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request3.extraQueryParameters);
        }
        return parameterBuilder.createQueryString();
      };
      AuthorizationCodeClient2.prototype.extractAccountSid = function(account) {
        var _a2;
        return ((_a2 = account.idTokenClaims) === null || _a2 === void 0 ? void 0 : _a2.sid) || null;
      };
      AuthorizationCodeClient2.prototype.extractLoginHint = function(account) {
        var _a2;
        return ((_a2 = account.idTokenClaims) === null || _a2 === void 0 ? void 0 : _a2.login_hint) || null;
      };
      return AuthorizationCodeClient2;
    }(BaseClient);
  }
});
var DeviceCodeClient;
var init_DeviceCodeClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/client/DeviceCodeClient.js"() {
    "use strict";
    init_tslib();
    init_BaseClient();
    init_ClientAuthError();
    init_RequestParameterBuilder();
    init_Constants();
    init_TimeUtils();
    init_ResponseHandler();
    init_StringUtils();
    init_ServerError();
    DeviceCodeClient = /** @class */
    function(_super) {
      __extends(DeviceCodeClient2, _super);
      function DeviceCodeClient2(configuration) {
        return _super.call(this, configuration) || this;
      }
      DeviceCodeClient2.prototype.acquireToken = function(request3) {
        return __awaiter(this, void 0, void 0, function() {
          var deviceCodeResponse, reqTimestamp, response, responseHandler;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.getDeviceCode(request3)];
              case 1:
                deviceCodeResponse = _a2.sent();
                request3.deviceCodeCallback(deviceCodeResponse);
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.acquireTokenWithDeviceCode(request3, deviceCodeResponse)];
              case 2:
                response = _a2.sent();
                responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                responseHandler.validateTokenResponse(response);
                return [4, responseHandler.handleServerTokenResponse(response, this.authority, reqTimestamp, request3)];
              case 3:
                return [2, _a2.sent()];
            }
          });
        });
      };
      DeviceCodeClient2.prototype.getDeviceCode = function(request3) {
        return __awaiter(this, void 0, void 0, function() {
          var queryString, headers, thumbprint;
          return __generator(this, function(_a2) {
            queryString = this.createQueryString(request3);
            headers = this.createTokenRequestHeaders();
            thumbprint = {
              clientId: this.config.authOptions.clientId,
              authority: request3.authority,
              scopes: request3.scopes,
              claims: request3.claims,
              authenticationScheme: request3.authenticationScheme,
              resourceRequestMethod: request3.resourceRequestMethod,
              resourceRequestUri: request3.resourceRequestUri,
              shrClaims: request3.shrClaims,
              sshKid: request3.sshKid
            };
            return [2, this.executePostRequestToDeviceCodeEndpoint(this.authority.deviceCodeEndpoint, queryString, headers, thumbprint)];
          });
        });
      };
      DeviceCodeClient2.prototype.executePostRequestToDeviceCodeEndpoint = function(deviceCodeEndpoint, queryString, headers, thumbprint) {
        return __awaiter(this, void 0, void 0, function() {
          var _a2, userCode, deviceCode, verificationUri, expiresIn, interval, message;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.networkManager.sendPostRequest(thumbprint, deviceCodeEndpoint, {
                  body: queryString,
                  headers,
                  proxyUrl: this.config.systemOptions.proxyUrl
                })];
              case 1:
                _a2 = _b.sent().body, userCode = _a2.user_code, deviceCode = _a2.device_code, verificationUri = _a2.verification_uri, expiresIn = _a2.expires_in, interval = _a2.interval, message = _a2.message;
                return [2, {
                  userCode,
                  deviceCode,
                  verificationUri,
                  expiresIn,
                  interval,
                  message
                }];
            }
          });
        });
      };
      DeviceCodeClient2.prototype.createQueryString = function(request3) {
        var parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addScopes(request3.scopes);
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        if (!StringUtils.isEmpty(request3.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
        }
        return parameterBuilder.createQueryString();
      };
      DeviceCodeClient2.prototype.continuePolling = function(deviceCodeExpirationTime, userSpecifiedTimeout, userSpecifiedCancelFlag) {
        if (userSpecifiedCancelFlag) {
          this.logger.error("Token request cancelled by setting DeviceCodeRequest.cancel = true");
          throw ClientAuthError.createDeviceCodeCancelledError();
        } else if (userSpecifiedTimeout && userSpecifiedTimeout < deviceCodeExpirationTime && TimeUtils.nowSeconds() > userSpecifiedTimeout) {
          this.logger.error("User defined timeout for device code polling reached. The timeout was set for " + userSpecifiedTimeout);
          throw ClientAuthError.createUserTimeoutReachedError();
        } else if (TimeUtils.nowSeconds() > deviceCodeExpirationTime) {
          if (userSpecifiedTimeout) {
            this.logger.verbose("User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for " + userSpecifiedTimeout);
          }
          this.logger.error("Device code expired. Expiration time of device code was " + deviceCodeExpirationTime);
          throw ClientAuthError.createDeviceCodeExpiredError();
        }
        return true;
      };
      DeviceCodeClient2.prototype.acquireTokenWithDeviceCode = function(request3, deviceCodeResponse) {
        return __awaiter(this, void 0, void 0, function() {
          var requestBody, headers, userSpecifiedTimeout, deviceCodeExpirationTime, pollingIntervalMilli, thumbprint, response;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                requestBody = this.createTokenRequestBody(request3, deviceCodeResponse);
                headers = this.createTokenRequestHeaders();
                userSpecifiedTimeout = request3.timeout ? TimeUtils.nowSeconds() + request3.timeout : void 0;
                deviceCodeExpirationTime = TimeUtils.nowSeconds() + deviceCodeResponse.expiresIn;
                pollingIntervalMilli = deviceCodeResponse.interval * 1e3;
                _a2.label = 1;
              case 1:
                if (!this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request3.cancel))
                  return [3, 8];
                thumbprint = {
                  clientId: this.config.authOptions.clientId,
                  authority: request3.authority,
                  scopes: request3.scopes,
                  claims: request3.claims,
                  authenticationScheme: request3.authenticationScheme,
                  resourceRequestMethod: request3.resourceRequestMethod,
                  resourceRequestUri: request3.resourceRequestUri,
                  shrClaims: request3.shrClaims,
                  sshKid: request3.sshKid
                };
                return [4, this.executePostToTokenEndpoint(this.authority.tokenEndpoint, requestBody, headers, thumbprint)];
              case 2:
                response = _a2.sent();
                if (!(response.body && response.body.error))
                  return [3, 6];
                if (!(response.body.error === Constants.AUTHORIZATION_PENDING))
                  return [3, 4];
                this.logger.info("Authorization pending. Continue polling.");
                return [4, TimeUtils.delay(pollingIntervalMilli)];
              case 3:
                _a2.sent();
                return [3, 5];
              case 4:
                this.logger.info("Unexpected error in polling from the server");
                throw ServerError.createPostRequestFailed(response.body.error);
              case 5:
                return [3, 7];
              case 6:
                this.logger.verbose("Authorization completed successfully. Polling stopped.");
                return [2, response.body];
              case 7:
                return [3, 1];
              case 8:
                this.logger.error("Polling stopped for unknown reasons.");
                throw ClientAuthError.createDeviceCodeUnknownError();
            }
          });
        });
      };
      DeviceCodeClient2.prototype.createTokenRequestBody = function(request3, deviceCodeResponse) {
        var requestParameters = new RequestParameterBuilder();
        requestParameters.addScopes(request3.scopes);
        requestParameters.addClientId(this.config.authOptions.clientId);
        requestParameters.addGrantType(GrantType.DEVICE_CODE_GRANT);
        requestParameters.addDeviceCode(deviceCodeResponse.deviceCode);
        var correlationId = request3.correlationId || this.config.cryptoInterface.createNewGuid();
        requestParameters.addCorrelationId(correlationId);
        requestParameters.addClientInfo();
        requestParameters.addLibraryInfo(this.config.libraryInfo);
        requestParameters.addApplicationTelemetry(this.config.telemetry.application);
        requestParameters.addThrottling();
        if (this.serverTelemetryManager) {
          requestParameters.addServerTelemetry(this.serverTelemetryManager);
        }
        if (!StringUtils.isEmptyObj(request3.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          requestParameters.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
        }
        return requestParameters.createQueryString();
      };
      return DeviceCodeClient2;
    }(BaseClient);
  }
});
var PerformanceEvents, PerformanceEventStatus;
var init_PerformanceEvent = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.js"() {
    "use strict";
    (function(PerformanceEvents2) {
      PerformanceEvents2["AcquireTokenByCode"] = "acquireTokenByCode";
      PerformanceEvents2["AcquireTokenByRefreshToken"] = "acquireTokenByRefreshToken";
      PerformanceEvents2["AcquireTokenSilent"] = "acquireTokenSilent";
      PerformanceEvents2["AcquireTokenSilentAsync"] = "acquireTokenSilentAsync";
      PerformanceEvents2["AcquireTokenPopup"] = "acquireTokenPopup";
      PerformanceEvents2["CryptoOptsGetPublicKeyThumbprint"] = "cryptoOptsGetPublicKeyThumbprint";
      PerformanceEvents2["CryptoOptsSignJwt"] = "cryptoOptsSignJwt";
      PerformanceEvents2["SilentCacheClientAcquireToken"] = "silentCacheClientAcquireToken";
      PerformanceEvents2["SilentIframeClientAcquireToken"] = "silentIframeClientAcquireToken";
      PerformanceEvents2["SilentRefreshClientAcquireToken"] = "silentRefreshClientAcquireToken";
      PerformanceEvents2["SsoSilent"] = "ssoSilent";
      PerformanceEvents2["StandardInteractionClientGetDiscoveredAuthority"] = "standardInteractionClientGetDiscoveredAuthority";
      PerformanceEvents2["FetchAccountIdWithNativeBroker"] = "fetchAccountIdWithNativeBroker";
      PerformanceEvents2["NativeInteractionClientAcquireToken"] = "nativeInteractionClientAcquireToken";
      PerformanceEvents2["BaseClientCreateTokenRequestHeaders"] = "baseClientCreateTokenRequestHeaders";
      PerformanceEvents2["BrokerHandhshake"] = "brokerHandshake";
      PerformanceEvents2["AcquireTokenByRefreshTokenInBroker"] = "acquireTokenByRefreshTokenInBroker";
      PerformanceEvents2["AcquireTokenByBroker"] = "acquireTokenByBroker";
      PerformanceEvents2["RefreshTokenClientExecuteTokenRequest"] = "refreshTokenClientExecuteTokenRequest";
      PerformanceEvents2["RefreshTokenClientAcquireToken"] = "refreshTokenClientAcquireToken";
      PerformanceEvents2["RefreshTokenClientAcquireTokenWithCachedRefreshToken"] = "refreshTokenClientAcquireTokenWithCachedRefreshToken";
    })(PerformanceEvents || (PerformanceEvents = {}));
    (function(PerformanceEventStatus2) {
      PerformanceEventStatus2[PerformanceEventStatus2["NotStarted"] = 0] = "NotStarted";
      PerformanceEventStatus2[PerformanceEventStatus2["InProgress"] = 1] = "InProgress";
      PerformanceEventStatus2[PerformanceEventStatus2["Completed"] = 2] = "Completed";
    })(PerformanceEventStatus || (PerformanceEventStatus = {}));
  }
});
var RefreshTokenClient;
var init_RefreshTokenClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/client/RefreshTokenClient.js"() {
    "use strict";
    init_tslib();
    init_BaseClient();
    init_RequestParameterBuilder();
    init_Constants();
    init_ResponseHandler();
    init_PopTokenGenerator();
    init_StringUtils();
    init_ClientConfigurationError();
    init_ClientAuthError();
    init_ServerError();
    init_TimeUtils();
    init_UrlString();
    init_CcsCredential();
    init_ClientInfo();
    init_InteractionRequiredAuthError();
    init_PerformanceEvent();
    RefreshTokenClient = /** @class */
    function(_super) {
      __extends(RefreshTokenClient2, _super);
      function RefreshTokenClient2(configuration, performanceClient) {
        return _super.call(this, configuration, performanceClient) || this;
      }
      RefreshTokenClient2.prototype.acquireToken = function(request3) {
        var _a2, _b;
        return __awaiter(this, void 0, void 0, function() {
          var atsMeasurement, reqTimestamp, response, requestId, responseHandler;
          var _this = this;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                atsMeasurement = (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.startMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request3.correlationId);
                this.logger.verbose("RefreshTokenClientAcquireToken called", request3.correlationId);
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.executeTokenRequest(request3, this.authority)];
              case 1:
                response = _c.sent();
                requestId = (_b = response.headers) === null || _b === void 0 ? void 0 : _b[HeaderNames.X_MS_REQUEST_ID];
                responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                responseHandler.validateTokenResponse(response.body);
                return [2, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request3, void 0, void 0, true, request3.forceCache, requestId).then(function(result) {
                  var _a3;
                  atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
                    success: true,
                    refreshTokenSize: ((_a3 = response.body.refresh_token) === null || _a3 === void 0 ? void 0 : _a3.length) || 0
                  });
                  return result;
                }).catch(function(error) {
                  _this.logger.verbose("Error in fetching refresh token", request3.correlationId);
                  atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
                    errorCode: error.errorCode,
                    subErrorCode: error.subError,
                    success: false,
                    refreshTokenSize: void 0
                  });
                  throw error;
                })];
            }
          });
        });
      };
      RefreshTokenClient2.prototype.acquireTokenByRefreshToken = function(request3) {
        return __awaiter(this, void 0, void 0, function() {
          var isFOCI, noFamilyRTInCache, clientMismatchErrorWithFamilyRT;
          return __generator(this, function(_a2) {
            if (!request3) {
              throw ClientConfigurationError.createEmptyTokenRequestError();
            }
            if (!request3.account) {
              throw ClientAuthError.createNoAccountInSilentRequestError();
            }
            isFOCI = this.cacheManager.isAppMetadataFOCI(request3.account.environment, this.config.authOptions.clientId);
            if (isFOCI) {
              try {
                return [2, this.acquireTokenWithCachedRefreshToken(request3, true)];
              } catch (e) {
                noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === InteractionRequiredAuthErrorMessage.noTokensFoundError.code;
                clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
                if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
                  return [2, this.acquireTokenWithCachedRefreshToken(request3, false)];
                } else {
                  throw e;
                }
              }
            }
            return [2, this.acquireTokenWithCachedRefreshToken(request3, false)];
          });
        });
      };
      RefreshTokenClient2.prototype.acquireTokenWithCachedRefreshToken = function(request3, foci) {
        var _a2;
        return __awaiter(this, void 0, void 0, function() {
          var atsMeasurement, refreshToken, refreshTokenRequest;
          return __generator(this, function(_b) {
            atsMeasurement = (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.startMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request3.correlationId);
            this.logger.verbose("RefreshTokenClientAcquireTokenWithCachedRefreshToken called", request3.correlationId);
            refreshToken = this.cacheManager.readRefreshTokenFromCache(this.config.authOptions.clientId, request3.account, foci);
            if (!refreshToken) {
              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.discardMeasurement();
              throw InteractionRequiredAuthError.createNoTokensFoundError();
            }
            atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
              success: true
            });
            refreshTokenRequest = __assign(__assign({}, request3), { refreshToken: refreshToken.secret, authenticationScheme: request3.authenticationScheme || AuthenticationScheme.BEARER, ccsCredential: {
              credential: request3.account.homeAccountId,
              type: CcsCredentialType.HOME_ACCOUNT_ID
            } });
            return [2, this.acquireToken(refreshTokenRequest)];
          });
        });
      };
      RefreshTokenClient2.prototype.executeTokenRequest = function(request3, authority) {
        var _a2;
        return __awaiter(this, void 0, void 0, function() {
          var acquireTokenMeasurement, requestBody, queryParameters, headers, thumbprint, endpoint;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                acquireTokenMeasurement = (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.startMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request3.correlationId);
                return [4, this.createTokenRequestBody(request3)];
              case 1:
                requestBody = _b.sent();
                queryParameters = this.createTokenQueryParameters(request3);
                headers = this.createTokenRequestHeaders(request3.ccsCredential);
                thumbprint = {
                  clientId: this.config.authOptions.clientId,
                  authority: authority.canonicalAuthority,
                  scopes: request3.scopes,
                  claims: request3.claims,
                  authenticationScheme: request3.authenticationScheme,
                  resourceRequestMethod: request3.resourceRequestMethod,
                  resourceRequestUri: request3.resourceRequestUri,
                  shrClaims: request3.shrClaims,
                  sshKid: request3.sshKid
                };
                endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParameters);
                return [2, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint).then(function(result) {
                  acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                    success: true
                  });
                  return result;
                }).catch(function(error) {
                  acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                    success: false
                  });
                  throw error;
                })];
            }
          });
        });
      };
      RefreshTokenClient2.prototype.createTokenQueryParameters = function(request3) {
        var parameterBuilder = new RequestParameterBuilder();
        if (request3.tokenQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request3.tokenQueryParameters);
        }
        return parameterBuilder.createQueryString();
      };
      RefreshTokenClient2.prototype.createTokenRequestBody = function(request3) {
        var _a2;
        return __awaiter(this, void 0, void 0, function() {
          var correlationId, acquireTokenMeasurement, parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, clientInfo;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                correlationId = request3.correlationId;
                acquireTokenMeasurement = (_a2 = this.performanceClient) === null || _a2 === void 0 ? void 0 : _a2.startMeasurement(PerformanceEvents.BaseClientCreateTokenRequestHeaders, correlationId);
                parameterBuilder = new RequestParameterBuilder();
                parameterBuilder.addClientId(this.config.authOptions.clientId);
                parameterBuilder.addScopes(request3.scopes);
                parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);
                parameterBuilder.addClientInfo();
                parameterBuilder.addLibraryInfo(this.config.libraryInfo);
                parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
                parameterBuilder.addThrottling();
                if (this.serverTelemetryManager) {
                  parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
                }
                parameterBuilder.addCorrelationId(correlationId);
                parameterBuilder.addRefreshToken(request3.refreshToken);
                if (this.config.clientCredentials.clientSecret) {
                  parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
                }
                if (this.config.clientCredentials.clientAssertion) {
                  clientAssertion = this.config.clientCredentials.clientAssertion;
                  parameterBuilder.addClientAssertion(clientAssertion.assertion);
                  parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
                }
                if (!(request3.authenticationScheme === AuthenticationScheme.POP))
                  return [3, 2];
                popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
                return [4, popTokenGenerator.generateCnf(request3)];
              case 1:
                reqCnfData = _b.sent();
                parameterBuilder.addPopToken(reqCnfData.reqCnfString);
                return [3, 3];
              case 2:
                if (request3.authenticationScheme === AuthenticationScheme.SSH) {
                  if (request3.sshJwk) {
                    parameterBuilder.addSshJwk(request3.sshJwk);
                  } else {
                    acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                      success: false
                    });
                    throw ClientConfigurationError.createMissingSshJwkError();
                  }
                }
                _b.label = 3;
              case 3:
                if (!StringUtils.isEmptyObj(request3.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                  parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
                }
                if (this.config.systemOptions.preventCorsPreflight && request3.ccsCredential) {
                  switch (request3.ccsCredential.type) {
                    case CcsCredentialType.HOME_ACCOUNT_ID:
                      try {
                        clientInfo = buildClientInfoFromHomeAccountId(request3.ccsCredential.credential);
                        parameterBuilder.addCcsOid(clientInfo);
                      } catch (e) {
                        this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                      }
                      break;
                    case CcsCredentialType.UPN:
                      parameterBuilder.addCcsUpn(request3.ccsCredential.credential);
                      break;
                  }
                }
                acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                  success: true
                });
                return [2, parameterBuilder.createQueryString()];
            }
          });
        });
      };
      return RefreshTokenClient2;
    }(BaseClient);
  }
});
var ClientCredentialClient;
var init_ClientCredentialClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/client/ClientCredentialClient.js"() {
    "use strict";
    init_tslib();
    init_BaseClient();
    init_RequestParameterBuilder();
    init_ScopeSet();
    init_Constants();
    init_ResponseHandler();
    init_TimeUtils();
    init_StringUtils();
    init_ClientAuthError();
    ClientCredentialClient = /** @class */
    function(_super) {
      __extends(ClientCredentialClient2, _super);
      function ClientCredentialClient2(configuration, appTokenProvider) {
        var _this = _super.call(this, configuration) || this;
        _this.appTokenProvider = appTokenProvider;
        return _this;
      }
      ClientCredentialClient2.prototype.acquireToken = function(request3) {
        return __awaiter(this, void 0, void 0, function() {
          var cachedAuthenticationResult;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.scopeSet = new ScopeSet(request3.scopes || []);
                if (!request3.skipCache)
                  return [3, 2];
                return [4, this.executeTokenRequest(request3, this.authority)];
              case 1:
                return [2, _a2.sent()];
              case 2:
                return [4, this.getCachedAuthenticationResult(request3)];
              case 3:
                cachedAuthenticationResult = _a2.sent();
                if (!cachedAuthenticationResult)
                  return [3, 4];
                return [2, cachedAuthenticationResult];
              case 4:
                return [4, this.executeTokenRequest(request3, this.authority)];
              case 5:
                return [2, _a2.sent()];
            }
          });
        });
      };
      ClientCredentialClient2.prototype.getCachedAuthenticationResult = function(request3) {
        var _a2, _b;
        return __awaiter(this, void 0, void 0, function() {
          var cachedAccessToken;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                cachedAccessToken = this.readAccessTokenFromCache();
                if (!cachedAccessToken) {
                  (_a2 = this.serverTelemetryManager) === null || _a2 === void 0 ? void 0 : _a2.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                  return [2, null];
                }
                if (TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                  (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                  return [2, null];
                }
                return [4, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {
                  account: null,
                  idToken: null,
                  accessToken: cachedAccessToken,
                  refreshToken: null,
                  appMetadata: null
                }, true, request3)];
              case 1:
                return [2, _c.sent()];
            }
          });
        });
      };
      ClientCredentialClient2.prototype.readAccessTokenFromCache = function() {
        var accessTokenFilter = {
          homeAccountId: Constants.EMPTY_STRING,
          environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,
          credentialType: CredentialType.ACCESS_TOKEN,
          clientId: this.config.authOptions.clientId,
          realm: this.authority.tenant,
          target: this.scopeSet.printScopesLowerCase()
        };
        var credentialCache = this.cacheManager.getCredentialsFilteredBy(accessTokenFilter);
        var accessTokens = Object.keys(credentialCache.accessTokens).map(function(key) {
          return credentialCache.accessTokens[key];
        });
        if (accessTokens.length < 1) {
          return null;
        } else if (accessTokens.length > 1) {
          throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return accessTokens[0];
      };
      ClientCredentialClient2.prototype.executeTokenRequest = function(request3, authority) {
        return __awaiter(this, void 0, void 0, function() {
          var serverTokenResponse, reqTimestamp, appTokenPropviderParameters, appTokenProviderResult, requestBody, headers, thumbprint, response, responseHandler, tokenResponse;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!this.appTokenProvider)
                  return [3, 2];
                this.logger.info("Using appTokenProvider extensibility.");
                appTokenPropviderParameters = {
                  correlationId: request3.correlationId,
                  tenantId: this.config.authOptions.authority.tenant,
                  scopes: request3.scopes,
                  claims: request3.claims
                };
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.appTokenProvider(appTokenPropviderParameters)];
              case 1:
                appTokenProviderResult = _a2.sent();
                serverTokenResponse = {
                  access_token: appTokenProviderResult.accessToken,
                  expires_in: appTokenProviderResult.expiresInSeconds,
                  refresh_in: appTokenProviderResult.refreshInSeconds,
                  token_type: AuthenticationScheme.BEARER
                };
                return [3, 4];
              case 2:
                requestBody = this.createTokenRequestBody(request3);
                headers = this.createTokenRequestHeaders();
                thumbprint = {
                  clientId: this.config.authOptions.clientId,
                  authority: request3.authority,
                  scopes: request3.scopes,
                  claims: request3.claims,
                  authenticationScheme: request3.authenticationScheme,
                  resourceRequestMethod: request3.resourceRequestMethod,
                  resourceRequestUri: request3.resourceRequestUri,
                  shrClaims: request3.shrClaims,
                  sshKid: request3.sshKid
                };
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers, thumbprint)];
              case 3:
                response = _a2.sent();
                serverTokenResponse = response.body;
                _a2.label = 4;
              case 4:
                responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                responseHandler.validateTokenResponse(serverTokenResponse);
                return [4, responseHandler.handleServerTokenResponse(serverTokenResponse, this.authority, reqTimestamp, request3)];
              case 5:
                tokenResponse = _a2.sent();
                return [2, tokenResponse];
            }
          });
        });
      };
      ClientCredentialClient2.prototype.createTokenRequestBody = function(request3) {
        var parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        parameterBuilder.addScopes(request3.scopes, false);
        parameterBuilder.addGrantType(GrantType.CLIENT_CREDENTIALS_GRANT);
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager) {
          parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        var correlationId = request3.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        if (this.config.clientCredentials.clientSecret) {
          parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        var clientAssertion = request3.clientAssertion || this.config.clientCredentials.clientAssertion;
        if (clientAssertion) {
          parameterBuilder.addClientAssertion(clientAssertion.assertion);
          parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        if (!StringUtils.isEmptyObj(request3.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
        }
        return parameterBuilder.createQueryString();
      };
      return ClientCredentialClient2;
    }(BaseClient);
  }
});
var OnBehalfOfClient;
var init_OnBehalfOfClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/client/OnBehalfOfClient.js"() {
    "use strict";
    init_tslib();
    init_BaseClient();
    init_RequestParameterBuilder();
    init_ScopeSet();
    init_Constants();
    init_ResponseHandler();
    init_TimeUtils();
    init_AuthToken();
    init_ClientAuthError();
    OnBehalfOfClient = /** @class */
    function(_super) {
      __extends(OnBehalfOfClient2, _super);
      function OnBehalfOfClient2(configuration) {
        return _super.call(this, configuration) || this;
      }
      OnBehalfOfClient2.prototype.acquireToken = function(request3) {
        return __awaiter(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                this.scopeSet = new ScopeSet(request3.scopes || []);
                _a2 = this;
                return [4, this.cryptoUtils.hashString(request3.oboAssertion)];
              case 1:
                _a2.userAssertionHash = _b.sent();
                if (!request3.skipCache)
                  return [3, 3];
                return [4, this.executeTokenRequest(request3, this.authority, this.userAssertionHash)];
              case 2:
                return [2, _b.sent()];
              case 3:
                _b.trys.push([3, 5, , 7]);
                return [4, this.getCachedAuthenticationResult(request3)];
              case 4:
                return [2, _b.sent()];
              case 5:
                _b.sent();
                return [4, this.executeTokenRequest(request3, this.authority, this.userAssertionHash)];
              case 6:
                return [2, _b.sent()];
              case 7:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      OnBehalfOfClient2.prototype.getCachedAuthenticationResult = function(request3) {
        var _a2, _b;
        return __awaiter(this, void 0, void 0, function() {
          var cachedAccessToken, cachedIdToken, idTokenObject, cachedAccount, localAccountId, accountInfo;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request3);
                if (!cachedAccessToken) {
                  (_a2 = this.serverTelemetryManager) === null || _a2 === void 0 ? void 0 : _a2.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                  this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
                  throw ClientAuthError.createRefreshRequiredError();
                } else if (TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                  (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                  this.logger.info("OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds.");
                  throw ClientAuthError.createRefreshRequiredError();
                }
                cachedIdToken = this.readIdTokenFromCacheForOBO(request3, cachedAccessToken.homeAccountId);
                cachedAccount = null;
                if (cachedIdToken) {
                  idTokenObject = new AuthToken(cachedIdToken.secret, this.config.cryptoInterface);
                  localAccountId = idTokenObject.claims.oid ? idTokenObject.claims.oid : idTokenObject.claims.sub;
                  accountInfo = {
                    homeAccountId: cachedIdToken.homeAccountId,
                    environment: cachedIdToken.environment,
                    tenantId: cachedIdToken.realm,
                    username: Constants.EMPTY_STRING,
                    localAccountId: localAccountId || Constants.EMPTY_STRING
                  };
                  cachedAccount = this.cacheManager.readAccountFromCache(accountInfo);
                }
                if (this.config.serverTelemetryManager) {
                  this.config.serverTelemetryManager.incrementCacheHits();
                }
                return [4, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {
                  account: cachedAccount,
                  accessToken: cachedAccessToken,
                  idToken: cachedIdToken,
                  refreshToken: null,
                  appMetadata: null
                }, true, request3, idTokenObject)];
              case 1:
                return [2, _c.sent()];
            }
          });
        });
      };
      OnBehalfOfClient2.prototype.readIdTokenFromCacheForOBO = function(request3, atHomeAccountId) {
        var idTokenFilter = {
          homeAccountId: atHomeAccountId,
          environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,
          credentialType: CredentialType.ID_TOKEN,
          clientId: this.config.authOptions.clientId,
          realm: this.authority.tenant
        };
        var credentialCache = this.cacheManager.getCredentialsFilteredBy(idTokenFilter);
        var idTokens = Object.keys(credentialCache.idTokens).map(function(key) {
          return credentialCache.idTokens[key];
        });
        if (idTokens.length < 1) {
          return null;
        }
        return idTokens[0];
      };
      OnBehalfOfClient2.prototype.readAccessTokenFromCacheForOBO = function(clientId, request3) {
        var authScheme = request3.authenticationScheme || AuthenticationScheme.BEARER;
        var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
        var accessTokenFilter = {
          credentialType,
          clientId,
          target: this.scopeSet.printScopesLowerCase(),
          tokenType: authScheme,
          keyId: request3.sshKid,
          requestedClaimsHash: request3.requestedClaimsHash,
          userAssertionHash: this.userAssertionHash
        };
        var credentialCache = this.cacheManager.getCredentialsFilteredBy(accessTokenFilter);
        var accessTokens = Object.keys(credentialCache.accessTokens).map(function(key) {
          return credentialCache.accessTokens[key];
        });
        var numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          return null;
        } else if (numAccessTokens > 1) {
          throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return accessTokens[0];
      };
      OnBehalfOfClient2.prototype.executeTokenRequest = function(request3, authority, userAssertionHash) {
        return __awaiter(this, void 0, void 0, function() {
          var requestBody, headers, thumbprint, reqTimestamp, response, responseHandler, tokenResponse;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                requestBody = this.createTokenRequestBody(request3);
                headers = this.createTokenRequestHeaders();
                thumbprint = {
                  clientId: this.config.authOptions.clientId,
                  authority: request3.authority,
                  scopes: request3.scopes,
                  claims: request3.claims,
                  authenticationScheme: request3.authenticationScheme,
                  resourceRequestMethod: request3.resourceRequestMethod,
                  resourceRequestUri: request3.resourceRequestUri,
                  shrClaims: request3.shrClaims,
                  sshKid: request3.sshKid
                };
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers, thumbprint)];
              case 1:
                response = _a2.sent();
                responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                responseHandler.validateTokenResponse(response.body);
                return [4, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request3, void 0, userAssertionHash)];
              case 2:
                tokenResponse = _a2.sent();
                return [2, tokenResponse];
            }
          });
        });
      };
      OnBehalfOfClient2.prototype.createTokenRequestBody = function(request3) {
        var parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        parameterBuilder.addScopes(request3.scopes);
        parameterBuilder.addGrantType(GrantType.JWT_BEARER);
        parameterBuilder.addClientInfo();
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager) {
          parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        var correlationId = request3.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        parameterBuilder.addRequestTokenUse(AADServerParamKeys.ON_BEHALF_OF);
        parameterBuilder.addOboAssertion(request3.oboAssertion);
        if (this.config.clientCredentials.clientSecret) {
          parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          var clientAssertion = this.config.clientCredentials.clientAssertion;
          parameterBuilder.addClientAssertion(clientAssertion.assertion);
          parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        return parameterBuilder.createQueryString();
      };
      return OnBehalfOfClient2;
    }(BaseClient);
  }
});
var SilentFlowClient;
var init_SilentFlowClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/client/SilentFlowClient.js"() {
    "use strict";
    init_tslib();
    init_BaseClient();
    init_AuthToken();
    init_TimeUtils();
    init_RefreshTokenClient();
    init_ClientAuthError();
    init_ClientConfigurationError();
    init_ResponseHandler();
    init_Constants();
    SilentFlowClient = /** @class */
    function(_super) {
      __extends(SilentFlowClient2, _super);
      function SilentFlowClient2(configuration, performanceClient) {
        return _super.call(this, configuration, performanceClient) || this;
      }
      SilentFlowClient2.prototype.acquireToken = function(request3) {
        return __awaiter(this, void 0, void 0, function() {
          var e_1, refreshTokenClient;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 2, , 3]);
                return [4, this.acquireCachedToken(request3)];
              case 1:
                return [2, _a2.sent()];
              case 2:
                e_1 = _a2.sent();
                if (e_1 instanceof ClientAuthError && e_1.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {
                  refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);
                  return [2, refreshTokenClient.acquireTokenByRefreshToken(request3)];
                } else {
                  throw e_1;
                }
              case 3:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      SilentFlowClient2.prototype.acquireCachedToken = function(request3) {
        var _a2, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function() {
          var environment, cacheRecord;
          return __generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                if (!request3) {
                  throw ClientConfigurationError.createEmptyTokenRequestError();
                }
                if (request3.forceRefresh) {
                  (_a2 = this.serverTelemetryManager) === null || _a2 === void 0 ? void 0 : _a2.setCacheOutcome(CacheOutcome.FORCE_REFRESH);
                  this.logger.info("SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.");
                  throw ClientAuthError.createRefreshRequiredError();
                }
                if (!request3.account) {
                  throw ClientAuthError.createNoAccountInSilentRequestError();
                }
                environment = request3.authority || this.authority.getPreferredCache();
                cacheRecord = this.cacheManager.readCacheRecord(request3.account, this.config.authOptions.clientId, request3, environment);
                if (!cacheRecord.accessToken) {
                  (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                  this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
                  throw ClientAuthError.createRefreshRequiredError();
                } else if (TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) || TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                  (_c = this.serverTelemetryManager) === null || _c === void 0 ? void 0 : _c.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                  this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds.");
                  throw ClientAuthError.createRefreshRequiredError();
                } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {
                  (_d = this.serverTelemetryManager) === null || _d === void 0 ? void 0 : _d.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);
                  this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.");
                  throw ClientAuthError.createRefreshRequiredError();
                }
                if (this.config.serverTelemetryManager) {
                  this.config.serverTelemetryManager.incrementCacheHits();
                }
                return [4, this.generateResultFromCacheRecord(cacheRecord, request3)];
              case 1:
                return [2, _e.sent()];
            }
          });
        });
      };
      SilentFlowClient2.prototype.generateResultFromCacheRecord = function(cacheRecord, request3) {
        return __awaiter(this, void 0, void 0, function() {
          var idTokenObj, authTime;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (cacheRecord.idToken) {
                  idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);
                }
                if (request3.maxAge || request3.maxAge === 0) {
                  authTime = idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.auth_time;
                  if (!authTime) {
                    throw ClientAuthError.createAuthTimeNotFoundError();
                  }
                  AuthToken.checkMaxAge(authTime, request3.maxAge);
                }
                return [4, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request3, idTokenObj)];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      return SilentFlowClient2;
    }(BaseClient);
  }
});
var UsernamePasswordClient;
var init_UsernamePasswordClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/client/UsernamePasswordClient.js"() {
    "use strict";
    init_tslib();
    init_BaseClient();
    init_ResponseHandler();
    init_RequestParameterBuilder();
    init_Constants();
    init_StringUtils();
    init_TimeUtils();
    init_CcsCredential();
    UsernamePasswordClient = /** @class */
    function(_super) {
      __extends(UsernamePasswordClient2, _super);
      function UsernamePasswordClient2(configuration) {
        return _super.call(this, configuration) || this;
      }
      UsernamePasswordClient2.prototype.acquireToken = function(request3) {
        return __awaiter(this, void 0, void 0, function() {
          var reqTimestamp, response, responseHandler, tokenResponse;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.logger.info("in acquireToken call");
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.executeTokenRequest(this.authority, request3)];
              case 1:
                response = _a2.sent();
                responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                responseHandler.validateTokenResponse(response.body);
                tokenResponse = responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request3);
                return [2, tokenResponse];
            }
          });
        });
      };
      UsernamePasswordClient2.prototype.executeTokenRequest = function(authority, request3) {
        return __awaiter(this, void 0, void 0, function() {
          var thumbprint, requestBody, headers;
          return __generator(this, function(_a2) {
            thumbprint = {
              clientId: this.config.authOptions.clientId,
              authority: authority.canonicalAuthority,
              scopes: request3.scopes,
              claims: request3.claims,
              authenticationScheme: request3.authenticationScheme,
              resourceRequestMethod: request3.resourceRequestMethod,
              resourceRequestUri: request3.resourceRequestUri,
              shrClaims: request3.shrClaims,
              sshKid: request3.sshKid
            };
            requestBody = this.createTokenRequestBody(request3);
            headers = this.createTokenRequestHeaders({
              credential: request3.username,
              type: CcsCredentialType.UPN
            });
            return [2, this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers, thumbprint)];
          });
        });
      };
      UsernamePasswordClient2.prototype.createTokenRequestBody = function(request3) {
        var parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        parameterBuilder.addUsername(request3.username);
        parameterBuilder.addPassword(request3.password);
        parameterBuilder.addScopes(request3.scopes);
        parameterBuilder.addResponseTypeForTokenAndIdToken();
        parameterBuilder.addGrantType(GrantType.RESOURCE_OWNER_PASSWORD_GRANT);
        parameterBuilder.addClientInfo();
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager) {
          parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        var correlationId = request3.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        if (this.config.clientCredentials.clientSecret) {
          parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          var clientAssertion = this.config.clientCredentials.clientAssertion;
          parameterBuilder.addClientAssertion(clientAssertion.assertion);
          parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        if (!StringUtils.isEmptyObj(request3.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request3.claims, this.config.authOptions.clientCapabilities);
        }
        if (this.config.systemOptions.preventCorsPreflight && request3.username) {
          parameterBuilder.addCcsUpn(request3.username);
        }
        return parameterBuilder.createQueryString();
      };
      return UsernamePasswordClient2;
    }(BaseClient);
  }
});
function isOpenIdConfigResponse(response) {
  return response.hasOwnProperty("authorization_endpoint") && response.hasOwnProperty("token_endpoint") && response.hasOwnProperty("issuer") && response.hasOwnProperty("jwks_uri");
}
var init_OpenIdConfigResponse = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.js"() {
    "use strict";
  }
});
var rawMetdataJSON, EndpointMetadata, InstanceDiscoveryMetadata;
var init_AuthorityMetadata = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.js"() {
    "use strict";
    rawMetdataJSON = { "endpointMetadata": { "https://login.microsoftonline.com/common/": { "token_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/common/": { "token_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/common/": { "token_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" }, "https://login.microsoftonline.com/consumers/": { "token_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/consumers/": { "token_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/consumers/": { "token_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" }, "https://login.microsoftonline.com/organizations/": { "token_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/organizations/": { "token_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/organizations/": { "token_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" } }, "instanceDiscoveryMetadata": { "https://login.microsoftonline.com/common/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/common/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/common/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.com/consumers/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/consumers/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/consumers/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.com/organizations/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/organizations/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/organizations/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] } } };
    EndpointMetadata = rawMetdataJSON.endpointMetadata;
    InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
  }
});
var ProtocolMode;
var init_ProtocolMode = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/authority/ProtocolMode.js"() {
    "use strict";
    (function(ProtocolMode2) {
      ProtocolMode2["AAD"] = "AAD";
      ProtocolMode2["OIDC"] = "OIDC";
    })(ProtocolMode || (ProtocolMode = {}));
  }
});
var AuthorityMetadataEntity;
var init_AuthorityMetadataEntity = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/cache/entities/AuthorityMetadataEntity.js"() {
    "use strict";
    init_Constants();
    init_TimeUtils();
    AuthorityMetadataEntity = /** @class */
    function() {
      function AuthorityMetadataEntity2() {
        this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
      }
      AuthorityMetadataEntity2.prototype.updateCloudDiscoveryMetadata = function(metadata, fromNetwork) {
        this.aliases = metadata.aliases;
        this.preferred_cache = metadata.preferred_cache;
        this.preferred_network = metadata.preferred_network;
        this.aliasesFromNetwork = fromNetwork;
      };
      AuthorityMetadataEntity2.prototype.updateEndpointMetadata = function(metadata, fromNetwork) {
        this.authorization_endpoint = metadata.authorization_endpoint;
        this.token_endpoint = metadata.token_endpoint;
        this.end_session_endpoint = metadata.end_session_endpoint;
        this.issuer = metadata.issuer;
        this.endpointsFromNetwork = fromNetwork;
        this.jwks_uri = metadata.jwks_uri;
      };
      AuthorityMetadataEntity2.prototype.updateCanonicalAuthority = function(authority) {
        this.canonical_authority = authority;
      };
      AuthorityMetadataEntity2.prototype.resetExpiresAt = function() {
        this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
      };
      AuthorityMetadataEntity2.prototype.isExpired = function() {
        return this.expiresAt <= TimeUtils.nowSeconds();
      };
      AuthorityMetadataEntity2.isAuthorityMetadataEntity = function(key, entity) {
        if (!entity) {
          return false;
        }
        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty("aliases") && entity.hasOwnProperty("preferred_cache") && entity.hasOwnProperty("preferred_network") && entity.hasOwnProperty("canonical_authority") && entity.hasOwnProperty("authorization_endpoint") && entity.hasOwnProperty("token_endpoint") && entity.hasOwnProperty("issuer") && entity.hasOwnProperty("aliasesFromNetwork") && entity.hasOwnProperty("endpointsFromNetwork") && entity.hasOwnProperty("expiresAt") && entity.hasOwnProperty("jwks_uri");
      };
      return AuthorityMetadataEntity2;
    }();
  }
});
function isCloudInstanceDiscoveryResponse(response) {
  return response.hasOwnProperty("tenant_discovery_endpoint") && response.hasOwnProperty("metadata");
}
var init_CloudInstanceDiscoveryResponse = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.js"() {
    "use strict";
  }
});
var RegionDiscovery;
var init_RegionDiscovery = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/authority/RegionDiscovery.js"() {
    "use strict";
    init_tslib();
    init_Constants();
    RegionDiscovery = /** @class */
    function() {
      function RegionDiscovery2(networkInterface) {
        this.networkInterface = networkInterface;
      }
      RegionDiscovery2.prototype.detectRegion = function(environmentRegion, regionDiscoveryMetadata, proxyUrl) {
        return __awaiter(this, void 0, void 0, function() {
          var autodetectedRegionName, options, localIMDSVersionResponse, currentIMDSVersion, currentIMDSVersionResponse;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                autodetectedRegionName = environmentRegion;
                if (!!autodetectedRegionName)
                  return [3, 8];
                options = RegionDiscovery2.IMDS_OPTIONS;
                if (proxyUrl) {
                  options.proxyUrl = proxyUrl;
                }
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 6, , 7]);
                return [4, this.getRegionFromIMDS(Constants.IMDS_VERSION, options)];
              case 2:
                localIMDSVersionResponse = _a2.sent();
                if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
                  autodetectedRegionName = localIMDSVersionResponse.body;
                  regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
                }
                if (!(localIMDSVersionResponse.status === ResponseCodes.httpBadRequest))
                  return [3, 5];
                return [4, this.getCurrentVersion(options)];
              case 3:
                currentIMDSVersion = _a2.sent();
                if (!currentIMDSVersion) {
                  regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                  return [2, null];
                }
                return [4, this.getRegionFromIMDS(currentIMDSVersion, options)];
              case 4:
                currentIMDSVersionResponse = _a2.sent();
                if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
                  autodetectedRegionName = currentIMDSVersionResponse.body;
                  regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
                }
                _a2.label = 5;
              case 5:
                return [3, 7];
              case 6:
                _a2.sent();
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                return [2, null];
              case 7:
                return [3, 9];
              case 8:
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
                _a2.label = 9;
              case 9:
                if (!autodetectedRegionName) {
                  regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                }
                return [2, autodetectedRegionName || null];
            }
          });
        });
      };
      RegionDiscovery2.prototype.getRegionFromIMDS = function(version3, options) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            return [2, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?api-version=" + version3 + "&format=text", options, Constants.IMDS_TIMEOUT)];
          });
        });
      };
      RegionDiscovery2.prototype.getCurrentVersion = function(options) {
        return __awaiter(this, void 0, void 0, function() {
          var response;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 2, , 3]);
                return [4, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?format=json", options)];
              case 1:
                response = _a2.sent();
                if (response.status === ResponseCodes.httpBadRequest && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
                  return [2, response.body["newest-versions"][0]];
                }
                return [2, null];
              case 2:
                _a2.sent();
                return [2, null];
              case 3:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      RegionDiscovery2.IMDS_OPTIONS = {
        headers: {
          Metadata: "true"
        }
      };
      return RegionDiscovery2;
    }();
  }
});
var Authority;
var init_Authority = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/authority/Authority.js"() {
    "use strict";
    init_tslib();
    init_AuthorityType();
    init_OpenIdConfigResponse();
    init_UrlString();
    init_ClientAuthError();
    init_Constants();
    init_AuthorityMetadata();
    init_ClientConfigurationError();
    init_ProtocolMode();
    init_AuthorityMetadataEntity();
    init_AuthorityOptions();
    init_CloudInstanceDiscoveryResponse();
    init_RegionDiscovery();
    Authority = /** @class */
    function() {
      function Authority2(authority, networkInterface, cacheManager, authorityOptions, proxyUrl) {
        this.canonicalAuthority = authority;
        this._canonicalAuthority.validateAsUri();
        this.networkInterface = networkInterface;
        this.cacheManager = cacheManager;
        this.authorityOptions = authorityOptions;
        this.regionDiscovery = new RegionDiscovery(networkInterface);
        this.regionDiscoveryMetadata = { region_used: void 0, region_source: void 0, region_outcome: void 0 };
        this.proxyUrl = proxyUrl || Constants.EMPTY_STRING;
      }
      Object.defineProperty(Authority2.prototype, "authorityType", {
        // See above for AuthorityType
        get: function() {
          var pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;
          if (pathSegments.length) {
            switch (pathSegments[0].toLowerCase()) {
              case Constants.ADFS:
                return AuthorityType.Adfs;
              case Constants.DSTS:
                return AuthorityType.Dsts;
            }
          }
          return AuthorityType.Default;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "protocolMode", {
        /**
         * ProtocolMode enum representing the way endpoints are constructed.
         */
        get: function() {
          return this.authorityOptions.protocolMode;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "options", {
        /**
         * Returns authorityOptions which can be used to reinstantiate a new authority instance
         */
        get: function() {
          return this.authorityOptions;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "canonicalAuthority", {
        /**
         * A URL that is the authority set by the developer
         */
        get: function() {
          return this._canonicalAuthority.urlString;
        },
        /**
         * Sets canonical authority.
         */
        set: function(url) {
          this._canonicalAuthority = new UrlString(url);
          this._canonicalAuthority.validateAsUri();
          this._canonicalAuthorityUrlComponents = null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "canonicalAuthorityUrlComponents", {
        /**
         * Get authority components.
         */
        get: function() {
          if (!this._canonicalAuthorityUrlComponents) {
            this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
          }
          return this._canonicalAuthorityUrlComponents;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "hostnameAndPort", {
        /**
         * Get hostname and port i.e. login.microsoftonline.com
         */
        get: function() {
          return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "tenant", {
        /**
         * Get tenant for authority.
         */
        get: function() {
          return this.canonicalAuthorityUrlComponents.PathSegments[0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "authorizationEndpoint", {
        /**
         * OAuth /authorize endpoint for requests
         */
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.authorization_endpoint);
            return this.replaceTenant(endpoint);
          } else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "tokenEndpoint", {
        /**
         * OAuth /token endpoint for requests
         */
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.token_endpoint);
            return this.replaceTenant(endpoint);
          } else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "deviceCodeEndpoint", {
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
            return this.replaceTenant(endpoint);
          } else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "endSessionEndpoint", {
        /**
         * OAuth logout endpoint for requests
         */
        get: function() {
          if (this.discoveryComplete()) {
            if (!this.metadata.end_session_endpoint) {
              throw ClientAuthError.createLogoutNotSupportedError();
            }
            var endpoint = this.replacePath(this.metadata.end_session_endpoint);
            return this.replaceTenant(endpoint);
          } else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "selfSignedJwtAudience", {
        /**
         * OAuth issuer for requests
         */
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.issuer);
            return this.replaceTenant(endpoint);
          } else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "jwksUri", {
        /**
         * Jwks_uri for token signing keys
         */
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.jwks_uri);
            return this.replaceTenant(endpoint);
          } else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        },
        enumerable: false,
        configurable: true
      });
      Authority2.prototype.replaceTenant = function(urlString) {
        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
      };
      Authority2.prototype.replacePath = function(urlString) {
        var endpoint = urlString;
        var cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
        var cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        var currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
        currentAuthorityParts.forEach(function(currentPart, index) {
          var cachedPart = cachedAuthorityParts[index];
          if (currentPart !== cachedPart) {
            endpoint = endpoint.replace("/" + cachedPart + "/", "/" + currentPart + "/");
          }
        });
        return endpoint;
      };
      Object.defineProperty(Authority2.prototype, "defaultOpenIdConfigurationEndpoint", {
        /**
         * The default open id configuration endpoint for any canonical authority.
         */
        get: function() {
          if (this.authorityType === AuthorityType.Adfs || this.authorityType === AuthorityType.Dsts || this.protocolMode === ProtocolMode.OIDC) {
            return this.canonicalAuthority + ".well-known/openid-configuration";
          }
          return this.canonicalAuthority + "v2.0/.well-known/openid-configuration";
        },
        enumerable: false,
        configurable: true
      });
      Authority2.prototype.discoveryComplete = function() {
        return !!this.metadata;
      };
      Authority2.prototype.resolveEndpointsAsync = function() {
        return __awaiter(this, void 0, void 0, function() {
          var metadataEntity, cloudDiscoverySource, endpointSource, cacheKey;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
                if (!metadataEntity) {
                  metadataEntity = new AuthorityMetadataEntity();
                  metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);
                }
                return [4, this.updateCloudDiscoveryMetadata(metadataEntity)];
              case 1:
                cloudDiscoverySource = _a2.sent();
                this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
                return [4, this.updateEndpointMetadata(metadataEntity)];
              case 2:
                endpointSource = _a2.sent();
                if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {
                  metadataEntity.resetExpiresAt();
                  metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);
                }
                cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
                this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
                this.metadata = metadataEntity;
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      Authority2.prototype.updateEndpointMetadata = function(metadataEntity) {
        var _a2, _b;
        return __awaiter(this, void 0, void 0, function() {
          var metadata, harcodedMetadata;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                metadata = this.getEndpointMetadataFromConfig();
                if (metadata) {
                  metadataEntity.updateEndpointMetadata(metadata, false);
                  return [2, AuthorityMetadataSource.CONFIG];
                }
                if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {
                  return [2, AuthorityMetadataSource.CACHE];
                }
                harcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
                return [4, this.getEndpointMetadataFromNetwork()];
              case 1:
                metadata = _c.sent();
                if (!metadata)
                  return [3, 4];
                if (!((_a2 = this.authorityOptions.azureRegionConfiguration) === null || _a2 === void 0 ? void 0 : _a2.azureRegion))
                  return [3, 3];
                return [4, this.updateMetadataWithRegionalInformation(metadata)];
              case 2:
                metadata = _c.sent();
                _c.label = 3;
              case 3:
                metadataEntity.updateEndpointMetadata(metadata, true);
                return [2, AuthorityMetadataSource.NETWORK];
              case 4:
                if (!(harcodedMetadata && !this.authorityOptions.skipAuthorityMetadataCache))
                  return [3, 7];
                if (!((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion))
                  return [3, 6];
                return [4, this.updateMetadataWithRegionalInformation(harcodedMetadata)];
              case 5:
                harcodedMetadata = _c.sent();
                _c.label = 6;
              case 6:
                metadataEntity.updateEndpointMetadata(harcodedMetadata, false);
                return [2, AuthorityMetadataSource.HARDCODED_VALUES];
              case 7:
                throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);
            }
          });
        });
      };
      Authority2.prototype.isAuthoritySameType = function(metadataEntity) {
        var cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
        var cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
      };
      Authority2.prototype.getEndpointMetadataFromConfig = function() {
        if (this.authorityOptions.authorityMetadata) {
          try {
            return JSON.parse(this.authorityOptions.authorityMetadata);
          } catch (e) {
            throw ClientConfigurationError.createInvalidAuthorityMetadataError();
          }
        }
        return null;
      };
      Authority2.prototype.getEndpointMetadataFromNetwork = function() {
        return __awaiter(this, void 0, void 0, function() {
          var options, response;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                options = {};
                if (this.proxyUrl) {
                  options.proxyUrl = this.proxyUrl;
                }
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint, options)];
              case 2:
                response = _a2.sent();
                return [2, isOpenIdConfigResponse(response.body) ? response.body : null];
              case 3:
                _a2.sent();
                return [2, null];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      Authority2.prototype.getEndpointMetadataFromHardcodedValues = function() {
        if (this.canonicalAuthority in EndpointMetadata) {
          return EndpointMetadata[this.canonicalAuthority];
        }
        return null;
      };
      Authority2.prototype.updateMetadataWithRegionalInformation = function(metadata) {
        var _a2, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function() {
          var autodetectedRegionName, azureRegion;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                return [4, this.regionDiscovery.detectRegion((_a2 = this.authorityOptions.azureRegionConfiguration) === null || _a2 === void 0 ? void 0 : _a2.environmentRegion, this.regionDiscoveryMetadata, this.proxyUrl)];
              case 1:
                autodetectedRegionName = _f.sent();
                azureRegion = ((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG ? autodetectedRegionName : (_c = this.authorityOptions.azureRegionConfiguration) === null || _c === void 0 ? void 0 : _c.azureRegion;
                if (((_d = this.authorityOptions.azureRegionConfiguration) === null || _d === void 0 ? void 0 : _d.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
                  this.regionDiscoveryMetadata.region_outcome = autodetectedRegionName ? RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL : RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
                } else {
                  if (autodetectedRegionName) {
                    this.regionDiscoveryMetadata.region_outcome = ((_e = this.authorityOptions.azureRegionConfiguration) === null || _e === void 0 ? void 0 : _e.azureRegion) === autodetectedRegionName ? RegionDiscoveryOutcomes.CONFIGURED_MATCHES_DETECTED : RegionDiscoveryOutcomes.CONFIGURED_NOT_DETECTED;
                  } else {
                    this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
                  }
                }
                if (azureRegion) {
                  this.regionDiscoveryMetadata.region_used = azureRegion;
                  return [2, Authority2.replaceWithRegionalInformation(metadata, azureRegion)];
                }
                return [2, metadata];
            }
          });
        });
      };
      Authority2.prototype.updateCloudDiscoveryMetadata = function(metadataEntity) {
        return __awaiter(this, void 0, void 0, function() {
          var metadata, harcodedMetadata;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                metadata = this.getCloudDiscoveryMetadataFromConfig();
                if (metadata) {
                  metadataEntity.updateCloudDiscoveryMetadata(metadata, false);
                  return [2, AuthorityMetadataSource.CONFIG];
                }
                if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntity.isExpired()) {
                  return [2, AuthorityMetadataSource.CACHE];
                }
                harcodedMetadata = this.getCloudDiscoveryMetadataFromHarcodedValues();
                return [4, this.getCloudDiscoveryMetadataFromNetwork()];
              case 1:
                metadata = _a2.sent();
                if (metadata) {
                  metadataEntity.updateCloudDiscoveryMetadata(metadata, true);
                  return [2, AuthorityMetadataSource.NETWORK];
                }
                if (harcodedMetadata && !this.options.skipAuthorityMetadataCache) {
                  metadataEntity.updateCloudDiscoveryMetadata(harcodedMetadata, false);
                  return [2, AuthorityMetadataSource.HARDCODED_VALUES];
                } else {
                  throw ClientConfigurationError.createUntrustedAuthorityError();
                }
            }
          });
        });
      };
      Authority2.prototype.getCloudDiscoveryMetadataFromConfig = function() {
        if (this.authorityOptions.cloudDiscoveryMetadata) {
          try {
            var parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
            var metadata = Authority2.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
            if (metadata) {
              return metadata;
            }
          } catch (e) {
            throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();
          }
        }
        if (this.isInKnownAuthorities()) {
          return Authority2.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return null;
      };
      Authority2.prototype.getCloudDiscoveryMetadataFromNetwork = function() {
        return __awaiter(this, void 0, void 0, function() {
          var instanceDiscoveryEndpoint, options, match, response, metadata;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                instanceDiscoveryEndpoint = "" + Constants.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + "oauth2/v2.0/authorize";
                options = {};
                if (this.proxyUrl) {
                  options.proxyUrl = this.proxyUrl;
                }
                match = null;
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options)];
              case 2:
                response = _a2.sent();
                metadata = isCloudInstanceDiscoveryResponse(response.body) ? response.body.metadata : [];
                if (metadata.length === 0) {
                  return [2, null];
                }
                match = Authority2.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
                return [3, 4];
              case 3:
                _a2.sent();
                return [2, null];
              case 4:
                if (!match) {
                  match = Authority2.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
                }
                return [2, match];
            }
          });
        });
      };
      Authority2.prototype.getCloudDiscoveryMetadataFromHarcodedValues = function() {
        if (this.canonicalAuthority in InstanceDiscoveryMetadata) {
          return InstanceDiscoveryMetadata[this.canonicalAuthority];
        }
        return null;
      };
      Authority2.prototype.isInKnownAuthorities = function() {
        var _this = this;
        var matches = this.authorityOptions.knownAuthorities.filter(function(authority) {
          return UrlString.getDomainFromUrl(authority).toLowerCase() === _this.hostnameAndPort;
        });
        return matches.length > 0;
      };
      Authority2.generateAuthority = function(authorityString, azureCloudOptions) {
        var authorityAzureCloudInstance;
        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
          var tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;
          authorityAzureCloudInstance = azureCloudOptions.azureCloudInstance + "/" + tenant + "/";
        }
        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
      };
      Authority2.createCloudDiscoveryMetadataFromHost = function(host) {
        return {
          preferred_network: host,
          preferred_cache: host,
          aliases: [host]
        };
      };
      Authority2.getCloudDiscoveryMetadataFromNetworkResponse = function(response, authority) {
        for (var i = 0; i < response.length; i++) {
          var metadata = response[i];
          if (metadata.aliases.indexOf(authority) > -1) {
            return metadata;
          }
        }
        return null;
      };
      Authority2.prototype.getPreferredCache = function() {
        if (this.discoveryComplete()) {
          return this.metadata.preferred_cache;
        } else {
          throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
        }
      };
      Authority2.prototype.isAlias = function(host) {
        return this.metadata.aliases.indexOf(host) > -1;
      };
      Authority2.isPublicCloudAuthority = function(host) {
        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
      };
      Authority2.buildRegionalAuthorityString = function(host, region, queryString) {
        var authorityUrlInstance = new UrlString(host);
        authorityUrlInstance.validateAsUri();
        var authorityUrlParts = authorityUrlInstance.getUrlComponents();
        var hostNameAndPort = region + "." + authorityUrlParts.HostNameAndPort;
        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
          hostNameAndPort = region + "." + Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX;
        }
        var url = UrlString.constructAuthorityUriFromObject(__assign(__assign({}, authorityUrlInstance.getUrlComponents()), { HostNameAndPort: hostNameAndPort })).urlString;
        if (queryString)
          return url + "?" + queryString;
        return url;
      };
      Authority2.replaceWithRegionalInformation = function(metadata, azureRegion) {
        metadata.authorization_endpoint = Authority2.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);
        metadata.token_endpoint = Authority2.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, Constants.REGIONAL_AUTH_NON_MSI_QUERY_STRING);
        if (metadata.end_session_endpoint) {
          metadata.end_session_endpoint = Authority2.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);
        }
        return metadata;
      };
      return Authority2;
    }();
  }
});
var AuthorityFactory;
var init_AuthorityFactory = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/authority/AuthorityFactory.js"() {
    "use strict";
    init_tslib();
    init_Authority();
    init_ClientConfigurationError();
    init_StringUtils();
    init_ClientAuthError();
    AuthorityFactory = /** @class */
    function() {
      function AuthorityFactory2() {
      }
      AuthorityFactory2.createDiscoveredInstance = function(authorityUri, networkClient, cacheManager, authorityOptions, proxyUrl) {
        return __awaiter(this, void 0, void 0, function() {
          var acquireTokenAuthority, e_1;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                acquireTokenAuthority = AuthorityFactory2.createInstance(authorityUri, networkClient, cacheManager, authorityOptions, proxyUrl);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, acquireTokenAuthority.resolveEndpointsAsync()];
              case 2:
                _a2.sent();
                return [2, acquireTokenAuthority];
              case 3:
                e_1 = _a2.sent();
                throw ClientAuthError.createEndpointDiscoveryIncompleteError(e_1);
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      AuthorityFactory2.createInstance = function(authorityUrl, networkInterface, cacheManager, authorityOptions, proxyUrl) {
        if (StringUtils.isEmpty(authorityUrl)) {
          throw ClientConfigurationError.createUrlEmptyError();
        }
        return new Authority(authorityUrl, networkInterface, cacheManager, authorityOptions, proxyUrl);
      };
      return AuthorityFactory2;
    }();
  }
});
var ServerTelemetryEntity;
var init_ServerTelemetryEntity = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/cache/entities/ServerTelemetryEntity.js"() {
    "use strict";
    init_Constants();
    ServerTelemetryEntity = /** @class */
    function() {
      function ServerTelemetryEntity2() {
        this.failedRequests = [];
        this.errors = [];
        this.cacheHits = 0;
      }
      ServerTelemetryEntity2.isServerTelemetryEntity = function(key, entity) {
        var validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
        var validateEntity = true;
        if (entity) {
          validateEntity = entity.hasOwnProperty("failedRequests") && entity.hasOwnProperty("errors") && entity.hasOwnProperty("cacheHits");
        }
        return validateKey && validateEntity;
      };
      return ServerTelemetryEntity2;
    }();
  }
});
var ThrottlingEntity;
var init_ThrottlingEntity = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/cache/entities/ThrottlingEntity.js"() {
    "use strict";
    init_Constants();
    ThrottlingEntity = /** @class */
    function() {
      function ThrottlingEntity2() {
      }
      ThrottlingEntity2.isThrottlingEntity = function(key, entity) {
        var validateKey = false;
        if (key) {
          validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
        }
        var validateEntity = true;
        if (entity) {
          validateEntity = entity.hasOwnProperty("throttleTime");
        }
        return validateKey && validateEntity;
      };
      return ThrottlingEntity2;
    }();
  }
});
var ServerTelemetryManager;
var init_ServerTelemetryManager = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.js"() {
    "use strict";
    init_Constants();
    init_ServerTelemetryEntity();
    init_StringUtils();
    ServerTelemetryManager = /** @class */
    function() {
      function ServerTelemetryManager2(telemetryRequest, cacheManager) {
        this.cacheOutcome = CacheOutcome.NO_CACHE_HIT;
        this.cacheManager = cacheManager;
        this.apiId = telemetryRequest.apiId;
        this.correlationId = telemetryRequest.correlationId;
        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
        this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
      }
      ServerTelemetryManager2.prototype.generateCurrentRequestHeaderValue = function() {
        var request3 = "" + this.apiId + SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR + this.cacheOutcome;
        var platformFields = [this.wrapperSKU, this.wrapperVer].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        var regionDiscoveryFields = this.getRegionDiscoveryFields();
        var requestWithRegionDiscoveryFields = [request3, regionDiscoveryFields].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, requestWithRegionDiscoveryFields, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      };
      ServerTelemetryManager2.prototype.generateLastRequestHeaderValue = function() {
        var lastRequests = this.getLastRequests();
        var maxErrors = ServerTelemetryManager2.maxErrorsToSend(lastRequests);
        var failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        var errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        var errorCount = lastRequests.errors.length;
        var overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
        var platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, lastRequests.cacheHits, failedRequests, errors, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      };
      ServerTelemetryManager2.prototype.cacheFailedRequest = function(error) {
        var lastRequests = this.getLastRequests();
        if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
          lastRequests.failedRequests.shift();
          lastRequests.failedRequests.shift();
          lastRequests.errors.shift();
        }
        lastRequests.failedRequests.push(this.apiId, this.correlationId);
        if (!StringUtils.isEmpty(error.subError)) {
          lastRequests.errors.push(error.subError);
        } else if (!StringUtils.isEmpty(error.errorCode)) {
          lastRequests.errors.push(error.errorCode);
        } else if (!!error && error.toString()) {
          lastRequests.errors.push(error.toString());
        } else {
          lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
        }
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
        return;
      };
      ServerTelemetryManager2.prototype.incrementCacheHits = function() {
        var lastRequests = this.getLastRequests();
        lastRequests.cacheHits += 1;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
        return lastRequests.cacheHits;
      };
      ServerTelemetryManager2.prototype.getLastRequests = function() {
        var initialValue = new ServerTelemetryEntity();
        var lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
        return lastRequests || initialValue;
      };
      ServerTelemetryManager2.prototype.clearTelemetryCache = function() {
        var lastRequests = this.getLastRequests();
        var numErrorsFlushed = ServerTelemetryManager2.maxErrorsToSend(lastRequests);
        var errorCount = lastRequests.errors.length;
        if (numErrorsFlushed === errorCount) {
          this.cacheManager.removeItem(this.telemetryCacheKey);
        } else {
          var serverTelemEntity = new ServerTelemetryEntity();
          serverTelemEntity.failedRequests = lastRequests.failedRequests.slice(numErrorsFlushed * 2);
          serverTelemEntity.errors = lastRequests.errors.slice(numErrorsFlushed);
          this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);
        }
      };
      ServerTelemetryManager2.maxErrorsToSend = function(serverTelemetryEntity) {
        var i;
        var maxErrors = 0;
        var dataSize = 0;
        var errorCount = serverTelemetryEntity.errors.length;
        for (i = 0; i < errorCount; i++) {
          var apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
          var correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
          var errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
          dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
          if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
            maxErrors += 1;
          } else {
            break;
          }
        }
        return maxErrors;
      };
      ServerTelemetryManager2.prototype.getRegionDiscoveryFields = function() {
        var regionDiscoveryFields = [];
        regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
        return regionDiscoveryFields.join(",");
      };
      ServerTelemetryManager2.prototype.updateRegionDiscoveryMetadata = function(regionDiscoveryMetadata) {
        this.regionUsed = regionDiscoveryMetadata.region_used;
        this.regionSource = regionDiscoveryMetadata.region_source;
        this.regionOutcome = regionDiscoveryMetadata.region_outcome;
      };
      ServerTelemetryManager2.prototype.setCacheOutcome = function(cacheOutcome) {
        this.cacheOutcome = cacheOutcome;
      };
      return ServerTelemetryManager2;
    }();
  }
});
var init_dist = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-common@7.6.0/node_modules/@azure/msal-common/dist/index.js"() {
    "use strict";
    init_AuthorizationCodeClient();
    init_DeviceCodeClient();
    init_RefreshTokenClient();
    init_ClientCredentialClient();
    init_OnBehalfOfClient();
    init_SilentFlowClient();
    init_UsernamePasswordClient();
    init_Authority();
    init_AuthorityOptions();
    init_AuthorityFactory();
    init_ProtocolMode();
    init_CacheManager();
    init_AppMetadataEntity();
    init_AccountEntity();
    init_IdTokenEntity();
    init_AccessTokenEntity();
    init_RefreshTokenEntity();
    init_ServerTelemetryEntity();
    init_AuthorityMetadataEntity();
    init_ThrottlingEntity();
    init_TokenCacheContext();
    init_UrlString();
    init_Logger();
    init_AuthError();
    init_ServerError();
    init_ClientAuthError();
    init_Constants();
    init_StringUtils();
    init_TimeUtils();
    init_ServerTelemetryManager();
  }
});
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var rnds8Pool, poolPtr;
var init_rng = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/rng.js"() {
    "use strict";
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});
var regex_default;
var init_regex = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/regex.js"() {
    "use strict";
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/validate.js"() {
    "use strict";
    init_regex();
    validate_default = validate;
  }
});
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/stringify.js"() {
    "use strict";
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v4.js"() {
    "use strict";
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});
var init_esm_node = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/index.js"() {
    "use strict";
    init_v4();
  }
});
var require_data_stream = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jws@3.2.2/node_modules/jws/lib/data-stream.js"(exports, module2) {
    "use strict";
    var Buffer2 = (0, import_chunk_QEHB4OUG.require_safe_buffer)().Buffer;
    var Stream = (0, import_chunk_FVJ3R4NJ.__require)("stream");
    var util2 = (0, import_chunk_FVJ3R4NJ.__require)("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util2.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});
var require_buffer_equal_constant_time = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/buffer-equal-constant-time@1.0.1/node_modules/buffer-equal-constant-time/index.js"(exports, module2) {
    "use strict";
    var Buffer2 = (0, import_chunk_FVJ3R4NJ.__require)("buffer").Buffer;
    var SlowBuffer = (0, import_chunk_FVJ3R4NJ.__require)("buffer").SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});
var require_param_bytes_for_alg = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/ecdsa-sig-formatter@1.0.11/node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});
var require_ecdsa_sig_formatter = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/ecdsa-sig-formatter@1.0.11/node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports, module2) {
    "use strict";
    var Buffer2 = (0, import_chunk_QEHB4OUG.require_safe_buffer)().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});
var require_jwa = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jwa@1.4.1/node_modules/jwa/index.js"(exports, module2) {
    "use strict";
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = (0, import_chunk_QEHB4OUG.require_safe_buffer)().Buffer;
    var crypto3 = (0, import_chunk_FVJ3R4NJ.__require)("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util2 = (0, import_chunk_FVJ3R4NJ.__require)("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto3.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util2.format.bind(util2, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign2(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto3.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign2(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto3.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto3.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign2(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto3.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto3.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto3.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto3.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto3.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto3.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign2() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign2() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});
var require_tostring = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jws@3.2.2/node_modules/jws/lib/tostring.js"(exports, module2) {
    "use strict";
    var Buffer2 = (0, import_chunk_FVJ3R4NJ.__require)("buffer").Buffer;
    module2.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});
var require_sign_stream = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jws@3.2.2/node_modules/jws/lib/sign-stream.js"(exports, module2) {
    "use strict";
    var Buffer2 = (0, import_chunk_QEHB4OUG.require_safe_buffer)().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = (0, import_chunk_FVJ3R4NJ.__require)("stream");
    var toString = require_tostring();
    var util2 = (0, import_chunk_FVJ3R4NJ.__require)("util");
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util2.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util2.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util2.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign2() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});
var require_verify_stream = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jws@3.2.2/node_modules/jws/lib/verify-stream.js"(exports, module2) {
    "use strict";
    var Buffer2 = (0, import_chunk_QEHB4OUG.require_safe_buffer)().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = (0, import_chunk_FVJ3R4NJ.__require)("stream");
    var toString = require_tostring();
    var util2 = (0, import_chunk_FVJ3R4NJ.__require)("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject2(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject2(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util2.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});
var require_jws = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jws@3.2.2/node_modules/jws/index.js"(exports) {
    "use strict";
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports.ALGORITHMS = ALGORITHMS;
    exports.sign = SignStream.sign;
    exports.verify = VerifyStream.verify;
    exports.decode = VerifyStream.decode;
    exports.isValid = VerifyStream.isValid;
    exports.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});
var require_decode = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jsonwebtoken@8.5.1/node_modules/jsonwebtoken/decode.js"(exports, module2) {
    "use strict";
    var jws = require_jws();
    module2.exports = function(jwt, options) {
      options = options || {};
      var decoded = jws.decode(jwt, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});
var require_JsonWebTokenError = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jsonwebtoken@8.5.1/node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports, module2) {
    "use strict";
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error)
        this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});
var require_NotBeforeError = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jsonwebtoken@8.5.1/node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports, module2) {
    "use strict";
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});
var require_TokenExpiredError = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jsonwebtoken@8.5.1/node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports, module2) {
    "use strict";
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});
var require_timespan = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jsonwebtoken@8.5.1/node_modules/jsonwebtoken/lib/timespan.js"(exports, module2) {
    "use strict";
    var ms = (0, import_chunk_MXIGSN4X.require_ms)();
    module2.exports = function(time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});
var require_semver = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/semver@5.7.1/node_modules/semver/semver.js"(exports, module2) {
    "use strict";
    exports = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports.re = [];
    var src = exports.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports.parse = parse2;
    function parse2(version3, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 !== "string") {
        return null;
      }
      if (version3.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version3)) {
        return null;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version3, options) {
      var v = parse2(version3, options);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version3, options) {
      var s = parse2(version3.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version3, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version3 instanceof SemVer) {
        if (version3.loose === options.loose) {
          return version3;
        } else {
          version3 = version3.version;
        }
      } else if (typeof version3 !== "string") {
        throw new TypeError("Invalid Version: " + version3);
      }
      if (version3.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version3, options);
      }
      debug("SemVer", version3, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version3.trim().match(options.loose ? re[LOOSE] : re[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version3);
      }
      this.raw = version3;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER2) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release2, identifier) {
      switch (release2) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release2);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version3, release2, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version3, loose).inc(release2, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version22) {
      if (eq(version1, version22)) {
        return null;
      } else {
        var v1 = parse2(version1);
        var v2 = parse2(version22);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compare(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.rcompare(a, b, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version3) {
      debug("Comparator.test", version3, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version3 === "string") {
        version3 = new SemVer(version3, this.options);
      }
      return cmp(version3, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_2, M, m, p, pr) {
        debug("tilde", comp, _2, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_2, M, m, p, pr) {
        debug("caret", comp, _2, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version3) {
      if (!version3) {
        return false;
      }
      if (typeof version3 === "string") {
        version3 = new SemVer(version3, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version3, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version3, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version3, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version3);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version3, range, options) {
      return outside(version3, range, "<", options);
    }
    exports.gtr = gtr;
    function gtr(version3, range, options) {
      return outside(version3, range, ">", options);
    }
    exports.outside = outside;
    function outside(version3, range, hilo, options) {
      version3 = new SemVer(version3, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version3, options) {
      var parsed = parse2(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports.coerce = coerce;
    function coerce(version3) {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 !== "string") {
        return null;
      }
      var match = version3.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse2(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});
var require_psSupported = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jsonwebtoken@8.5.1/node_modules/jsonwebtoken/lib/psSupported.js"(exports, module2) {
    "use strict";
    var semver = require_semver();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});
var require_verify = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jsonwebtoken@8.5.1/node_modules/jsonwebtoken/verify.js"(exports, module2) {
    "use strict";
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      var done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err)
            throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      var parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      var decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      var header = decodedToken.header;
      var getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        var hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          options.algorithms = ["none"];
        }
        if (!options.algorithms) {
          options.algorithms = ~secretOrPublicKey2.toString().indexOf("BEGIN CERTIFICATE") || ~secretOrPublicKey2.toString().indexOf("BEGIN PUBLIC KEY") ? PUB_KEY_ALGS : ~secretOrPublicKey2.toString().indexOf("BEGIN RSA PUBLIC KEY") ? RSA_KEY_ALGS : HS_ALGS;
        }
        if (!~options.algorithms.indexOf(decodedToken.header.alg)) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        var valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        var payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          var match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          var invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          var maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          var signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});
var require_lodash = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/lodash.includes@4.3.0/node_modules/lodash.includes/index.js"(exports, module2) {
    "use strict";
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER2 : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject2(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = includes;
  }
});
var require_lodash2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/lodash.isboolean@3.0.3/node_modules/lodash.isboolean/index.js"(exports, module2) {
    "use strict";
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});
var require_lodash3 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/lodash.isinteger@4.0.4/node_modules/lodash.isinteger/index.js"(exports, module2) {
    "use strict";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject2(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger;
  }
});
var require_lodash4 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/lodash.isnumber@3.0.3/node_modules/lodash.isnumber/index.js"(exports, module2) {
    "use strict";
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber;
  }
});
var require_lodash5 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/lodash.isplainobject@4.0.6/node_modules/lodash.isplainobject/index.js"(exports, module2) {
    "use strict";
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});
var require_lodash6 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/lodash.isstring@4.0.1/node_modules/lodash.isstring/index.js"(exports, module2) {
    "use strict";
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString;
  }
});
var require_lodash7 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/lodash.once@4.1.1/node_modules/lodash.once/index.js"(exports, module2) {
    "use strict";
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject2(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once;
  }
});
var require_sign = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jsonwebtoken@8.5.1/node_modules/jsonwebtoken/sign.js"(exports, module2) {
    "use strict";
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber = require_lodash4();
    var isPlainObject = require_lodash5();
    var isString = require_lodash6();
    var once = require_lodash7();
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString, message: '"encoding" must be a string' },
      issuer: { isValid: isString, message: '"issuer" must be a string' },
      subject: { isValid: isString, message: '"subject" must be a string' },
      jwtid: { isValid: isString, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
    };
    function validate2(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        var validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate2(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate2(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      var isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      var header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        var invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      var timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        var claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      var encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          callback(null, signature);
        });
      } else {
        return jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
      }
    };
  }
});
var require_jsonwebtoken = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/jsonwebtoken@8.5.1/node_modules/jsonwebtoken/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});
function buildAppConfiguration({
  auth,
  cache,
  system,
  telemetry
}) {
  return {
    auth: {
      ...DEFAULT_AUTH_OPTIONS,
      ...auth
    },
    cache: {
      ...DEFAULT_CACHE_OPTIONS,
      ...cache
    },
    system: {
      ...DEFAULT_SYSTEM_OPTIONS2,
      ...system
    },
    telemetry: {
      ...DEFAULT_TELEMETRY_OPTIONS2,
      ...telemetry
    }
  };
}
var import_jsonwebtoken, HttpMethod, HttpStatus, REGION_ENVIRONMENT_VARIABLE, RANDOM_OCTET_SIZE, Hash, CharSet, Constants2, ApiId, JwtConstants, LOOPBACK_SERVER_CONSTANTS, HttpClient, networkRequestViaProxy, networkRequestViaHttps, NetworkUtils, DEFAULT_AUTH_OPTIONS, DEFAULT_CACHE_OPTIONS, DEFAULT_LOGGER_OPTIONS, DEFAULT_SYSTEM_OPTIONS2, DEFAULT_TELEMETRY_OPTIONS2, GuidGenerator, EncodingUtils, HashUtils, PkceGenerator, CryptoProvider, Deserializer, Serializer, NodeStorage, defaultSerializedCache, TokenCache, name2, version2, NodeAuthErrorMessage, NodeAuthError, ClientApplication, LoopbackClient, PublicClientApplication, ClientAssertion, ConfidentialClientApplication;
var init_msal_node_esm = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+msal-node@1.14.2/node_modules/@azure/msal-node/dist/msal-node.esm.js"() {
    "use strict";
    init_dist();
    init_esm_node();
    import_jsonwebtoken = (0, import_chunk_FVJ3R4NJ.__toESM)(require_jsonwebtoken());
    (function(HttpMethod2) {
      HttpMethod2["GET"] = "get";
      HttpMethod2["POST"] = "post";
    })(HttpMethod || (HttpMethod = {}));
    (function(HttpStatus2) {
      HttpStatus2[HttpStatus2["OK"] = 200] = "OK";
      HttpStatus2[HttpStatus2["REDIRECT"] = 302] = "REDIRECT";
    })(HttpStatus || (HttpStatus = {}));
    REGION_ENVIRONMENT_VARIABLE = "REGION_NAME";
    RANDOM_OCTET_SIZE = 32;
    Hash = {
      SHA256: "sha256"
    };
    CharSet = {
      CV_CHARSET: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
    };
    Constants2 = {
      MSAL_SKU: "msal.js.node",
      JWT_BEARER_ASSERTION_TYPE: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
      AUTHORIZATION_PENDING: "authorization_pending",
      HTTP_PROTOCOL: "http://",
      LOCALHOST: "localhost"
    };
    (function(ApiId2) {
      ApiId2[ApiId2["acquireTokenSilent"] = 62] = "acquireTokenSilent";
      ApiId2[ApiId2["acquireTokenByUsernamePassword"] = 371] = "acquireTokenByUsernamePassword";
      ApiId2[ApiId2["acquireTokenByDeviceCode"] = 671] = "acquireTokenByDeviceCode";
      ApiId2[ApiId2["acquireTokenByClientCredential"] = 771] = "acquireTokenByClientCredential";
      ApiId2[ApiId2["acquireTokenByCode"] = 871] = "acquireTokenByCode";
      ApiId2[ApiId2["acquireTokenByRefreshToken"] = 872] = "acquireTokenByRefreshToken";
    })(ApiId || (ApiId = {}));
    JwtConstants = {
      ALGORITHM: "alg",
      RSA_256: "RS256",
      X5T: "x5t",
      X5C: "x5c",
      AUDIENCE: "aud",
      EXPIRATION_TIME: "exp",
      ISSUER: "iss",
      SUBJECT: "sub",
      NOT_BEFORE: "nbf",
      JWT_ID: "jti"
    };
    LOOPBACK_SERVER_CONSTANTS = {
      INTERVAL_MS: 100,
      TIMEOUT_MS: 5e3
    };
    HttpClient = class {
      /**
       * Http Get request
       * @param url
       * @param options
       */
      async sendGetRequestAsync(url, options) {
        if (options != null && options.proxyUrl) {
          return networkRequestViaProxy(url, HttpMethod.GET, options);
        } else {
          return networkRequestViaHttps(url, HttpMethod.GET, options);
        }
      }
      /**
       * Http Post request
       * @param url
       * @param options
       */
      async sendPostRequestAsync(url, options, cancellationToken) {
        if (options != null && options.proxyUrl) {
          return networkRequestViaProxy(url, HttpMethod.POST, options, cancellationToken);
        } else {
          return networkRequestViaHttps(url, HttpMethod.POST, options, cancellationToken);
        }
      }
    };
    networkRequestViaProxy = (url, httpMethod, options, timeout) => {
      const headers = (options == null ? void 0 : options.headers) || {};
      const proxyUrl = new URL((options == null ? void 0 : options.proxyUrl) || "");
      const destinationUrl = new URL(url);
      const tunnelRequestOptions = {
        host: proxyUrl.hostname,
        port: proxyUrl.port,
        method: "CONNECT",
        path: destinationUrl.hostname,
        headers
      };
      if (timeout) {
        tunnelRequestOptions.timeout = timeout;
      }
      let postRequestStringContent = "";
      if (httpMethod === HttpMethod.POST) {
        const body = (options == null ? void 0 : options.body) || "";
        postRequestStringContent = `Content-Type: application/x-www-form-urlencoded\r
Content-Length: ${body.length}\r
\r
${body}`;
      }
      const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\r
Host: ${destinationUrl.host}\r
Connection: close\r
` + postRequestStringContent + "\r\n";
      return new Promise((resolve, reject) => {
        const request3 = import_http.default.request(tunnelRequestOptions);
        if (tunnelRequestOptions.timeout) {
          request3.on("timeout", () => {
            request3.destroy();
            reject(new Error("Request time out"));
          });
        }
        request3.end();
        request3.on("connect", (response, socket) => {
          const statusCode = (response == null ? void 0 : response.statusCode) || 500;
          if (statusCode < 200 || statusCode > 299) {
            request3.destroy();
            socket.destroy();
            reject(new Error(` Error connecting to proxy: ${response.statusCode}, ${response == null ? void 0 : response.statusMessage}`));
          }
          if (tunnelRequestOptions.timeout) {
            socket.setTimeout(tunnelRequestOptions.timeout);
            socket.on("timeout", () => {
              request3.destroy();
              socket.destroy();
              reject(new Error("Request time out"));
            });
          }
          socket.write(outgoingRequestString);
          const data = [];
          socket.on("data", (chunk) => {
            data.push(chunk);
          });
          socket.on("end", () => {
            const dataString = Buffer.concat([...data]).toString();
            const dataStringArray = dataString.split("\r\n");
            const statusCode2 = parseInt(dataStringArray[0].split(" ")[1]);
            const body = dataStringArray[dataStringArray.length - 1];
            const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);
            const entries = /* @__PURE__ */ new Map();
            headersArray.forEach((header) => {
              const headerKeyValue = header.split(new RegExp(/:\s(.*)/s));
              const headerKey = headerKeyValue[0];
              let headerValue = headerKeyValue[1];
              try {
                const object = JSON.parse(headerValue);
                if (object && typeof object === "object") {
                  headerValue = object;
                }
              } catch (e) {
              }
              entries.set(headerKey, headerValue);
            });
            const headers2 = Object.fromEntries(entries);
            const networkResponse = {
              headers: headers2,
              body: JSON.parse(body),
              status: statusCode2
            };
            if ((statusCode2 < 200 || statusCode2 > 299) && // do not destroy the request for the device code flow
            networkResponse.body["error"] !== Constants2.AUTHORIZATION_PENDING) {
              request3.destroy();
            }
            resolve(networkResponse);
          });
          socket.on("error", (chunk) => {
            request3.destroy();
            socket.destroy();
            reject(new Error(chunk.toString()));
          });
        });
        request3.on("error", (chunk) => {
          request3.destroy();
          reject(new Error(chunk.toString()));
        });
      });
    };
    networkRequestViaHttps = (url, httpMethod, options, timeout) => {
      const isPostRequest = httpMethod === HttpMethod.POST;
      const body = (options == null ? void 0 : options.body) || "";
      const emptyHeaders = {};
      const customOptions = {
        method: httpMethod,
        headers: (options == null ? void 0 : options.headers) || emptyHeaders
      };
      if (timeout) {
        customOptions.timeout = timeout;
      }
      if (isPostRequest) {
        customOptions.headers = {
          ...customOptions.headers,
          "Content-Length": body.length
        };
      }
      return new Promise((resolve, reject) => {
        const request3 = import_https.default.request(url, customOptions);
        if (timeout) {
          request3.on("timeout", () => {
            request3.destroy();
            reject(new Error("Request time out"));
          });
        }
        if (isPostRequest) {
          request3.write(body);
        }
        request3.end();
        request3.on("response", (response) => {
          const headers = response.headers;
          const statusCode = response.statusCode;
          const data = [];
          response.on("data", (chunk) => {
            data.push(chunk);
          });
          response.on("end", () => {
            const body2 = Buffer.concat([...data]).toString();
            const networkResponse = {
              headers,
              body: JSON.parse(body2),
              status: statusCode
            };
            if ((statusCode < 200 || statusCode > 299) && // do not destroy the request for the device code flow
            networkResponse.body["error"] !== Constants2.AUTHORIZATION_PENDING) {
              request3.destroy();
            }
            resolve(networkResponse);
          });
        });
        request3.on("error", (chunk) => {
          request3.destroy();
          reject(new Error(chunk.toString()));
        });
      });
    };
    NetworkUtils = class {
      /**
       * Returns best compatible network client object.
       */
      static getNetworkClient() {
        return new HttpClient();
      }
    };
    DEFAULT_AUTH_OPTIONS = {
      clientId: Constants.EMPTY_STRING,
      authority: Constants.DEFAULT_AUTHORITY,
      clientSecret: Constants.EMPTY_STRING,
      clientAssertion: Constants.EMPTY_STRING,
      clientCertificate: {
        thumbprint: Constants.EMPTY_STRING,
        privateKey: Constants.EMPTY_STRING,
        x5c: Constants.EMPTY_STRING
      },
      knownAuthorities: [],
      cloudDiscoveryMetadata: Constants.EMPTY_STRING,
      authorityMetadata: Constants.EMPTY_STRING,
      clientCapabilities: [],
      protocolMode: ProtocolMode.AAD,
      azureCloudOptions: {
        azureCloudInstance: AzureCloudInstance.None,
        tenant: Constants.EMPTY_STRING
      },
      skipAuthorityMetadataCache: false
    };
    DEFAULT_CACHE_OPTIONS = {};
    DEFAULT_LOGGER_OPTIONS = {
      loggerCallback: () => {
      },
      piiLoggingEnabled: false,
      logLevel: LogLevel.Info
    };
    DEFAULT_SYSTEM_OPTIONS2 = {
      loggerOptions: DEFAULT_LOGGER_OPTIONS,
      networkClient: /* @__PURE__ */ NetworkUtils.getNetworkClient(),
      proxyUrl: Constants.EMPTY_STRING
    };
    DEFAULT_TELEMETRY_OPTIONS2 = {
      application: {
        appName: Constants.EMPTY_STRING,
        appVersion: Constants.EMPTY_STRING
      }
    };
    GuidGenerator = class {
      /**
       *
       * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.
       * uuidv4 generates guids from cryprtographically-string random
       */
      generateGuid() {
        return v4_default();
      }
      /**
       * verifies if a string is  GUID
       * @param guid
       */
      isGuid(guid) {
        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return regexGuid.test(guid);
      }
    };
    EncodingUtils = class _EncodingUtils {
      /**
       * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
       * 'base64': Base64 encoding.
       *
       * @param str text
       */
      static base64Encode(str, encoding) {
        return Buffer.from(str, encoding).toString("base64");
      }
      /**
       * encode a URL
       * @param str
       */
      static base64EncodeUrl(str, encoding) {
        return _EncodingUtils.base64Encode(str, encoding).replace(/=/g, Constants.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_");
      }
      /**
       * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
       * 'base64': Base64 encoding.
       *
       * @param base64Str Base64 encoded text
       */
      static base64Decode(base64Str) {
        return Buffer.from(base64Str, "base64").toString("utf8");
      }
      /**
       * @param base64Str Base64 encoded Url
       */
      static base64DecodeUrl(base64Str) {
        let str = base64Str.replace(/-/g, "+").replace(/_/g, "/");
        while (str.length % 4) {
          str += "=";
        }
        return _EncodingUtils.base64Decode(str);
      }
    };
    HashUtils = class {
      /**
       * generate 'SHA256' hash
       * @param buffer
       */
      sha256(buffer) {
        return import_crypto2.default.createHash(Hash.SHA256).update(buffer).digest();
      }
    };
    PkceGenerator = class {
      constructor() {
        this.hashUtils = new HashUtils();
      }
      /**
       * generates the codeVerfier and the challenge from the codeVerfier
       * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2
       */
      async generatePkceCodes() {
        const verifier = this.generateCodeVerifier();
        const challenge = this.generateCodeChallengeFromVerifier(verifier);
        return {
          verifier,
          challenge
        };
      }
      /**
       * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1
       */
      generateCodeVerifier() {
        const charArr = [];
        const maxNumber = 256 - 256 % CharSet.CV_CHARSET.length;
        while (charArr.length <= RANDOM_OCTET_SIZE) {
          const byte = import_crypto2.default.randomBytes(1)[0];
          if (byte >= maxNumber) {
            continue;
          }
          const index = byte % CharSet.CV_CHARSET.length;
          charArr.push(CharSet.CV_CHARSET[index]);
        }
        const verifier = charArr.join(Constants.EMPTY_STRING);
        return EncodingUtils.base64EncodeUrl(verifier);
      }
      /**
       * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2
       * @param codeVerifier
       */
      generateCodeChallengeFromVerifier(codeVerifier) {
        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(codeVerifier).toString("base64"), "base64");
      }
    };
    CryptoProvider = class {
      constructor() {
        this.pkceGenerator = new PkceGenerator();
        this.guidGenerator = new GuidGenerator();
        this.hashUtils = new HashUtils();
      }
      /**
       * Creates a new random GUID - used to populate state and nonce.
       * @returns string (GUID)
       */
      createNewGuid() {
        return this.guidGenerator.generateGuid();
      }
      /**
       * Encodes input string to base64.
       * @param input - string to be encoded
       */
      base64Encode(input) {
        return EncodingUtils.base64Encode(input);
      }
      /**
       * Decodes input string from base64.
       * @param input - string to be decoded
       */
      base64Decode(input) {
        return EncodingUtils.base64Decode(input);
      }
      /**
       * Generates PKCE codes used in Authorization Code Flow.
       */
      generatePkceCodes() {
        return this.pkceGenerator.generatePkceCodes();
      }
      /**
       * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node
       */
      getPublicKeyThumbprint() {
        throw new Error("Method not implemented.");
      }
      /**
       * Removes cryptographic keypair from key store matching the keyId passed in
       * @param kid
       */
      removeTokenBindingKey() {
        throw new Error("Method not implemented.");
      }
      /**
       * Removes all cryptographic keys from Keystore
       */
      clearKeystore() {
        throw new Error("Method not implemented.");
      }
      /**
       * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node
       */
      signJwt() {
        throw new Error("Method not implemented.");
      }
      /**
       * Returns the SHA-256 hash of an input string
       */
      async hashString(plainText) {
        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(plainText).toString("base64"), "base64");
      }
    };
    Deserializer = class {
      /**
       * Parse the JSON blob in memory and deserialize the content
       * @param cachedJson
       */
      static deserializeJSONBlob(jsonFile) {
        const deserializedCache = StringUtils.isEmpty(jsonFile) ? {} : JSON.parse(jsonFile);
        return deserializedCache;
      }
      /**
       * Deserializes accounts to AccountEntity objects
       * @param accounts
       */
      static deserializeAccounts(accounts) {
        const accountObjects = {};
        if (accounts) {
          Object.keys(accounts).map(function(key) {
            const serializedAcc = accounts[key];
            const mappedAcc = {
              homeAccountId: serializedAcc.home_account_id,
              environment: serializedAcc.environment,
              realm: serializedAcc.realm,
              localAccountId: serializedAcc.local_account_id,
              username: serializedAcc.username,
              authorityType: serializedAcc.authority_type,
              name: serializedAcc.name,
              clientInfo: serializedAcc.client_info,
              lastModificationTime: serializedAcc.last_modification_time,
              lastModificationApp: serializedAcc.last_modification_app
            };
            const account = new AccountEntity();
            CacheManager.toObject(account, mappedAcc);
            accountObjects[key] = account;
          });
        }
        return accountObjects;
      }
      /**
       * Deserializes id tokens to IdTokenEntity objects
       * @param idTokens
       */
      static deserializeIdTokens(idTokens) {
        const idObjects = {};
        if (idTokens) {
          Object.keys(idTokens).map(function(key) {
            const serializedIdT = idTokens[key];
            const mappedIdT = {
              homeAccountId: serializedIdT.home_account_id,
              environment: serializedIdT.environment,
              credentialType: serializedIdT.credential_type,
              clientId: serializedIdT.client_id,
              secret: serializedIdT.secret,
              realm: serializedIdT.realm
            };
            const idToken = new IdTokenEntity();
            CacheManager.toObject(idToken, mappedIdT);
            idObjects[key] = idToken;
          });
        }
        return idObjects;
      }
      /**
       * Deserializes access tokens to AccessTokenEntity objects
       * @param accessTokens
       */
      static deserializeAccessTokens(accessTokens) {
        const atObjects = {};
        if (accessTokens) {
          Object.keys(accessTokens).map(function(key) {
            const serializedAT = accessTokens[key];
            const mappedAT = {
              homeAccountId: serializedAT.home_account_id,
              environment: serializedAT.environment,
              credentialType: serializedAT.credential_type,
              clientId: serializedAT.client_id,
              secret: serializedAT.secret,
              realm: serializedAT.realm,
              target: serializedAT.target,
              cachedAt: serializedAT.cached_at,
              expiresOn: serializedAT.expires_on,
              extendedExpiresOn: serializedAT.extended_expires_on,
              refreshOn: serializedAT.refresh_on,
              keyId: serializedAT.key_id,
              tokenType: serializedAT.token_type,
              requestedClaims: serializedAT.requestedClaims,
              requestedClaimsHash: serializedAT.requestedClaimsHash
            };
            const accessToken = new AccessTokenEntity();
            CacheManager.toObject(accessToken, mappedAT);
            atObjects[key] = accessToken;
          });
        }
        return atObjects;
      }
      /**
       * Deserializes refresh tokens to RefreshTokenEntity objects
       * @param refreshTokens
       */
      static deserializeRefreshTokens(refreshTokens) {
        const rtObjects = {};
        if (refreshTokens) {
          Object.keys(refreshTokens).map(function(key) {
            const serializedRT = refreshTokens[key];
            const mappedRT = {
              homeAccountId: serializedRT.home_account_id,
              environment: serializedRT.environment,
              credentialType: serializedRT.credential_type,
              clientId: serializedRT.client_id,
              secret: serializedRT.secret,
              familyId: serializedRT.family_id,
              target: serializedRT.target,
              realm: serializedRT.realm
            };
            const refreshToken = new RefreshTokenEntity();
            CacheManager.toObject(refreshToken, mappedRT);
            rtObjects[key] = refreshToken;
          });
        }
        return rtObjects;
      }
      /**
       * Deserializes appMetadata to AppMetaData objects
       * @param appMetadata
       */
      static deserializeAppMetadata(appMetadata) {
        const appMetadataObjects = {};
        if (appMetadata) {
          Object.keys(appMetadata).map(function(key) {
            const serializedAmdt = appMetadata[key];
            const mappedAmd = {
              clientId: serializedAmdt.client_id,
              environment: serializedAmdt.environment,
              familyId: serializedAmdt.family_id
            };
            const amd = new AppMetadataEntity();
            CacheManager.toObject(amd, mappedAmd);
            appMetadataObjects[key] = amd;
          });
        }
        return appMetadataObjects;
      }
      /**
       * Deserialize an inMemory Cache
       * @param jsonCache
       */
      static deserializeAllCache(jsonCache) {
        return {
          accounts: jsonCache.Account ? this.deserializeAccounts(jsonCache.Account) : {},
          idTokens: jsonCache.IdToken ? this.deserializeIdTokens(jsonCache.IdToken) : {},
          accessTokens: jsonCache.AccessToken ? this.deserializeAccessTokens(jsonCache.AccessToken) : {},
          refreshTokens: jsonCache.RefreshToken ? this.deserializeRefreshTokens(jsonCache.RefreshToken) : {},
          appMetadata: jsonCache.AppMetadata ? this.deserializeAppMetadata(jsonCache.AppMetadata) : {}
        };
      }
    };
    Serializer = class {
      /**
       * serialize the JSON blob
       * @param data
       */
      static serializeJSONBlob(data) {
        return JSON.stringify(data);
      }
      /**
       * Serialize Accounts
       * @param accCache
       */
      static serializeAccounts(accCache) {
        const accounts = {};
        Object.keys(accCache).map(function(key) {
          const accountEntity = accCache[key];
          accounts[key] = {
            home_account_id: accountEntity.homeAccountId,
            environment: accountEntity.environment,
            realm: accountEntity.realm,
            local_account_id: accountEntity.localAccountId,
            username: accountEntity.username,
            authority_type: accountEntity.authorityType,
            name: accountEntity.name,
            client_info: accountEntity.clientInfo,
            last_modification_time: accountEntity.lastModificationTime,
            last_modification_app: accountEntity.lastModificationApp
          };
        });
        return accounts;
      }
      /**
       * Serialize IdTokens
       * @param idTCache
       */
      static serializeIdTokens(idTCache) {
        const idTokens = {};
        Object.keys(idTCache).map(function(key) {
          const idTEntity = idTCache[key];
          idTokens[key] = {
            home_account_id: idTEntity.homeAccountId,
            environment: idTEntity.environment,
            credential_type: idTEntity.credentialType,
            client_id: idTEntity.clientId,
            secret: idTEntity.secret,
            realm: idTEntity.realm
          };
        });
        return idTokens;
      }
      /**
       * Serializes AccessTokens
       * @param atCache
       */
      static serializeAccessTokens(atCache) {
        const accessTokens = {};
        Object.keys(atCache).map(function(key) {
          const atEntity = atCache[key];
          accessTokens[key] = {
            home_account_id: atEntity.homeAccountId,
            environment: atEntity.environment,
            credential_type: atEntity.credentialType,
            client_id: atEntity.clientId,
            secret: atEntity.secret,
            realm: atEntity.realm,
            target: atEntity.target,
            cached_at: atEntity.cachedAt,
            expires_on: atEntity.expiresOn,
            extended_expires_on: atEntity.extendedExpiresOn,
            refresh_on: atEntity.refreshOn,
            key_id: atEntity.keyId,
            token_type: atEntity.tokenType,
            requestedClaims: atEntity.requestedClaims,
            requestedClaimsHash: atEntity.requestedClaimsHash
          };
        });
        return accessTokens;
      }
      /**
       * Serialize refreshTokens
       * @param rtCache
       */
      static serializeRefreshTokens(rtCache) {
        const refreshTokens = {};
        Object.keys(rtCache).map(function(key) {
          const rtEntity = rtCache[key];
          refreshTokens[key] = {
            home_account_id: rtEntity.homeAccountId,
            environment: rtEntity.environment,
            credential_type: rtEntity.credentialType,
            client_id: rtEntity.clientId,
            secret: rtEntity.secret,
            family_id: rtEntity.familyId,
            target: rtEntity.target,
            realm: rtEntity.realm
          };
        });
        return refreshTokens;
      }
      /**
       * Serialize amdtCache
       * @param amdtCache
       */
      static serializeAppMetadata(amdtCache) {
        const appMetadata = {};
        Object.keys(amdtCache).map(function(key) {
          const amdtEntity = amdtCache[key];
          appMetadata[key] = {
            client_id: amdtEntity.clientId,
            environment: amdtEntity.environment,
            family_id: amdtEntity.familyId
          };
        });
        return appMetadata;
      }
      /**
       * Serialize the cache
       * @param jsonContent
       */
      static serializeAllCache(inMemCache) {
        return {
          Account: this.serializeAccounts(inMemCache.accounts),
          IdToken: this.serializeIdTokens(inMemCache.idTokens),
          AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),
          RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),
          AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata)
        };
      }
    };
    NodeStorage = class extends CacheManager {
      constructor(logger25, clientId, cryptoImpl) {
        super(clientId, cryptoImpl);
        this.cache = {};
        this.changeEmitters = [];
        this.logger = logger25;
      }
      /**
       * Queue up callbacks
       * @param func - a callback function for cache change indication
       */
      registerChangeEmitter(func) {
        this.changeEmitters.push(func);
      }
      /**
       * Invoke the callback when cache changes
       */
      emitChange() {
        this.changeEmitters.forEach((func) => func.call(null));
      }
      /**
       * Converts cacheKVStore to InMemoryCache
       * @param cache - key value store
       */
      cacheToInMemoryCache(cache) {
        const inMemoryCache = {
          accounts: {},
          idTokens: {},
          accessTokens: {},
          refreshTokens: {},
          appMetadata: {}
        };
        for (const key in cache) {
          if (cache[key] instanceof AccountEntity) {
            inMemoryCache.accounts[key] = cache[key];
          } else if (cache[key] instanceof IdTokenEntity) {
            inMemoryCache.idTokens[key] = cache[key];
          } else if (cache[key] instanceof AccessTokenEntity) {
            inMemoryCache.accessTokens[key] = cache[key];
          } else if (cache[key] instanceof RefreshTokenEntity) {
            inMemoryCache.refreshTokens[key] = cache[key];
          } else if (cache[key] instanceof AppMetadataEntity) {
            inMemoryCache.appMetadata[key] = cache[key];
          } else {
            continue;
          }
        }
        return inMemoryCache;
      }
      /**
       * converts inMemoryCache to CacheKVStore
       * @param inMemoryCache - kvstore map for inmemory
       */
      inMemoryCacheToCache(inMemoryCache) {
        let cache = this.getCache();
        cache = {
          ...cache,
          ...inMemoryCache.accounts,
          ...inMemoryCache.idTokens,
          ...inMemoryCache.accessTokens,
          ...inMemoryCache.refreshTokens,
          ...inMemoryCache.appMetadata
        };
        return cache;
      }
      /**
       * gets the current in memory cache for the client
       */
      getInMemoryCache() {
        this.logger.trace("Getting in-memory cache");
        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());
        return inMemoryCache;
      }
      /**
       * sets the current in memory cache for the client
       * @param inMemoryCache - key value map in memory
       */
      setInMemoryCache(inMemoryCache) {
        this.logger.trace("Setting in-memory cache");
        const cache = this.inMemoryCacheToCache(inMemoryCache);
        this.setCache(cache);
        this.emitChange();
      }
      /**
       * get the current cache key-value store
       */
      getCache() {
        this.logger.trace("Getting cache key-value store");
        return this.cache;
      }
      /**
       * sets the current cache (key value store)
       * @param cacheMap - key value map
       */
      setCache(cache) {
        this.logger.trace("Setting cache key value store");
        this.cache = cache;
        this.emitChange();
      }
      /**
       * Gets cache item with given key.
       * @param key - lookup key for the cache entry
       */
      getItem(key) {
        this.logger.tracePii(`Item key: ${key}`);
        const cache = this.getCache();
        return cache[key];
      }
      /**
       * Gets cache item with given key-value
       * @param key - lookup key for the cache entry
       * @param value - value of the cache entry
       */
      setItem(key, value) {
        this.logger.tracePii(`Item key: ${key}`);
        const cache = this.getCache();
        cache[key] = value;
        this.setCache(cache);
      }
      /**
       * fetch the account entity
       * @param accountKey - lookup key to fetch cache type AccountEntity
       */
      getAccount(accountKey) {
        const account = this.getItem(accountKey);
        if (AccountEntity.isAccountEntity(account)) {
          return account;
        }
        return null;
      }
      /**
       * set account entity
       * @param account - cache value to be set of type AccountEntity
       */
      setAccount(account) {
        const accountKey = account.generateAccountKey();
        this.setItem(accountKey, account);
      }
      /**
       * fetch the idToken credential
       * @param idTokenKey - lookup key to fetch cache type IdTokenEntity
       */
      getIdTokenCredential(idTokenKey) {
        const idToken = this.getItem(idTokenKey);
        if (IdTokenEntity.isIdTokenEntity(idToken)) {
          return idToken;
        }
        return null;
      }
      /**
       * set idToken credential
       * @param idToken - cache value to be set of type IdTokenEntity
       */
      setIdTokenCredential(idToken) {
        const idTokenKey = idToken.generateCredentialKey();
        this.setItem(idTokenKey, idToken);
      }
      /**
       * fetch the accessToken credential
       * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity
       */
      getAccessTokenCredential(accessTokenKey) {
        const accessToken = this.getItem(accessTokenKey);
        if (AccessTokenEntity.isAccessTokenEntity(accessToken)) {
          return accessToken;
        }
        return null;
      }
      /**
       * set accessToken credential
       * @param accessToken -  cache value to be set of type AccessTokenEntity
       */
      setAccessTokenCredential(accessToken) {
        const accessTokenKey = accessToken.generateCredentialKey();
        this.setItem(accessTokenKey, accessToken);
      }
      /**
       * fetch the refreshToken credential
       * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity
       */
      getRefreshTokenCredential(refreshTokenKey) {
        const refreshToken = this.getItem(refreshTokenKey);
        if (RefreshTokenEntity.isRefreshTokenEntity(refreshToken)) {
          return refreshToken;
        }
        return null;
      }
      /**
       * set refreshToken credential
       * @param refreshToken - cache value to be set of type RefreshTokenEntity
       */
      setRefreshTokenCredential(refreshToken) {
        const refreshTokenKey = refreshToken.generateCredentialKey();
        this.setItem(refreshTokenKey, refreshToken);
      }
      /**
       * fetch appMetadata entity from the platform cache
       * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity
       */
      getAppMetadata(appMetadataKey) {
        const appMetadata = this.getItem(appMetadataKey);
        if (AppMetadataEntity.isAppMetadataEntity(appMetadataKey, appMetadata)) {
          return appMetadata;
        }
        return null;
      }
      /**
       * set appMetadata entity to the platform cache
       * @param appMetadata - cache value to be set of type AppMetadataEntity
       */
      setAppMetadata(appMetadata) {
        const appMetadataKey = appMetadata.generateAppMetadataKey();
        this.setItem(appMetadataKey, appMetadata);
      }
      /**
       * fetch server telemetry entity from the platform cache
       * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity
       */
      getServerTelemetry(serverTelemetrykey) {
        const serverTelemetryEntity = this.getItem(serverTelemetrykey);
        if (serverTelemetryEntity && ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {
          return serverTelemetryEntity;
        }
        return null;
      }
      /**
       * set server telemetry entity to the platform cache
       * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity
       * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity
       */
      setServerTelemetry(serverTelemetryKey, serverTelemetry) {
        this.setItem(serverTelemetryKey, serverTelemetry);
      }
      /**
       * fetch authority metadata entity from the platform cache
       * @param key - lookup key to fetch cache type AuthorityMetadataEntity
       */
      getAuthorityMetadata(key) {
        const authorityMetadataEntity = this.getItem(key);
        if (authorityMetadataEntity && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, authorityMetadataEntity)) {
          return authorityMetadataEntity;
        }
        return null;
      }
      /**
       * Get all authority metadata keys
       */
      getAuthorityMetadataKeys() {
        return this.getKeys().filter((key) => {
          return this.isAuthorityMetadata(key);
        });
      }
      /**
       * set authority metadata entity to the platform cache
       * @param key - lookup key to fetch cache type AuthorityMetadataEntity
       * @param metadata - cache value to be set of type AuthorityMetadataEntity
       */
      setAuthorityMetadata(key, metadata) {
        this.setItem(key, metadata);
      }
      /**
       * fetch throttling entity from the platform cache
       * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
       */
      getThrottlingCache(throttlingCacheKey) {
        const throttlingCache = this.getItem(throttlingCacheKey);
        if (throttlingCache && ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {
          return throttlingCache;
        }
        return null;
      }
      /**
       * set throttling entity to the platform cache
       * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
       * @param throttlingCache - cache value to be set of type ThrottlingEntity
       */
      setThrottlingCache(throttlingCacheKey, throttlingCache) {
        this.setItem(throttlingCacheKey, throttlingCache);
      }
      /**
       * Removes the cache item from memory with the given key.
       * @param key - lookup key to remove a cache entity
       * @param inMemory - key value map of the cache
       */
      removeItem(key) {
        this.logger.tracePii(`Item key: ${key}`);
        let result = false;
        const cache = this.getCache();
        if (!!cache[key]) {
          delete cache[key];
          result = true;
        }
        if (result) {
          this.setCache(cache);
          this.emitChange();
        }
        return result;
      }
      /**
       * Checks whether key is in cache.
       * @param key - look up key for a cache entity
       */
      containsKey(key) {
        return this.getKeys().includes(key);
      }
      /**
       * Gets all keys in window.
       */
      getKeys() {
        this.logger.trace("Retrieving all cache keys");
        const cache = this.getCache();
        return [...Object.keys(cache)];
      }
      /**
       * Clears all cache entries created by MSAL (except tokens).
       */
      async clear() {
        this.logger.trace("Clearing cache entries created by MSAL");
        const cacheKeys = this.getKeys();
        cacheKeys.forEach((key) => {
          this.removeItem(key);
        });
        this.emitChange();
      }
      /**
       * Initialize in memory cache from an exisiting cache vault
       * @param cache - blob formatted cache (JSON)
       */
      static generateInMemoryCache(cache) {
        return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache));
      }
      /**
       * retrieves the final JSON
       * @param inMemoryCache - itemised cache read from the JSON
       */
      static generateJsonCache(inMemoryCache) {
        return Serializer.serializeAllCache(inMemoryCache);
      }
      /**
       * Updates a credential's cache key if the current cache key is outdated
       */
      updateCredentialCacheKey(currentCacheKey, credential) {
        const updatedCacheKey = credential.generateCredentialKey();
        if (currentCacheKey !== updatedCacheKey) {
          const cacheItem = this.getItem(currentCacheKey);
          if (cacheItem) {
            this.removeItem(currentCacheKey);
            this.setItem(updatedCacheKey, cacheItem);
            this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);
            return updatedCacheKey;
          } else {
            this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);
          }
        }
        return currentCacheKey;
      }
    };
    defaultSerializedCache = {
      Account: {},
      IdToken: {},
      AccessToken: {},
      RefreshToken: {},
      AppMetadata: {}
    };
    TokenCache = class {
      constructor(storage, logger25, cachePlugin) {
        this.cacheHasChanged = false;
        this.storage = storage;
        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));
        if (cachePlugin) {
          this.persistence = cachePlugin;
        }
        this.logger = logger25;
      }
      /**
       * Set to true if cache state has changed since last time serialize or writeToPersistence was called
       */
      hasChanged() {
        return this.cacheHasChanged;
      }
      /**
       * Serializes in memory cache to JSON
       */
      serialize() {
        this.logger.trace("Serializing in-memory cache");
        let finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache());
        if (!StringUtils.isEmpty(this.cacheSnapshot)) {
          this.logger.trace("Reading cache snapshot from disk");
          finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);
        } else {
          this.logger.trace("No cache snapshot to merge");
        }
        this.cacheHasChanged = false;
        return JSON.stringify(finalState);
      }
      /**
       * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format
       * @param cache - blob formatted cache
       */
      deserialize(cache) {
        this.logger.trace("Deserializing JSON to in-memory cache");
        this.cacheSnapshot = cache;
        if (!StringUtils.isEmpty(this.cacheSnapshot)) {
          this.logger.trace("Reading cache snapshot from disk");
          const deserializedCache = Deserializer.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));
          this.storage.setInMemoryCache(deserializedCache);
        } else {
          this.logger.trace("No cache snapshot to deserialize");
        }
      }
      /**
       * Fetches the cache key-value map
       */
      getKVStore() {
        return this.storage.getCache();
      }
      /**
       * API that retrieves all accounts currently in cache to the user
       */
      async getAllAccounts() {
        this.logger.trace("getAllAccounts called");
        let cacheContext;
        try {
          if (this.persistence) {
            cacheContext = new TokenCacheContext(this, false);
            await this.persistence.beforeCacheAccess(cacheContext);
          }
          return this.storage.getAllAccounts();
        } finally {
          if (this.persistence && cacheContext) {
            await this.persistence.afterCacheAccess(cacheContext);
          }
        }
      }
      /**
       * Returns the signed in account matching homeAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param homeAccountId - unique identifier for an account (uid.utid)
       */
      async getAccountByHomeId(homeAccountId) {
        const allAccounts = await this.getAllAccounts();
        if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {
          return allAccounts.filter((accountObj) => accountObj.homeAccountId === homeAccountId)[0] || null;
        } else {
          return null;
        }
      }
      /**
       * Returns the signed in account matching localAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)
       */
      async getAccountByLocalId(localAccountId) {
        const allAccounts = await this.getAllAccounts();
        if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {
          return allAccounts.filter((accountObj) => accountObj.localAccountId === localAccountId)[0] || null;
        } else {
          return null;
        }
      }
      /**
       * API to remove a specific account and the relevant data from cache
       * @param account - AccountInfo passed by the user
       */
      async removeAccount(account) {
        this.logger.trace("removeAccount called");
        let cacheContext;
        try {
          if (this.persistence) {
            cacheContext = new TokenCacheContext(this, true);
            await this.persistence.beforeCacheAccess(cacheContext);
          }
          await this.storage.removeAccount(AccountEntity.generateAccountCacheKey(account));
        } finally {
          if (this.persistence && cacheContext) {
            await this.persistence.afterCacheAccess(cacheContext);
          }
        }
      }
      /**
       * Called when the cache has changed state.
       */
      handleChangeEvent() {
        this.cacheHasChanged = true;
      }
      /**
       * Merge in memory cache with the cache snapshot.
       * @param oldState - cache before changes
       * @param currentState - current cache state in the library
       */
      mergeState(oldState, currentState) {
        this.logger.trace("Merging in-memory cache with cache snapshot");
        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);
        return this.mergeUpdates(stateAfterRemoval, currentState);
      }
      /**
       * Deep update of oldState based on newState values
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeUpdates(oldState, newState) {
        Object.keys(newState).forEach((newKey) => {
          const newValue = newState[newKey];
          if (!oldState.hasOwnProperty(newKey)) {
            if (newValue !== null) {
              oldState[newKey] = newValue;
            }
          } else {
            const newValueNotNull = newValue !== null;
            const newValueIsObject = typeof newValue === "object";
            const newValueIsNotArray = !Array.isArray(newValue);
            const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== "undefined" && oldState[newKey] !== null;
            if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {
              this.mergeUpdates(oldState[newKey], newValue);
            } else {
              oldState[newKey] = newValue;
            }
          }
        });
        return oldState;
      }
      /**
       * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of
       * oldState that are not recognized, they are left untouched.
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeRemovals(oldState, newState) {
        this.logger.trace("Remove updated entries in cache");
        const accounts = oldState.Account ? this.mergeRemovalsDict(oldState.Account, newState.Account) : oldState.Account;
        const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;
        const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;
        const idTokens = oldState.IdToken ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken) : oldState.IdToken;
        const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;
        return {
          ...oldState,
          Account: accounts,
          AccessToken: accessTokens,
          RefreshToken: refreshTokens,
          IdToken: idTokens,
          AppMetadata: appMetadata
        };
      }
      /**
       * Helper to merge new cache with the old one
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeRemovalsDict(oldState, newState) {
        const finalState = {
          ...oldState
        };
        Object.keys(oldState).forEach((oldKey) => {
          if (!newState || !newState.hasOwnProperty(oldKey)) {
            delete finalState[oldKey];
          }
        });
        return finalState;
      }
      /**
       * Helper to overlay as a part of cache merge
       * @param passedInCache - cache read from the blob
       */
      overlayDefaults(passedInCache) {
        this.logger.trace("Overlaying input cache with the default cache");
        return {
          Account: {
            ...defaultSerializedCache.Account,
            ...passedInCache.Account
          },
          IdToken: {
            ...defaultSerializedCache.IdToken,
            ...passedInCache.IdToken
          },
          AccessToken: {
            ...defaultSerializedCache.AccessToken,
            ...passedInCache.AccessToken
          },
          RefreshToken: {
            ...defaultSerializedCache.RefreshToken,
            ...passedInCache.RefreshToken
          },
          AppMetadata: {
            ...defaultSerializedCache.AppMetadata,
            ...passedInCache.AppMetadata
          }
        };
      }
    };
    name2 = "@azure/msal-node";
    version2 = "1.14.2";
    NodeAuthErrorMessage = {
      invalidLoopbackAddressType: {
        code: "invalid_loopback_server_address_type",
        desc: "Loopback server address is not type string. This is unexpected."
      },
      unableToLoadRedirectUri: {
        code: "unable_to_load_redirectUrl",
        desc: "Loopback server callback was invoked without a url. This is unexpected."
      },
      noAuthCodeInResponse: {
        code: "no_auth_code_in_response",
        desc: "No auth code found in the server response. Please check your network trace to determine what happened."
      },
      noLoopbackServerExists: {
        code: "no_loopback_server_exists",
        desc: "No loopback server exists yet."
      },
      loopbackServerAlreadyExists: {
        code: "loopback_server_already_exists",
        desc: "Loopback server already exists. Cannot create another."
      },
      loopbackServerTimeout: {
        code: "loopback_server_timeout",
        desc: "Timed out waiting for auth code listener to be registered."
      },
      stateNotFoundError: {
        code: "state_not_found",
        desc: "State not found. Please verify that the request originated from msal."
      }
    };
    NodeAuthError = class _NodeAuthError extends AuthError {
      constructor(errorCode, errorMessage) {
        super(errorCode, errorMessage);
        this.name = "NodeAuthError";
      }
      /**
       * Creates an error thrown if loopback server address is of type string.
       */
      static createInvalidLoopbackAddressTypeError() {
        return new _NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code, `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);
      }
      /**
       * Creates an error thrown if the loopback server is unable to get a url.
       */
      static createUnableToLoadRedirectUrlError() {
        return new _NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code, `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);
      }
      /**
       * Creates an error thrown if the server response does not contain an auth code.
       */
      static createNoAuthCodeInResponseError() {
        return new _NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code, `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);
      }
      /**
       * Creates an error thrown if the loopback server has not been spun up yet.
       */
      static createNoLoopbackServerExistsError() {
        return new _NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code, `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);
      }
      /**
       * Creates an error thrown if a loopback server already exists when attempting to create another one.
       */
      static createLoopbackServerAlreadyExistsError() {
        return new _NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code, `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);
      }
      /**
       * Creates an error thrown if the loopback server times out registering the auth code listener.
       */
      static createLoopbackServerTimeoutError() {
        return new _NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code, `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);
      }
      /**
       * Creates an error thrown when the state is not present.
       */
      static createStateNotFoundError() {
        return new _NodeAuthError(NodeAuthErrorMessage.stateNotFoundError.code, NodeAuthErrorMessage.stateNotFoundError.desc);
      }
    };
    ClientApplication = class {
      /**
       * Constructor for the ClientApplication
       */
      constructor(configuration) {
        this.config = buildAppConfiguration(configuration);
        this.cryptoProvider = new CryptoProvider();
        this.logger = new Logger(this.config.system.loggerOptions, name2, version2);
        this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider);
        this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);
      }
      /**
       * Creates the URL of the authorization request, letting the user input credentials and consent to the
       * application. The URL targets the /authorize endpoint of the authority configured in the
       * application object.
       *
       * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI
       * sent in the request and should contain an authorization code, which can then be used to acquire tokens via
       * `acquireTokenByCode(AuthorizationCodeRequest)`.
       */
      async getAuthCodeUrl(request3) {
        this.logger.info("getAuthCodeUrl called", request3.correlationId);
        const validRequest = {
          ...request3,
          ...await this.initializeBaseRequest(request3),
          responseMode: request3.responseMode || ResponseMode.QUERY,
          authenticationScheme: AuthenticationScheme.BEARER
        };
        const authClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, void 0, void 0, request3.azureCloudOptions);
        const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
        this.logger.verbose("Auth code client created", validRequest.correlationId);
        return authorizationCodeClient.getAuthCodeUrl(validRequest);
      }
      /**
       * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0
       * Authorization Code flow.
       *
       * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0
       * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and
       * AuthorizationCodeRequest are the same.
       */
      async acquireTokenByCode(request3, authCodePayLoad) {
        this.logger.info("acquireTokenByCode called");
        if (request3.state && authCodePayLoad) {
          this.logger.info("acquireTokenByCode - validating state");
          this.validateState(request3.state, authCodePayLoad.state || "");
          authCodePayLoad = {
            ...authCodePayLoad,
            state: ""
          };
        }
        const validRequest = {
          ...request3,
          ...await this.initializeBaseRequest(request3),
          authenticationScheme: AuthenticationScheme.BEARER
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);
        try {
          const authClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request3.azureCloudOptions);
          const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
          this.logger.verbose("Auth code client created", validRequest.correlationId);
          return authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token by exchanging the refresh token provided for a new set of tokens.
       *
       * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is
       * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will
       * handle the caching and refreshing of tokens automatically.
       */
      async acquireTokenByRefreshToken(request3) {
        this.logger.info("acquireTokenByRefreshToken called", request3.correlationId);
        const validRequest = {
          ...request3,
          ...await this.initializeBaseRequest(request3),
          authenticationScheme: AuthenticationScheme.BEARER
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);
        try {
          const refreshTokenClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request3.azureCloudOptions);
          const refreshTokenClient = new RefreshTokenClient(refreshTokenClientConfig);
          this.logger.verbose("Refresh token client created", validRequest.correlationId);
          return refreshTokenClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token silently when a user specifies the account the token is requested for.
       *
       * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.
       * There is also an optional "forceRefresh" boolean the user can send to bypass the cache for access_token and id_token.
       * In case the refresh_token is expired or not found, an error is thrown
       * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).
       */
      async acquireTokenSilent(request3) {
        const validRequest = {
          ...request3,
          ...await this.initializeBaseRequest(request3),
          forceRefresh: request3.forceRefresh || false
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);
        try {
          const silentFlowClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request3.azureCloudOptions);
          const silentFlowClient = new SilentFlowClient(silentFlowClientConfig);
          this.logger.verbose("Silent flow client created", validRequest.correlationId);
          return silentFlowClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires tokens with password grant by exchanging client applications username and password for credentials
       *
       * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.
       * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4
       * Microsoft's documentation and recommendations are at:
       * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword
       *
       * @param request - UsenamePasswordRequest
       */
      async acquireTokenByUsernamePassword(request3) {
        this.logger.info("acquireTokenByUsernamePassword called", request3.correlationId);
        const validRequest = {
          ...request3,
          ...await this.initializeBaseRequest(request3)
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);
        try {
          const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request3.azureCloudOptions);
          const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);
          this.logger.verbose("Username password client created", validRequest.correlationId);
          return usernamePasswordClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Gets the token cache for the application.
       */
      getTokenCache() {
        this.logger.info("getTokenCache called");
        return this.tokenCache;
      }
      /**
       * Validates OIDC state by comparing the user cached state with the state received from the server.
       *
       * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against
       * CSRF attacks.
       * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.
       * @param state
       * @param cachedState
       */
      validateState(state, cachedState) {
        if (!state) {
          throw NodeAuthError.createStateNotFoundError();
        }
        if (state !== cachedState) {
          throw ClientAuthError.createStateMismatchError();
        }
      }
      /**
       * Returns the logger instance
       */
      getLogger() {
        return this.logger;
      }
      /**
       * Replaces the default logger set in configurations with new Logger with new configurations
       * @param logger - Logger instance
       */
      setLogger(logger25) {
        this.logger = logger25;
      }
      /**
       * Builds the common configuration to be passed to the common component based on the platform configurarion
       * @param authority - user passed authority in configuration
       * @param serverTelemetryManager - initializes servertelemetry if passed
       */
      async buildOauthClientConfiguration(authority, requestCorrelationId, serverTelemetryManager, azureRegionConfiguration, azureCloudOptions) {
        this.logger.verbose("buildOauthClientConfiguration called", requestCorrelationId);
        const userAzureCloudOptions = azureCloudOptions ? azureCloudOptions : this.config.auth.azureCloudOptions;
        this.logger.verbose(`building oauth client configuration with the authority: ${authority}`, requestCorrelationId);
        const discoveredAuthority = await this.createAuthority(authority, azureRegionConfiguration, requestCorrelationId, userAzureCloudOptions);
        serverTelemetryManager == null ? void 0 : serverTelemetryManager.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);
        const clientConfiguration = {
          authOptions: {
            clientId: this.config.auth.clientId,
            authority: discoveredAuthority,
            clientCapabilities: this.config.auth.clientCapabilities
          },
          systemOptions: {
            proxyUrl: this.config.system.proxyUrl
          },
          loggerOptions: {
            logLevel: this.config.system.loggerOptions.logLevel,
            loggerCallback: this.config.system.loggerOptions.loggerCallback,
            piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,
            correlationId: requestCorrelationId
          },
          cryptoInterface: this.cryptoProvider,
          networkInterface: this.config.system.networkClient,
          storageInterface: this.storage,
          serverTelemetryManager,
          clientCredentials: {
            clientSecret: this.clientSecret,
            clientAssertion: this.clientAssertion ? this.getClientAssertion(discoveredAuthority) : void 0
          },
          libraryInfo: {
            sku: Constants2.MSAL_SKU,
            version: version2,
            cpu: process.arch || Constants.EMPTY_STRING,
            os: process.platform || Constants.EMPTY_STRING
          },
          telemetry: this.config.telemetry,
          persistencePlugin: this.config.cache.cachePlugin,
          serializableCache: this.tokenCache
        };
        return clientConfiguration;
      }
      getClientAssertion(authority) {
        return {
          assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),
          assertionType: Constants2.JWT_BEARER_ASSERTION_TYPE
        };
      }
      /**
       * Generates a request with the default scopes & generates a correlationId.
       * @param authRequest - BaseAuthRequest for initialization
       */
      async initializeBaseRequest(authRequest) {
        this.logger.verbose("initializeRequestScopes called", authRequest.correlationId);
        if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {
          this.logger.verbose("Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request", authRequest.correlationId);
        }
        authRequest.authenticationScheme = AuthenticationScheme.BEARER;
        if (authRequest.claims && !StringUtils.isEmpty(authRequest.claims)) {
          authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(authRequest.claims);
        }
        return {
          ...authRequest,
          scopes: [...authRequest && authRequest.scopes || [], ...OIDC_DEFAULT_SCOPES],
          correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),
          authority: authRequest.authority || this.config.auth.authority
        };
      }
      /**
       * Initializes the server telemetry payload
       * @param apiId - Id for a specific request
       * @param correlationId - GUID
       * @param forceRefresh - boolean to indicate network call
       */
      initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {
        const telemetryPayload = {
          clientId: this.config.auth.clientId,
          correlationId,
          apiId,
          forceRefresh: forceRefresh || false
        };
        return new ServerTelemetryManager(telemetryPayload, this.storage);
      }
      /**
       * Create authority instance. If authority not passed in request, default to authority set on the application
       * object. If no authority set in application object, then default to common authority.
       * @param authorityString - authority from user configuration
       */
      async createAuthority(authorityString, azureRegionConfiguration, requestCorrelationId, azureCloudOptions) {
        this.logger.verbose("createAuthority called", requestCorrelationId);
        const authorityUrl = Authority.generateAuthority(authorityString, azureCloudOptions);
        const authorityOptions = {
          protocolMode: this.config.auth.protocolMode,
          knownAuthorities: this.config.auth.knownAuthorities,
          cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
          authorityMetadata: this.config.auth.authorityMetadata,
          azureRegionConfiguration,
          skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
        };
        return await AuthorityFactory.createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.config.system.proxyUrl);
      }
      /**
       * Clear the cache
       */
      clearCache() {
        this.storage.clear();
      }
    };
    LoopbackClient = class {
      /**
       * Spins up a loopback server which returns the server response when the localhost redirectUri is hit
       * @param successTemplate
       * @param errorTemplate
       * @returns
       */
      async listenForAuthCode(successTemplate, errorTemplate) {
        if (!!this.server) {
          throw NodeAuthError.createLoopbackServerAlreadyExistsError();
        }
        const authCodeListener = new Promise((resolve, reject) => {
          this.server = (0, import_http.createServer)(async (req, res) => {
            const url = req.url;
            if (!url) {
              res.end(errorTemplate || "Error occurred loading redirectUrl");
              reject(NodeAuthError.createUnableToLoadRedirectUrlError());
              return;
            } else if (url === Constants.FORWARD_SLASH) {
              res.end(successTemplate || "Auth code was successfully acquired. You can close this window now.");
              return;
            }
            const authCodeResponse = UrlString.getDeserializedQueryString(url);
            if (authCodeResponse.code) {
              const redirectUri = await this.getRedirectUri();
              res.writeHead(HttpStatus.REDIRECT, {
                location: redirectUri
              });
              res.end();
            }
            resolve(authCodeResponse);
          });
          this.server.listen(0);
        });
        await new Promise((resolve) => {
          let ticks = 0;
          const id = setInterval(() => {
            if (LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS / LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS < ticks) {
              throw NodeAuthError.createLoopbackServerTimeoutError();
            }
            if (this.server.listening) {
              clearInterval(id);
              resolve();
            }
            ticks++;
          }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);
        });
        return authCodeListener;
      }
      /**
       * Get the port that the loopback server is running on
       * @returns
       */
      getRedirectUri() {
        if (!this.server) {
          throw NodeAuthError.createNoLoopbackServerExistsError();
        }
        const address = this.server.address();
        if (!address || typeof address === "string" || !address.port) {
          this.closeServer();
          throw NodeAuthError.createInvalidLoopbackAddressTypeError();
        }
        const port = address && address.port;
        return `${Constants2.HTTP_PROTOCOL}${Constants2.LOCALHOST}:${port}`;
      }
      /**
       * Close the loopback server
       */
      closeServer() {
        if (!!this.server) {
          this.server.close();
        }
      }
    };
    PublicClientApplication = class extends ClientApplication {
      /**
       * Important attributes in the Configuration object for auth are:
       * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.
       * - authority: the authority URL for your application.
       *
       * AAD authorities are of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
       * - If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
       * - If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
       * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
       * - To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
       *
       * Azure B2C authorities are of the form https://\{instance\}/\{tenant\}/\{policy\}. Each policy is considered
       * its own authority. You will have to set the all of the knownAuthorities at the time of the client application
       * construction.
       *
       * ADFS authorities are of the form https://\{instance\}/adfs.
       */
      constructor(configuration) {
        super(configuration);
      }
      /**
       * Acquires a token from the authority using OAuth2.0 device code flow.
       * This flow is designed for devices that do not have access to a browser or have input constraints.
       * The authorization server issues a DeviceCode object with a verification code, an end-user code,
       * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be
       * instructed to use another device to navigate to the verification URI to input credentials.
       * Since the client cannot receive incoming requests, it polls the authorization server repeatedly
       * until the end-user completes input of credentials.
       */
      async acquireTokenByDeviceCode(request3) {
        this.logger.info("acquireTokenByDeviceCode called", request3.correlationId);
        const validRequest = Object.assign(request3, await this.initializeBaseRequest(request3));
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);
        try {
          const deviceCodeConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request3.azureCloudOptions);
          const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);
          this.logger.verbose("Device code client created", validRequest.correlationId);
          return deviceCodeClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token by requesting an Authorization code then exchanging it for a token.
       */
      async acquireTokenInteractive(request3) {
        const {
          verifier,
          challenge
        } = await this.cryptoProvider.generatePkceCodes();
        const {
          openBrowser,
          successTemplate,
          errorTemplate,
          ...remainingProperties
        } = request3;
        const loopbackClient = new LoopbackClient();
        const authCodeListener = loopbackClient.listenForAuthCode(successTemplate, errorTemplate);
        const redirectUri = loopbackClient.getRedirectUri();
        const validRequest = {
          ...remainingProperties,
          scopes: request3.scopes || [],
          redirectUri,
          responseMode: ResponseMode.QUERY,
          codeChallenge: challenge,
          codeChallengeMethod: CodeChallengeMethodValues.S256
        };
        const authCodeUrl = await this.getAuthCodeUrl(validRequest);
        await openBrowser(authCodeUrl);
        const authCodeResponse = await authCodeListener.finally(() => {
          loopbackClient.closeServer();
        });
        if (authCodeResponse.error) {
          throw new ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);
        } else if (!authCodeResponse.code) {
          throw NodeAuthError.createNoAuthCodeInResponseError();
        }
        const clientInfo = authCodeResponse.client_info;
        const tokenRequest = {
          code: authCodeResponse.code,
          scopes: OIDC_DEFAULT_SCOPES,
          redirectUri: validRequest.redirectUri,
          codeVerifier: verifier,
          clientInfo: clientInfo || Constants.EMPTY_STRING
        };
        return this.acquireTokenByCode(tokenRequest);
      }
    };
    ClientAssertion = class _ClientAssertion {
      /**
       * Initialize the ClientAssertion class from the clientAssertion passed by the user
       * @param assertion - refer https://tools.ietf.org/html/rfc7521
       */
      static fromAssertion(assertion) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.jwt = assertion;
        return clientAssertion;
      }
      /**
       * Initialize the ClientAssertion class from the certificate passed by the user
       * @param thumbprint - identifier of a certificate
       * @param privateKey - secret key
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static fromCertificate(thumbprint, privateKey, publicCertificate) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.privateKey = privateKey;
        clientAssertion.thumbprint = thumbprint;
        if (publicCertificate) {
          clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
        }
        return clientAssertion;
      }
      /**
       * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is
       * @param cryptoProvider - library's crypto helper
       * @param issuer - iss claim
       * @param jwtAudience - aud claim
       */
      getJwt(cryptoProvider, issuer, jwtAudience) {
        if (this.privateKey && this.thumbprint) {
          if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {
            return this.jwt;
          }
          return this.createJwt(cryptoProvider, issuer, jwtAudience);
        }
        if (this.jwt) {
          return this.jwt;
        }
        throw ClientAuthError.createInvalidAssertionError();
      }
      /**
       * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3
       */
      createJwt(cryptoProvider, issuer, jwtAudience) {
        this.issuer = issuer;
        this.jwtAudience = jwtAudience;
        const issuedAt = TimeUtils.nowSeconds();
        this.expirationTime = issuedAt + 600;
        const header = {
          alg: JwtConstants.RSA_256,
          x5t: EncodingUtils.base64EncodeUrl(this.thumbprint, "hex")
        };
        if (this.publicCertificate) {
          Object.assign(header, {
            x5c: this.publicCertificate
          });
        }
        const payload = {
          [JwtConstants.AUDIENCE]: this.jwtAudience,
          [JwtConstants.EXPIRATION_TIME]: this.expirationTime,
          [JwtConstants.ISSUER]: this.issuer,
          [JwtConstants.SUBJECT]: this.issuer,
          [JwtConstants.NOT_BEFORE]: issuedAt,
          [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()
        };
        this.jwt = (0, import_jsonwebtoken.sign)(payload, this.privateKey, {
          header
        });
        return this.jwt;
      }
      /**
       * Utility API to check expiration
       */
      isExpired() {
        return this.expirationTime < TimeUtils.nowSeconds();
      }
      /**
       * Extracts the raw certs from a given certificate string and returns them in an array.
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static parseCertificate(publicCertificate) {
        const regexToFindCerts = /-----BEGIN CERTIFICATE-----\r*\n(.+?)\r*\n-----END CERTIFICATE-----/gs;
        const certs = [];
        let matches;
        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {
          certs.push(matches[1].replace(/\r*\n/g, Constants.EMPTY_STRING));
        }
        return certs;
      }
    };
    ConfidentialClientApplication = class extends ClientApplication {
      /**
       * Constructor for the ConfidentialClientApplication
       *
       * Required attributes in the Configuration object are:
       * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal
       * - authority: the authority URL for your application.
       * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.
       *
       * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
       * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
       * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
       * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
       * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
       *
       * In Azure B2C, authority is of the form https://\{instance\}/tfp/\{tenant\}/\{policyName\}/
       * Full B2C functionality will be available in this library in future versions.
       *
       * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance
       */
      constructor(configuration) {
        super(configuration);
        this.setClientCredential(this.config);
        this.appTokenProvider = void 0;
      }
      /**
       * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and
       * is meant for Azure SDK to enhance Managed Identity support.
       *
       * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.
       */
      SetAppTokenProvider(provider) {
        this.appTokenProvider = provider;
      }
      /**
       * Acquires tokens from the authority for the application (not for an end user).
       */
      async acquireTokenByClientCredential(request3) {
        this.logger.info("acquireTokenByClientCredential called", request3.correlationId);
        let clientAssertion;
        if (request3.clientAssertion) {
          clientAssertion = {
            assertion: request3.clientAssertion,
            assertionType: Constants2.JWT_BEARER_ASSERTION_TYPE
          };
        }
        const baseRequest = await this.initializeBaseRequest(request3);
        const validBaseRequest = {
          ...baseRequest,
          scopes: baseRequest.scopes.filter((scope) => !OIDC_DEFAULT_SCOPES.includes(scope))
        };
        const validRequest = {
          ...request3,
          ...validBaseRequest,
          clientAssertion
        };
        const azureRegionConfiguration = {
          azureRegion: validRequest.azureRegion,
          environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE]
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);
        try {
          const clientCredentialConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, azureRegionConfiguration, request3.azureCloudOptions);
          const clientCredentialClient = new ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);
          this.logger.verbose("Client credential client created", validRequest.correlationId);
          return clientCredentialClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires tokens from the authority for the application.
       *
       * Used in scenarios where the current app is a middle-tier service which was called with a token
       * representing an end user. The current app can use the token (oboAssertion) to request another
       * token to access downstream web API, on behalf of that user.
       *
       * The current middle-tier app has no user interaction to obtain consent.
       * See how to gain consent upfront for your middle-tier app from this article.
       * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application
       */
      async acquireTokenOnBehalfOf(request3) {
        this.logger.info("acquireTokenOnBehalfOf called", request3.correlationId);
        const validRequest = {
          ...request3,
          ...await this.initializeBaseRequest(request3)
        };
        try {
          const onBehalfOfConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, void 0, void 0, request3.azureCloudOptions);
          const oboClient = new OnBehalfOfClient(onBehalfOfConfig);
          this.logger.verbose("On behalf of client created", validRequest.correlationId);
          return oboClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          throw e;
        }
      }
      setClientCredential(configuration) {
        const clientSecretNotEmpty = !StringUtils.isEmpty(configuration.auth.clientSecret);
        const clientAssertionNotEmpty = !StringUtils.isEmpty(configuration.auth.clientAssertion);
        const certificate = configuration.auth.clientCertificate || {
          thumbprint: Constants.EMPTY_STRING,
          privateKey: Constants.EMPTY_STRING
        };
        const certificateNotEmpty = !StringUtils.isEmpty(certificate.thumbprint) || !StringUtils.isEmpty(certificate.privateKey);
        if (this.appTokenProvider) {
          return;
        }
        if (clientSecretNotEmpty && clientAssertionNotEmpty || clientAssertionNotEmpty && certificateNotEmpty || clientSecretNotEmpty && certificateNotEmpty) {
          throw ClientAuthError.createInvalidCredentialError();
        }
        if (configuration.auth.clientSecret) {
          this.clientSecret = configuration.auth.clientSecret;
          return;
        }
        if (configuration.auth.clientAssertion) {
          this.clientAssertion = ClientAssertion.fromAssertion(configuration.auth.clientAssertion);
          return;
        }
        if (!certificateNotEmpty) {
          throw ClientAuthError.createInvalidCredentialError();
        } else {
          var _configuration$auth$c;
          this.clientAssertion = ClientAssertion.fromCertificate(certificate.thumbprint, certificate.privateKey, (_configuration$auth$c = configuration.auth.clientCertificate) == null ? void 0 : _configuration$auth$c.x5c);
        }
      }
    };
  }
});
var XML_ATTRKEY, XML_CHARKEY;
var init_interfaces = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/interfaces.js"() {
    "use strict";
    XML_ATTRKEY = "$";
    XML_CHARKEY = "_";
  }
});
function isPrimitiveBody(value, mapperTypeName) {
  return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === void 0 || value === null);
}
function handleNullableResponseAndWrappableBody(responseObject) {
  const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
    return responseObject.shouldWrapBody ? { body: null } : null;
  } else {
    return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;
  }
}
function flattenResponse(fullResponse, responseSpec) {
  var _a2, _b;
  const parsedHeaders = fullResponse.parsedHeaders;
  if (fullResponse.request.method === "HEAD") {
    return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });
  }
  const bodyMapper = responseSpec && responseSpec.bodyMapper;
  const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);
  const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;
  if (expectedBodyTypeName === "Stream") {
    return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });
  }
  const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
  const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
  if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
    const arrayResponse = (_a2 = fullResponse.parsedBody) !== null && _a2 !== void 0 ? _a2 : [];
    for (const key of Object.keys(modelProperties)) {
      if (modelProperties[key].serializedName) {
        arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];
      }
    }
    if (parsedHeaders) {
      for (const key of Object.keys(parsedHeaders)) {
        arrayResponse[key] = parsedHeaders[key];
      }
    }
    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
  }
  return handleNullableResponseAndWrappableBody({
    body: fullResponse.parsedBody,
    headers: parsedHeaders,
    hasNullableType: isNullable,
    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
  });
}
var init_utils = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/utils.js"() {
    "use strict";
  }
});
var MapperTypeNames;
var init_serializer = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/serializer.js"() {
    "use strict";
    MapperTypeNames = {
      Base64Url: "Base64Url",
      Boolean: "Boolean",
      ByteArray: "ByteArray",
      Composite: "Composite",
      Date: "Date",
      DateTime: "DateTime",
      DateTimeRfc1123: "DateTimeRfc1123",
      Dictionary: "Dictionary",
      Enum: "Enum",
      Number: "Number",
      Object: "Object",
      Sequence: "Sequence",
      String: "String",
      Stream: "Stream",
      TimeSpan: "TimeSpan",
      UnixTime: "UnixTime"
    };
  }
});
function createEmptyPipeline() {
  return HttpPipeline.create();
}
var ValidPhaseNames, HttpPipeline;
var init_pipeline = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/pipeline.js"() {
    "use strict";
    ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
    HttpPipeline = class _HttpPipeline {
      constructor(policies = []) {
        this._policies = [];
        this._policies = policies;
        this._orderedPolicies = void 0;
      }
      addPolicy(policy, options = {}) {
        if (options.phase && options.afterPhase) {
          throw new Error("Policies inside a phase cannot specify afterPhase.");
        }
        if (options.phase && !ValidPhaseNames.has(options.phase)) {
          throw new Error(`Invalid phase name: ${options.phase}`);
        }
        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
          throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
        }
        this._policies.push({
          policy,
          options
        });
        this._orderedPolicies = void 0;
      }
      removePolicy(options) {
        const removedPolicies = [];
        this._policies = this._policies.filter((policyDescriptor) => {
          if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
            removedPolicies.push(policyDescriptor.policy);
            return false;
          } else {
            return true;
          }
        });
        this._orderedPolicies = void 0;
        return removedPolicies;
      }
      sendRequest(httpClient, request3) {
        const policies = this.getOrderedPolicies();
        const pipeline = policies.reduceRight((next, policy) => {
          return (req) => {
            return policy.sendRequest(req, next);
          };
        }, (req) => httpClient.sendRequest(req));
        return pipeline(request3);
      }
      getOrderedPolicies() {
        if (!this._orderedPolicies) {
          this._orderedPolicies = this.orderPolicies();
        }
        return this._orderedPolicies;
      }
      clone() {
        return new _HttpPipeline(this._policies);
      }
      static create() {
        return new _HttpPipeline();
      }
      orderPolicies() {
        const result = [];
        const policyMap = /* @__PURE__ */ new Map();
        function createPhase(name3) {
          return {
            name: name3,
            policies: /* @__PURE__ */ new Set(),
            hasRun: false,
            hasAfterPolicies: false
          };
        }
        const serializePhase = createPhase("Serialize");
        const noPhase = createPhase("None");
        const deserializePhase = createPhase("Deserialize");
        const retryPhase = createPhase("Retry");
        const signPhase = createPhase("Sign");
        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
        function getPhase(phase) {
          if (phase === "Retry") {
            return retryPhase;
          } else if (phase === "Serialize") {
            return serializePhase;
          } else if (phase === "Deserialize") {
            return deserializePhase;
          } else if (phase === "Sign") {
            return signPhase;
          } else {
            return noPhase;
          }
        }
        for (const descriptor of this._policies) {
          const policy = descriptor.policy;
          const options = descriptor.options;
          const policyName = policy.name;
          if (policyMap.has(policyName)) {
            throw new Error("Duplicate policy names not allowed in pipeline");
          }
          const node = {
            policy,
            dependsOn: /* @__PURE__ */ new Set(),
            dependants: /* @__PURE__ */ new Set()
          };
          if (options.afterPhase) {
            node.afterPhase = getPhase(options.afterPhase);
            node.afterPhase.hasAfterPolicies = true;
          }
          policyMap.set(policyName, node);
          const phase = getPhase(options.phase);
          phase.policies.add(node);
        }
        for (const descriptor of this._policies) {
          const { policy, options } = descriptor;
          const policyName = policy.name;
          const node = policyMap.get(policyName);
          if (!node) {
            throw new Error(`Missing node for policy ${policyName}`);
          }
          if (options.afterPolicies) {
            for (const afterPolicyName of options.afterPolicies) {
              const afterNode = policyMap.get(afterPolicyName);
              if (afterNode) {
                node.dependsOn.add(afterNode);
                afterNode.dependants.add(node);
              }
            }
          }
          if (options.beforePolicies) {
            for (const beforePolicyName of options.beforePolicies) {
              const beforeNode = policyMap.get(beforePolicyName);
              if (beforeNode) {
                beforeNode.dependsOn.add(node);
                node.dependants.add(beforeNode);
              }
            }
          }
        }
        function walkPhase(phase) {
          phase.hasRun = true;
          for (const node of phase.policies) {
            if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
              continue;
            }
            if (node.dependsOn.size === 0) {
              result.push(node.policy);
              for (const dependant of node.dependants) {
                dependant.dependsOn.delete(node);
              }
              policyMap.delete(node.policy.name);
              phase.policies.delete(node);
            }
          }
        }
        function walkPhases() {
          for (const phase of orderedPhases) {
            walkPhase(phase);
            if (phase.policies.size > 0 && phase !== noPhase) {
              if (!noPhase.hasRun) {
                walkPhase(noPhase);
              }
              return;
            }
            if (phase.hasAfterPolicies) {
              walkPhase(noPhase);
            }
          }
        }
        let iteration = 0;
        while (policyMap.size > 0) {
          iteration++;
          const initialResultLength = result.length;
          walkPhases();
          if (result.length <= initialResultLength && iteration > 1) {
            throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
          }
        }
        return result;
      }
    };
  }
});
function log(message, ...args) {
  process.stderr.write(`${import_util.default.format(message, ...args)}${import_os.EOL}`);
}
var init_log = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+logger@1.0.3/node_modules/@azure/logger/dist-esm/src/log.js"() {
    "use strict";
  }
});
function enable(namespaces) {
  enabledString = namespaces;
  enabledNamespaces = [];
  skippedNamespaces = [];
  const wildcard = /\*/g;
  const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
  for (const ns of namespaceList) {
    if (ns.startsWith("-")) {
      skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
    } else {
      enabledNamespaces.push(new RegExp(`^${ns}$`));
    }
  }
  for (const instance of debuggers) {
    instance.enabled = enabled(instance.namespace);
  }
}
function enabled(namespace) {
  if (namespace.endsWith("*")) {
    return true;
  }
  for (const skipped of skippedNamespaces) {
    if (skipped.test(namespace)) {
      return false;
    }
  }
  for (const enabledNamespace of enabledNamespaces) {
    if (enabledNamespace.test(namespace)) {
      return true;
    }
  }
  return false;
}
function disable() {
  const result = enabledString || "";
  enable("");
  return result;
}
function createDebugger(namespace) {
  const newDebugger = Object.assign(debug, {
    enabled: enabled(namespace),
    destroy,
    log: debugObj.log,
    namespace,
    extend
  });
  function debug(...args) {
    if (!newDebugger.enabled) {
      return;
    }
    if (args.length > 0) {
      args[0] = `${namespace} ${args[0]}`;
    }
    newDebugger.log(...args);
  }
  debuggers.push(newDebugger);
  return newDebugger;
}
function destroy() {
  const index = debuggers.indexOf(this);
  if (index >= 0) {
    debuggers.splice(index, 1);
    return true;
  }
  return false;
}
function extend(namespace) {
  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
  newDebugger.log = this.log;
  return newDebugger;
}
var debugEnvVariable, enabledString, enabledNamespaces, skippedNamespaces, debuggers, debugObj, debug_default;
var init_debug = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+logger@1.0.3/node_modules/@azure/logger/dist-esm/src/debug.js"() {
    "use strict";
    init_log();
    debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
    enabledNamespaces = [];
    skippedNamespaces = [];
    debuggers = [];
    if (debugEnvVariable) {
      enable(debugEnvVariable);
    }
    debugObj = Object.assign((namespace) => {
      return createDebugger(namespace);
    }, {
      enable,
      enabled,
      disable,
      log
    });
    debug_default = debugObj;
  }
});
function setLogLevel(level) {
  if (level && !isAzureLogLevel(level)) {
    throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
  }
  azureLogLevel = level;
  const enabledNamespaces2 = [];
  for (const logger25 of registeredLoggers) {
    if (shouldEnable(logger25)) {
      enabledNamespaces2.push(logger25.namespace);
    }
  }
  debug_default.enable(enabledNamespaces2.join(","));
}
function createClientLogger(namespace) {
  const clientRootLogger = AzureLogger.extend(namespace);
  patchLogMethod(AzureLogger, clientRootLogger);
  return {
    error: createLogger(clientRootLogger, "error"),
    warning: createLogger(clientRootLogger, "warning"),
    info: createLogger(clientRootLogger, "info"),
    verbose: createLogger(clientRootLogger, "verbose")
  };
}
function patchLogMethod(parent, child) {
  child.log = (...args) => {
    parent.log(...args);
  };
}
function createLogger(parent, level) {
  const logger25 = Object.assign(parent.extend(level), {
    level
  });
  patchLogMethod(parent, logger25);
  if (shouldEnable(logger25)) {
    const enabledNamespaces2 = debug_default.disable();
    debug_default.enable(enabledNamespaces2 + "," + logger25.namespace);
  }
  registeredLoggers.add(logger25);
  return logger25;
}
function shouldEnable(logger25) {
  if (azureLogLevel && levelMap[logger25.level] <= levelMap[azureLogLevel]) {
    return true;
  } else {
    return false;
  }
}
function isAzureLogLevel(logLevel) {
  return AZURE_LOG_LEVELS.includes(logLevel);
}
var registeredLoggers, logLevelFromEnv, azureLogLevel, AzureLogger, AZURE_LOG_LEVELS, levelMap;
var init_src = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+logger@1.0.3/node_modules/@azure/logger/dist-esm/src/index.js"() {
    "use strict";
    init_debug();
    registeredLoggers = /* @__PURE__ */ new Set();
    logLevelFromEnv = typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL || void 0;
    AzureLogger = debug_default("azure");
    AzureLogger.log = (...args) => {
      debug_default.log(...args);
    };
    AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
    if (logLevelFromEnv) {
      if (isAzureLogLevel(logLevelFromEnv)) {
        setLogLevel(logLevelFromEnv);
      } else {
        console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
      }
    }
    levelMap = {
      verbose: 400,
      info: 300,
      warning: 200,
      error: 100
    };
  }
});
var logger;
var init_log2 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js"() {
    "use strict";
    init_src();
    logger = createClientLogger("core-rest-pipeline");
  }
});
var _a, isNode;
var init_isNode = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-util@1.1.1/node_modules/@azure/core-util/dist-esm/src/isNode.js"() {
    "use strict";
    isNode = typeof process !== "undefined" && Boolean(process.version) && Boolean((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node);
  }
});
function abortSignal(signal) {
  if (signal.aborted) {
    return;
  }
  if (signal.onabort) {
    signal.onabort.call(signal);
  }
  const listeners = listenersMap.get(signal);
  if (listeners) {
    listeners.slice().forEach((listener) => {
      listener.call(signal, { type: "abort" });
    });
  }
  abortedMap.set(signal, true);
}
var listenersMap, abortedMap, AbortSignal;
var init_AbortSignal = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+abort-controller@1.1.0/node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js"() {
    "use strict";
    listenersMap = /* @__PURE__ */ new WeakMap();
    abortedMap = /* @__PURE__ */ new WeakMap();
    AbortSignal = class _AbortSignal {
      constructor() {
        this.onabort = null;
        listenersMap.set(this, []);
        abortedMap.set(this, false);
      }
      /**
       * Status of whether aborted or not.
       *
       * @readonly
       */
      get aborted() {
        if (!abortedMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        return abortedMap.get(this);
      }
      /**
       * Creates a new AbortSignal instance that will never be aborted.
       *
       * @readonly
       */
      static get none() {
        return new _AbortSignal();
      }
      /**
       * Added new "abort" event listener, only support "abort" event.
       *
       * @param _type - Only support "abort" event
       * @param listener - The listener to be added
       */
      addEventListener(_type, listener) {
        if (!listenersMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        listeners.push(listener);
      }
      /**
       * Remove "abort" event listener, only support "abort" event.
       *
       * @param _type - Only support "abort" event
       * @param listener - The listener to be removed
       */
      removeEventListener(_type, listener) {
        if (!listenersMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      }
      /**
       * Dispatches a synthetic event to the AbortSignal.
       */
      dispatchEvent(_event) {
        throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
      }
    };
  }
});
var AbortError, AbortController;
var init_AbortController = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+abort-controller@1.1.0/node_modules/@azure/abort-controller/dist-esm/src/AbortController.js"() {
    "use strict";
    init_AbortSignal();
    AbortError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    AbortController = class {
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      constructor(parentSignals) {
        this._signal = new AbortSignal();
        if (!parentSignals) {
          return;
        }
        if (!Array.isArray(parentSignals)) {
          parentSignals = arguments;
        }
        for (const parentSignal of parentSignals) {
          if (parentSignal.aborted) {
            this.abort();
          } else {
            parentSignal.addEventListener("abort", () => {
              this.abort();
            });
          }
        }
      }
      /**
       * The AbortSignal associated with this controller that will signal aborted
       * when the abort method is called on this controller.
       *
       * @readonly
       */
      get signal() {
        return this._signal;
      }
      /**
       * Signal that any operations passed this controller's associated abort signal
       * to cancel any remaining work and throw an `AbortError`.
       */
      abort() {
        abortSignal(this._signal);
      }
      /**
       * Creates a new AbortSignal instance that will abort after the provided ms.
       * @param ms - Elapsed time in milliseconds to trigger an abort.
       */
      static timeout(ms) {
        const signal = new AbortSignal();
        const timer = setTimeout(abortSignal, ms, signal);
        if (typeof timer.unref === "function") {
          timer.unref();
        }
        return signal;
      }
    };
  }
});
var init_src2 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+abort-controller@1.1.0/node_modules/@azure/abort-controller/dist-esm/src/index.js"() {
    "use strict";
    init_AbortController();
  }
});
function isDefined(thing) {
  return typeof thing !== "undefined" && thing !== null;
}
var init_typeGuards = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-util@1.1.1/node_modules/@azure/core-util/dist-esm/src/typeGuards.js"() {
    "use strict";
  }
});
function delay(timeInMs, options) {
  return new Promise((resolve, reject) => {
    let timer = void 0;
    let onAborted = void 0;
    const rejectOnAbort = () => {
      var _a2;
      return reject(new AbortError((_a2 = options === null || options === void 0 ? void 0 : options.abortErrorMsg) !== null && _a2 !== void 0 ? _a2 : StandardAbortMessage));
    };
    const removeListeners = () => {
      if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
        options.abortSignal.removeEventListener("abort", onAborted);
      }
    };
    onAborted = () => {
      if (isDefined(timer)) {
        clearTimeout(timer);
      }
      removeListeners();
      return rejectOnAbort();
    };
    if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
      return rejectOnAbort();
    }
    timer = setTimeout(() => {
      removeListeners();
      resolve();
    }, timeInMs);
    if (options === null || options === void 0 ? void 0 : options.abortSignal) {
      options.abortSignal.addEventListener("abort", onAborted);
    }
  });
}
var StandardAbortMessage;
var init_delay = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-util@1.1.1/node_modules/@azure/core-util/dist-esm/src/delay.js"() {
    "use strict";
    init_src2();
    init_typeGuards();
    StandardAbortMessage = "The operation was aborted.";
  }
});
function getRandomIntegerInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  const offset = Math.floor(Math.random() * (max - min + 1));
  return offset + min;
}
var init_random = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-util@1.1.1/node_modules/@azure/core-util/dist-esm/src/random.js"() {
    "use strict";
  }
});
function isObject(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}
var init_object = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-util@1.1.1/node_modules/@azure/core-util/dist-esm/src/object.js"() {
    "use strict";
  }
});
function isError(e) {
  if (isObject(e)) {
    const hasName = typeof e.name === "string";
    const hasMessage = typeof e.message === "string";
    return hasName && hasMessage;
  }
  return false;
}
function getErrorMessage(e) {
  if (isError(e)) {
    return e.message;
  } else {
    let stringified;
    try {
      if (typeof e === "object" && e) {
        stringified = JSON.stringify(e);
      } else {
        stringified = String(e);
      }
    } catch (err) {
      stringified = "[unable to stringify input]";
    }
    return `Unknown error ${stringified}`;
  }
}
var init_error = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-util@1.1.1/node_modules/@azure/core-util/dist-esm/src/error.js"() {
    "use strict";
    init_object();
  }
});
var init_src3 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-util@1.1.1/node_modules/@azure/core-util/dist-esm/src/index.js"() {
    "use strict";
    init_isNode();
    init_delay();
    init_random();
    init_object();
    init_error();
  }
});
var RedactedString, defaultAllowedHeaderNames, defaultAllowedQueryParameters, Sanitizer;
var init_sanitizer = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/util/sanitizer.js"() {
    "use strict";
    init_src3();
    RedactedString = "REDACTED";
    defaultAllowedHeaderNames = [
      "x-ms-client-request-id",
      "x-ms-return-client-request-id",
      "x-ms-useragent",
      "x-ms-correlation-request-id",
      "x-ms-request-id",
      "client-request-id",
      "ms-cv",
      "return-client-request-id",
      "traceparent",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Origin",
      "Accept",
      "Accept-Encoding",
      "Cache-Control",
      "Connection",
      "Content-Length",
      "Content-Type",
      "Date",
      "ETag",
      "Expires",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "Last-Modified",
      "Pragma",
      "Request-Id",
      "Retry-After",
      "Server",
      "Transfer-Encoding",
      "User-Agent",
      "WWW-Authenticate"
    ];
    defaultAllowedQueryParameters = ["api-version"];
    Sanitizer = class {
      constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
        allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
        allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
      }
      sanitize(obj) {
        const seen = /* @__PURE__ */ new Set();
        return JSON.stringify(obj, (key, value) => {
          if (value instanceof Error) {
            return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
          }
          if (key === "headers") {
            return this.sanitizeHeaders(value);
          } else if (key === "url") {
            return this.sanitizeUrl(value);
          } else if (key === "query") {
            return this.sanitizeQuery(value);
          } else if (key === "body") {
            return void 0;
          } else if (key === "response") {
            return void 0;
          } else if (key === "operationSpec") {
            return void 0;
          } else if (Array.isArray(value) || isObject(value)) {
            if (seen.has(value)) {
              return "[Circular]";
            }
            seen.add(value);
          }
          return value;
        }, 2);
      }
      sanitizeHeaders(obj) {
        const sanitized = {};
        for (const key of Object.keys(obj)) {
          if (this.allowedHeaderNames.has(key.toLowerCase())) {
            sanitized[key] = obj[key];
          } else {
            sanitized[key] = RedactedString;
          }
        }
        return sanitized;
      }
      sanitizeQuery(value) {
        if (typeof value !== "object" || value === null) {
          return value;
        }
        const sanitized = {};
        for (const k of Object.keys(value)) {
          if (this.allowedQueryParameters.has(k.toLowerCase())) {
            sanitized[k] = value[k];
          } else {
            sanitized[k] = RedactedString;
          }
        }
        return sanitized;
      }
      sanitizeUrl(value) {
        if (typeof value !== "string" || value === null) {
          return value;
        }
        const url = new URL(value);
        if (!url.search) {
          return value;
        }
        for (const [key] of url.searchParams) {
          if (!this.allowedQueryParameters.has(key.toLowerCase())) {
            url.searchParams.set(key, RedactedString);
          }
        }
        return url.toString();
      }
    };
  }
});
function logPolicy(options = {}) {
  var _a2;
  const logger25 = (_a2 = options.logger) !== null && _a2 !== void 0 ? _a2 : logger.info;
  const sanitizer = new Sanitizer({
    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  return {
    name: logPolicyName,
    async sendRequest(request3, next) {
      if (!logger25.enabled) {
        return next(request3);
      }
      logger25(`Request: ${sanitizer.sanitize(request3)}`);
      const response = await next(request3);
      logger25(`Response status code: ${response.status}`);
      logger25(`Headers: ${sanitizer.sanitize(response.headers)}`);
      return response;
    }
  };
}
var logPolicyName;
var init_logPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/logPolicy.js"() {
    "use strict";
    init_log2();
    init_sanitizer();
    logPolicyName = "logPolicy";
  }
});
function redirectPolicy(options = {}) {
  const { maxRetries = 20 } = options;
  return {
    name: redirectPolicyName,
    async sendRequest(request3, next) {
      const response = await next(request3);
      return handleRedirect(next, response, maxRetries);
    }
  };
}
async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
  const { request: request3, status, headers } = response;
  const locationHeader = headers.get("location");
  if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request3.method) || status === 302 && allowedRedirect.includes(request3.method) || status === 303 && request3.method === "POST" || status === 307) && currentRetries < maxRetries) {
    const url = new URL(locationHeader, request3.url);
    request3.url = url.toString();
    if (status === 303) {
      request3.method = "GET";
      request3.headers.delete("Content-Length");
      delete request3.body;
    }
    request3.headers.delete("Authorization");
    const res = await next(request3);
    return handleRedirect(next, res, maxRetries, currentRetries + 1);
  }
  return response;
}
var redirectPolicyName, allowedRedirect;
var init_redirectPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/redirectPolicy.js"() {
    "use strict";
    redirectPolicyName = "redirectPolicy";
    allowedRedirect = ["GET", "HEAD"];
  }
});
function getHeaderName() {
  return "User-Agent";
}
function setPlatformSpecificData(map) {
  map.set("Node", process.version);
  map.set("OS", `(${os.arch()}-${os.type()}-${os.release()})`);
}
var init_userAgentPlatform = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgentPlatform.js"() {
    "use strict";
  }
});
var SDK_VERSION, DEFAULT_RETRY_POLICY_COUNT;
var init_constants = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js"() {
    "use strict";
    SDK_VERSION = "1.9.2";
    DEFAULT_RETRY_POLICY_COUNT = 3;
  }
});
function getUserAgentString(telemetryInfo) {
  const parts = [];
  for (const [key, value] of telemetryInfo) {
    const token = value ? `${key}/${value}` : key;
    parts.push(token);
  }
  return parts.join(" ");
}
function getUserAgentHeaderName() {
  return getHeaderName();
}
function getUserAgentValue(prefix) {
  const runtimeInfo = /* @__PURE__ */ new Map();
  runtimeInfo.set("core-rest-pipeline", SDK_VERSION);
  setPlatformSpecificData(runtimeInfo);
  const defaultAgent = getUserAgentString(runtimeInfo);
  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  return userAgentValue;
}
var init_userAgent = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgent.js"() {
    "use strict";
    init_userAgentPlatform();
    init_constants();
  }
});
function userAgentPolicy(options = {}) {
  const userAgentValue = getUserAgentValue(options.userAgentPrefix);
  return {
    name: userAgentPolicyName,
    async sendRequest(request3, next) {
      if (!request3.headers.has(UserAgentHeaderName)) {
        request3.headers.set(UserAgentHeaderName, userAgentValue);
      }
      return next(request3);
    }
  };
}
var UserAgentHeaderName, userAgentPolicyName;
var init_userAgentPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/userAgentPolicy.js"() {
    "use strict";
    init_userAgent();
    UserAgentHeaderName = getUserAgentHeaderName();
    userAgentPolicyName = "userAgentPolicy";
  }
});
function decompressResponsePolicy() {
  return {
    name: decompressResponsePolicyName,
    async sendRequest(request3, next) {
      if (request3.method !== "HEAD") {
        request3.headers.set("Accept-Encoding", "gzip,deflate");
      }
      return next(request3);
    }
  };
}
var decompressResponsePolicyName;
var init_decompressResponsePolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/decompressResponsePolicy.js"() {
    "use strict";
    decompressResponsePolicyName = "decompressResponsePolicy";
  }
});
function delay2(delayInMs, value, options) {
  return new Promise((resolve, reject) => {
    let timer = void 0;
    let onAborted = void 0;
    const rejectOnAbort = () => {
      return reject(new AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage2));
    };
    const removeListeners = () => {
      if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
        options.abortSignal.removeEventListener("abort", onAborted);
      }
    };
    onAborted = () => {
      if (timer) {
        clearTimeout(timer);
      }
      removeListeners();
      return rejectOnAbort();
    };
    if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
      return rejectOnAbort();
    }
    timer = setTimeout(() => {
      removeListeners();
      resolve(value);
    }, delayInMs);
    if (options === null || options === void 0 ? void 0 : options.abortSignal) {
      options.abortSignal.addEventListener("abort", onAborted);
    }
  });
}
function parseHeaderValueAsNumber(response, headerName) {
  const value = response.headers.get(headerName);
  if (!value)
    return;
  const valueAsNum = Number(value);
  if (Number.isNaN(valueAsNum))
    return;
  return valueAsNum;
}
var StandardAbortMessage2;
var init_helpers = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js"() {
    "use strict";
    init_src2();
    StandardAbortMessage2 = "The operation was aborted.";
  }
});
function getRetryAfterInMs(response) {
  if (!(response && [429, 503].includes(response.status)))
    return void 0;
  try {
    for (const header of AllRetryAfterHeaders) {
      const retryAfterValue = parseHeaderValueAsNumber(response, header);
      if (retryAfterValue === 0 || retryAfterValue) {
        const multiplyingFactor = header === RetryAfterHeader ? 1e3 : 1;
        return retryAfterValue * multiplyingFactor;
      }
    }
    const retryAfterHeader = response.headers.get(RetryAfterHeader);
    if (!retryAfterHeader)
      return;
    const date = Date.parse(retryAfterHeader);
    const diff = date - Date.now();
    return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
  } catch (e) {
    return void 0;
  }
}
function isThrottlingRetryResponse(response) {
  return Number.isFinite(getRetryAfterInMs(response));
}
function throttlingRetryStrategy() {
  return {
    name: "throttlingRetryStrategy",
    retry({ response }) {
      const retryAfterInMs = getRetryAfterInMs(response);
      if (!Number.isFinite(retryAfterInMs)) {
        return { skipStrategy: true };
      }
      return {
        retryAfterInMs
      };
    }
  };
}
var RetryAfterHeader, AllRetryAfterHeaders;
var init_throttlingRetryStrategy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js"() {
    "use strict";
    init_helpers();
    RetryAfterHeader = "Retry-After";
    AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
  }
});
function exponentialRetryStrategy(options = {}) {
  var _a2, _b;
  const retryInterval = (_a2 = options.retryDelayInMs) !== null && _a2 !== void 0 ? _a2 : DEFAULT_CLIENT_RETRY_INTERVAL;
  const maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== void 0 ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
  let retryAfterInMs = retryInterval;
  return {
    name: "exponentialRetryStrategy",
    retry({ retryCount, response, responseError }) {
      const matchedSystemError = isSystemError(responseError);
      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
      const isExponential = isExponentialRetryResponse(response);
      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
        return { skipStrategy: true };
      }
      if (responseError && !matchedSystemError && !isExponential) {
        return { errorToThrow: responseError };
      }
      const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
      const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
      retryAfterInMs = clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);
      return { retryAfterInMs };
    }
  };
}
function isExponentialRetryResponse(response) {
  return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
}
function isSystemError(err) {
  if (!err) {
    return false;
  }
  return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT";
}
var DEFAULT_CLIENT_RETRY_INTERVAL, DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
var init_exponentialRetryStrategy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/exponentialRetryStrategy.js"() {
    "use strict";
    init_src3();
    init_throttlingRetryStrategy();
    DEFAULT_CLIENT_RETRY_INTERVAL = 1e3;
    DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
  }
});
function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {
  const logger25 = options.logger || retryPolicyLogger;
  return {
    name: retryPolicyName,
    async sendRequest(request3, next) {
      var _a2, _b;
      let response;
      let responseError;
      let retryCount = -1;
      retryRequest:
        while (true) {
          retryCount += 1;
          response = void 0;
          responseError = void 0;
          try {
            logger25.info(`Retry ${retryCount}: Attempting to send request`, request3.requestId);
            response = await next(request3);
            logger25.info(`Retry ${retryCount}: Received a response from request`, request3.requestId);
          } catch (e) {
            logger25.error(`Retry ${retryCount}: Received an error from request`, request3.requestId);
            responseError = e;
            if (!e || responseError.name !== "RestError") {
              throw e;
            }
            response = responseError.response;
          }
          if ((_a2 = request3.abortSignal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
            logger25.error(`Retry ${retryCount}: Request aborted.`);
            const abortError = new AbortError();
            throw abortError;
          }
          if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {
            logger25.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
            if (responseError) {
              throw responseError;
            } else if (response) {
              return response;
            } else {
              throw new Error("Maximum retries reached with no response or error to throw");
            }
          }
          logger25.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
          strategiesLoop:
            for (const strategy of strategies) {
              const strategyLogger = strategy.logger || retryPolicyLogger;
              strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
              const modifiers = strategy.retry({
                retryCount,
                response,
                responseError
              });
              if (modifiers.skipStrategy) {
                strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                continue strategiesLoop;
              }
              const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
              if (errorToThrow) {
                strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                throw errorToThrow;
              }
              if (retryAfterInMs || retryAfterInMs === 0) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                await delay2(retryAfterInMs, void 0, { abortSignal: request3.abortSignal });
                continue retryRequest;
              }
              if (redirectTo) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                request3.url = redirectTo;
                continue retryRequest;
              }
            }
          if (responseError) {
            logger25.info(`None of the retry strategies could work with the received error. Throwing it.`);
            throw responseError;
          }
          if (response) {
            logger25.info(`None of the retry strategies could work with the received response. Returning it.`);
            return response;
          }
        }
    }
  };
}
var retryPolicyLogger, retryPolicyName;
var init_retryPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js"() {
    "use strict";
    init_helpers();
    init_src();
    init_src2();
    init_constants();
    retryPolicyLogger = createClientLogger("core-rest-pipeline retryPolicy");
    retryPolicyName = "retryPolicy";
  }
});
function defaultRetryPolicy(options = {}) {
  var _a2;
  return {
    name: defaultRetryPolicyName,
    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
      maxRetries: (_a2 = options.maxRetries) !== null && _a2 !== void 0 ? _a2 : DEFAULT_RETRY_POLICY_COUNT
    }).sendRequest
  };
}
var defaultRetryPolicyName;
var init_defaultRetryPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/defaultRetryPolicy.js"() {
    "use strict";
    init_exponentialRetryStrategy();
    init_throttlingRetryStrategy();
    init_retryPolicy();
    init_constants();
    defaultRetryPolicyName = "defaultRetryPolicy";
  }
});
var require_delayed_stream = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js"(exports, module2) {
    "use strict";
    var Stream = (0, import_chunk_FVJ3R4NJ.__require)("stream").Stream;
    var util2 = (0, import_chunk_FVJ3R4NJ.__require)("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util2.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});
var require_combined_stream = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js"(exports, module2) {
    "use strict";
    var util2 = (0, import_chunk_FVJ3R4NJ.__require)("util");
    var Stream = (0, import_chunk_FVJ3R4NJ.__require)("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util2.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self = this;
      stream.on("error", function(err) {
        self._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});
var require_db = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});
var require_mime_db = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_db();
  }
});
var require_mime_types = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = (0, import_chunk_FVJ3R4NJ.__require)("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path3) {
      if (!path3 || typeof path3 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path3).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type2;
        }
      });
    }
  }
});
var require_defer = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js"(exports, module2) {
    "use strict";
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});
var require_async = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"(exports, module2) {
    "use strict";
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});
var require_abort = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"(exports, module2) {
    "use strict";
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});
var require_iterate = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"(exports, module2) {
    "use strict";
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});
var require_state = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"(exports, module2) {
    "use strict";
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});
var require_terminator = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js"(exports, module2) {
    "use strict";
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});
var require_parallel = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"(exports, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});
var require_serialOrdered = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js"(exports, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});
var require_serial = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"(exports, module2) {
    "use strict";
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});
var require_asynckit = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});
var require_populate = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/populate.js"(exports, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});
var require_form_data = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/form_data.js"(exports, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util2 = (0, import_chunk_FVJ3R4NJ.__require)("util");
    var path3 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    var http4 = (0, import_chunk_FVJ3R4NJ.__require)("http");
    var https4 = (0, import_chunk_FVJ3R4NJ.__require)("https");
    var parseUrl = (0, import_chunk_FVJ3R4NJ.__require)("url").parse;
    var fs4 = (0, import_chunk_FVJ3R4NJ.__require)("fs");
    var Stream = (0, import_chunk_FVJ3R4NJ.__require)("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData2;
    util2.inherits(FormData2, CombinedStream);
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util2.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs4.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path3.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path3.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path3.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request3, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request3 = https4.request(options);
      } else {
        request3 = http4.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request3.setHeader("Content-Length", length);
        }
        this.pipe(request3);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request3.removeListener("error", callback);
            request3.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request3.on("error", callback);
          request3.on("response", onResponse);
        }
      }.bind(this));
      return request3;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});
function formDataPolicy() {
  return {
    name: formDataPolicyName,
    async sendRequest(request3, next) {
      if (request3.formData) {
        const contentType = request3.headers.get("Content-Type");
        if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
          request3.body = wwwFormUrlEncode(request3.formData);
          request3.formData = void 0;
        } else {
          prepareFormData(request3.formData, request3);
        }
      }
      return next(request3);
    }
  };
}
function wwwFormUrlEncode(formData) {
  const urlSearchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(formData)) {
    if (Array.isArray(value)) {
      for (const subValue of value) {
        urlSearchParams.append(key, subValue.toString());
      }
    } else {
      urlSearchParams.append(key, value.toString());
    }
  }
  return urlSearchParams.toString();
}
async function prepareFormData(formData, request3) {
  const requestForm = new import_form_data.default();
  for (const formKey of Object.keys(formData)) {
    const formValue = formData[formKey];
    if (Array.isArray(formValue)) {
      for (const subValue of formValue) {
        requestForm.append(formKey, subValue);
      }
    } else {
      requestForm.append(formKey, formValue);
    }
  }
  request3.body = requestForm;
  request3.formData = void 0;
  const contentType = request3.headers.get("Content-Type");
  if (contentType && contentType.indexOf("multipart/form-data") !== -1) {
    request3.headers.set("Content-Type", `multipart/form-data; boundary=${requestForm.getBoundary()}`);
  }
  try {
    const contentLength = await new Promise((resolve, reject) => {
      requestForm.getLength((err, length) => {
        if (err) {
          reject(err);
        } else {
          resolve(length);
        }
      });
    });
    request3.headers.set("Content-Length", contentLength);
  } catch (e) {
  }
}
var import_form_data, formDataPolicyName;
var init_formDataPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/formDataPolicy.js"() {
    "use strict";
    import_form_data = (0, import_chunk_FVJ3R4NJ.__toESM)(require_form_data());
    formDataPolicyName = "formDataPolicy";
  }
});
var require_promisify = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/promisify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function promisify3(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports.default = promisify3;
  }
});
var require_src2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/index.js"(exports, module2) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var debug_1 = __importDefault((0, import_chunk_MXIGSN4X.require_src)());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent3 extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent3;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});
var require_parse_proxy_response = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var debug_1 = __importDefault((0, import_chunk_MXIGSN4X.require_src)());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports.default = parseProxyResponse;
  }
});
var require_agent = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/agent.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var net_1 = __importDefault((0, import_chunk_FVJ3R4NJ.__require)("net"));
    var tls_1 = __importDefault((0, import_chunk_FVJ3R4NJ.__require)("tls"));
    var url_1 = __importDefault((0, import_chunk_FVJ3R4NJ.__require)("url"));
    var assert_1 = __importDefault((0, import_chunk_FVJ3R4NJ.__require)("assert"));
    var debug_1 = __importDefault((0, import_chunk_MXIGSN4X.require_src)());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent2 = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       *
       * @api protected
       */
      callback(req, opts) {
        return __awaiter2(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name3 of Object.keys(headers)) {
            payload += `${name3}: ${headers[name3]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              debug("Upgrading socket connection to TLS");
              const servername = opts.servername || opts.host;
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket({ writable: false });
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports.default = HttpsProxyAgent2;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});
var require_dist = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/index.js"(exports, module2) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module2.exports = createHttpsProxyAgent;
  }
});
var require_dist2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/@tootallnate+once@2.0.0/node_modules/@tootallnate/once/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function once(emitter, name3, { signal } = {}) {
      return new Promise((resolve, reject) => {
        function cleanup() {
          signal === null || signal === void 0 ? void 0 : signal.removeEventListener("abort", cleanup);
          emitter.removeListener(name3, onEvent);
          emitter.removeListener("error", onError);
        }
        function onEvent(...args) {
          cleanup();
          resolve(args);
        }
        function onError(err) {
          cleanup();
          reject(err);
        }
        signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", cleanup);
        emitter.on(name3, onEvent);
        emitter.on("error", onError);
      });
    }
    exports.default = once;
  }
});
var require_agent2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/http-proxy-agent@5.0.0/node_modules/http-proxy-agent/dist/agent.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var net_1 = __importDefault((0, import_chunk_FVJ3R4NJ.__require)("net"));
    var tls_1 = __importDefault((0, import_chunk_FVJ3R4NJ.__require)("tls"));
    var url_1 = __importDefault((0, import_chunk_FVJ3R4NJ.__require)("url"));
    var debug_1 = __importDefault((0, import_chunk_MXIGSN4X.require_src)());
    var once_1 = __importDefault(require_dist2());
    var agent_base_1 = require_src2();
    var debug = (0, debug_1.default)("http-proxy-agent");
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    var HttpProxyAgent2 = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("Creating new HttpProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       *
       * @api protected
       */
      callback(req, opts) {
        return __awaiter2(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          const parsed = url_1.default.parse(req.path);
          if (!parsed.protocol) {
            parsed.protocol = "http:";
          }
          if (!parsed.hostname) {
            parsed.hostname = opts.hostname || opts.host || null;
          }
          if (parsed.port == null && typeof opts.port) {
            parsed.port = String(opts.port);
          }
          if (parsed.port === "80") {
            parsed.port = "";
          }
          req.path = url_1.default.format(parsed);
          if (proxy.auth) {
            req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
          }
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          if (req._header) {
            let first;
            let endOfHeaders;
            debug("Regenerating stored HTTP header string for request");
            req._header = null;
            req._implicitHeader();
            if (req.output && req.output.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.output[0];
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.output[0] = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.output);
            } else if (req.outputData && req.outputData.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.outputData[0].data;
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.outputData[0].data = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.outputData[0].data);
            }
          }
          yield (0, once_1.default)(socket, "connect");
          return socket;
        });
      }
    };
    exports.default = HttpProxyAgent2;
  }
});
var require_dist3 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/http-proxy-agent@5.0.0/node_modules/http-proxy-agent/dist/index.js"(exports, module2) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent2());
    function createHttpProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpProxyAgent2) {
      createHttpProxyAgent2.HttpProxyAgent = agent_1.default;
      createHttpProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpProxyAgent || (createHttpProxyAgent = {}));
    module2.exports = createHttpProxyAgent;
  }
});
function getEnvironmentValue(name3) {
  if (process.env[name3]) {
    return process.env[name3];
  } else if (process.env[name3.toLowerCase()]) {
    return process.env[name3.toLowerCase()];
  }
  return void 0;
}
function loadEnvironmentProxyValue() {
  if (!process) {
    return void 0;
  }
  const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
  const allProxy = getEnvironmentValue(ALL_PROXY);
  const httpProxy = getEnvironmentValue(HTTP_PROXY);
  return httpsProxy || allProxy || httpProxy;
}
function isBypassed(uri, noProxyList, bypassedMap) {
  if (noProxyList.length === 0) {
    return false;
  }
  const host = new URL(uri).hostname;
  if (bypassedMap === null || bypassedMap === void 0 ? void 0 : bypassedMap.has(host)) {
    return bypassedMap.get(host);
  }
  let isBypassedFlag = false;
  for (const pattern of noProxyList) {
    if (pattern[0] === ".") {
      if (host.endsWith(pattern)) {
        isBypassedFlag = true;
      } else {
        if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
          isBypassedFlag = true;
        }
      }
    } else {
      if (host === pattern) {
        isBypassedFlag = true;
      }
    }
  }
  bypassedMap === null || bypassedMap === void 0 ? void 0 : bypassedMap.set(host, isBypassedFlag);
  return isBypassedFlag;
}
function loadNoProxy() {
  const noProxy = getEnvironmentValue(NO_PROXY);
  noProxyListLoaded = true;
  if (noProxy) {
    return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
  }
  return [];
}
function getDefaultProxySettings(proxyUrl) {
  if (!proxyUrl) {
    proxyUrl = loadEnvironmentProxyValue();
    if (!proxyUrl) {
      return void 0;
    }
  }
  const parsedUrl = new URL(proxyUrl);
  const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
  return {
    host: schema + parsedUrl.hostname,
    port: Number.parseInt(parsedUrl.port || "80"),
    username: parsedUrl.username,
    password: parsedUrl.password
  };
}
function getProxyAgentOptions(proxySettings, { headers, tlsSettings }) {
  let parsedProxyUrl;
  try {
    parsedProxyUrl = new URL(proxySettings.host);
  } catch (_error) {
    throw new Error(`Expecting a valid host string in proxy settings, but found "${proxySettings.host}".`);
  }
  if (tlsSettings) {
    logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
  }
  const proxyAgentOptions = {
    hostname: parsedProxyUrl.hostname,
    port: proxySettings.port,
    protocol: parsedProxyUrl.protocol,
    headers: headers.toJSON()
  };
  if (proxySettings.username && proxySettings.password) {
    proxyAgentOptions.auth = `${proxySettings.username}:${proxySettings.password}`;
  } else if (proxySettings.username) {
    proxyAgentOptions.auth = `${proxySettings.username}`;
  }
  return proxyAgentOptions;
}
function setProxyAgentOnRequest(request3, cachedAgents) {
  if (request3.agent) {
    return;
  }
  const url = new URL(request3.url);
  const isInsecure = url.protocol !== "https:";
  const proxySettings = request3.proxySettings;
  if (proxySettings) {
    if (isInsecure) {
      if (!cachedAgents.httpProxyAgent) {
        const proxyAgentOptions = getProxyAgentOptions(proxySettings, request3);
        cachedAgents.httpProxyAgent = new import_http_proxy_agent.HttpProxyAgent(proxyAgentOptions);
      }
      request3.agent = cachedAgents.httpProxyAgent;
    } else {
      if (!cachedAgents.httpsProxyAgent) {
        const proxyAgentOptions = getProxyAgentOptions(proxySettings, request3);
        cachedAgents.httpsProxyAgent = new import_https_proxy_agent.HttpsProxyAgent(proxyAgentOptions);
      }
      request3.agent = cachedAgents.httpsProxyAgent;
    }
  }
}
function proxyPolicy(proxySettings = getDefaultProxySettings(), options) {
  if (!noProxyListLoaded) {
    globalNoProxyList.push(...loadNoProxy());
  }
  const cachedAgents = {};
  return {
    name: proxyPolicyName,
    async sendRequest(request3, next) {
      var _a2;
      if (!request3.proxySettings && !isBypassed(request3.url, (_a2 = options === null || options === void 0 ? void 0 : options.customNoProxyList) !== null && _a2 !== void 0 ? _a2 : globalNoProxyList, (options === null || options === void 0 ? void 0 : options.customNoProxyList) ? void 0 : globalBypassedMap)) {
        request3.proxySettings = proxySettings;
      }
      if (request3.proxySettings) {
        setProxyAgentOnRequest(request3, cachedAgents);
      }
      return next(request3);
    }
  };
}
var import_https_proxy_agent, import_http_proxy_agent, HTTPS_PROXY, HTTP_PROXY, ALL_PROXY, NO_PROXY, proxyPolicyName, globalNoProxyList, noProxyListLoaded, globalBypassedMap;
var init_proxyPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/proxyPolicy.js"() {
    "use strict";
    import_https_proxy_agent = (0, import_chunk_FVJ3R4NJ.__toESM)(require_dist());
    import_http_proxy_agent = (0, import_chunk_FVJ3R4NJ.__toESM)(require_dist3());
    init_log2();
    HTTPS_PROXY = "HTTPS_PROXY";
    HTTP_PROXY = "HTTP_PROXY";
    ALL_PROXY = "ALL_PROXY";
    NO_PROXY = "NO_PROXY";
    proxyPolicyName = "proxyPolicy";
    globalNoProxyList = [];
    noProxyListLoaded = false;
    globalBypassedMap = /* @__PURE__ */ new Map();
  }
});
function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
  return {
    name: setClientRequestIdPolicyName,
    async sendRequest(request3, next) {
      if (!request3.headers.has(requestIdHeaderName)) {
        request3.headers.set(requestIdHeaderName, request3.requestId);
      }
      return next(request3);
    }
  };
}
var setClientRequestIdPolicyName;
var init_setClientRequestIdPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/setClientRequestIdPolicy.js"() {
    "use strict";
    setClientRequestIdPolicyName = "setClientRequestIdPolicy";
  }
});
function tlsPolicy(tlsSettings) {
  return {
    name: tlsPolicyName,
    sendRequest: async (req, next) => {
      if (!req.tlsSettings) {
        req.tlsSettings = tlsSettings;
      }
      return next(req);
    }
  };
}
var tlsPolicyName;
var init_tlsPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tlsPolicy.js"() {
    "use strict";
    tlsPolicyName = "tlsPolicy";
  }
});
function createTracingContext(options = {}) {
  let context = new TracingContextImpl(options.parentContext);
  if (options.span) {
    context = context.setValue(knownContextKeys.span, options.span);
  }
  if (options.namespace) {
    context = context.setValue(knownContextKeys.namespace, options.namespace);
  }
  return context;
}
var knownContextKeys, TracingContextImpl;
var init_tracingContext = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-tracing@1.0.1/node_modules/@azure/core-tracing/dist-esm/src/tracingContext.js"() {
    "use strict";
    knownContextKeys = {
      span: Symbol.for("@azure/core-tracing span"),
      namespace: Symbol.for("@azure/core-tracing namespace")
    };
    TracingContextImpl = class _TracingContextImpl {
      constructor(initialContext) {
        this._contextMap = initialContext instanceof _TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
      }
      setValue(key, value) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.set(key, value);
        return newContext;
      }
      getValue(key) {
        return this._contextMap.get(key);
      }
      deleteValue(key) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.delete(key);
        return newContext;
      }
    };
  }
});
function createDefaultTracingSpan() {
  return {
    end: () => {
    },
    isRecording: () => false,
    recordException: () => {
    },
    setAttribute: () => {
    },
    setStatus: () => {
    }
  };
}
function createDefaultInstrumenter() {
  return {
    createRequestHeaders: () => {
      return {};
    },
    parseTraceparentHeader: () => {
      return void 0;
    },
    startSpan: (_name, spanOptions) => {
      return {
        span: createDefaultTracingSpan(),
        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext })
      };
    },
    withContext(_context, callback, ...callbackArgs) {
      return callback(...callbackArgs);
    }
  };
}
function getInstrumenter() {
  if (!instrumenterImplementation) {
    instrumenterImplementation = createDefaultInstrumenter();
  }
  return instrumenterImplementation;
}
var instrumenterImplementation;
var init_instrumenter = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-tracing@1.0.1/node_modules/@azure/core-tracing/dist-esm/src/instrumenter.js"() {
    "use strict";
    init_tracingContext();
  }
});
function createTracingClient(options) {
  const { namespace, packageName, packageVersion } = options;
  function startSpan(name3, operationOptions, spanOptions) {
    var _a2;
    const startSpanResult = getInstrumenter().startSpan(name3, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a2 = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a2 === void 0 ? void 0 : _a2.tracingContext }));
    let tracingContext = startSpanResult.tracingContext;
    const span = startSpanResult.span;
    if (!tracingContext.getValue(knownContextKeys.namespace)) {
      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
    }
    span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
    const updatedOptions = Object.assign({}, operationOptions, {
      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext })
    });
    return {
      span,
      updatedOptions
    };
  }
  async function withSpan(name3, operationOptions, callback, spanOptions) {
    const { span, updatedOptions } = startSpan(name3, operationOptions, spanOptions);
    try {
      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
      span.setStatus({ status: "success" });
      return result;
    } catch (err) {
      span.setStatus({ status: "error", error: err });
      throw err;
    } finally {
      span.end();
    }
  }
  function withContext(context, callback, ...callbackArgs) {
    return getInstrumenter().withContext(context, callback, ...callbackArgs);
  }
  function parseTraceparentHeader(traceparentHeader) {
    return getInstrumenter().parseTraceparentHeader(traceparentHeader);
  }
  function createRequestHeaders(tracingContext) {
    return getInstrumenter().createRequestHeaders(tracingContext);
  }
  return {
    startSpan,
    withSpan,
    withContext,
    parseTraceparentHeader,
    createRequestHeaders
  };
}
var init_tracingClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-tracing@1.0.1/node_modules/@azure/core-tracing/dist-esm/src/tracingClient.js"() {
    "use strict";
    init_instrumenter();
    init_tracingContext();
  }
});
var init_src4 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-tracing@1.0.1/node_modules/@azure/core-tracing/dist-esm/src/index.js"() {
    "use strict";
    init_tracingClient();
  }
});
var custom;
var init_inspect = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/util/inspect.js"() {
    "use strict";
    custom = import_util2.inspect.custom;
  }
});
function isRestError(e) {
  if (e instanceof RestError) {
    return true;
  }
  return isError(e) && e.name === "RestError";
}
var errorSanitizer, RestError;
var init_restError = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js"() {
    "use strict";
    init_src3();
    init_inspect();
    init_sanitizer();
    errorSanitizer = new Sanitizer();
    RestError = class _RestError extends Error {
      constructor(message, options = {}) {
        super(message);
        this.name = "RestError";
        this.code = options.code;
        this.statusCode = options.statusCode;
        this.request = options.request;
        this.response = options.response;
        Object.setPrototypeOf(this, _RestError.prototype);
      }
      /**
       * Logging method for util.inspect in Node
       */
      [custom]() {
        return `RestError: ${this.message} 
 ${errorSanitizer.sanitize(this)}`;
      }
    };
    RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    RestError.PARSE_ERROR = "PARSE_ERROR";
  }
});
function tracingPolicy(options = {}) {
  const userAgent = getUserAgentValue(options.userAgentPrefix);
  const tracingClient2 = tryCreateTracingClient();
  return {
    name: tracingPolicyName,
    async sendRequest(request3, next) {
      var _a2, _b;
      if (!tracingClient2 || !((_a2 = request3.tracingOptions) === null || _a2 === void 0 ? void 0 : _a2.tracingContext)) {
        return next(request3);
      }
      const { span, tracingContext } = (_b = tryCreateSpan(tracingClient2, request3, userAgent)) !== null && _b !== void 0 ? _b : {};
      if (!span || !tracingContext) {
        return next(request3);
      }
      try {
        const response = await tracingClient2.withContext(tracingContext, next, request3);
        tryProcessResponse(span, response);
        return response;
      } catch (err) {
        tryProcessError(span, err);
        throw err;
      }
    }
  };
}
function tryCreateTracingClient() {
  try {
    return createTracingClient({
      namespace: "",
      packageName: "@azure/core-rest-pipeline",
      packageVersion: SDK_VERSION
    });
  } catch (e) {
    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryCreateSpan(tracingClient2, request3, userAgent) {
  try {
    const { span, updatedOptions } = tracingClient2.startSpan(`HTTP ${request3.method}`, { tracingOptions: request3.tracingOptions }, {
      spanKind: "client",
      spanAttributes: {
        "http.method": request3.method,
        "http.url": request3.url,
        requestId: request3.requestId
      }
    });
    if (!span.isRecording()) {
      span.end();
      return void 0;
    }
    if (userAgent) {
      span.setAttribute("http.user_agent", userAgent);
    }
    const headers = tracingClient2.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
    for (const [key, value] of Object.entries(headers)) {
      request3.headers.set(key, value);
    }
    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
  } catch (e) {
    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryProcessError(span, error) {
  try {
    span.setStatus({
      status: "error",
      error: isError(error) ? error : void 0
    });
    if (isRestError(error) && error.statusCode) {
      span.setAttribute("http.status_code", error.statusCode);
    }
    span.end();
  } catch (e) {
    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
function tryProcessResponse(span, response) {
  try {
    span.setAttribute("http.status_code", response.status);
    const serviceRequestId = response.headers.get("x-ms-request-id");
    if (serviceRequestId) {
      span.setAttribute("serviceRequestId", serviceRequestId);
    }
    span.setStatus({
      status: "success"
    });
    span.end();
  } catch (e) {
    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
var tracingPolicyName;
var init_tracingPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tracingPolicy.js"() {
    "use strict";
    init_src4();
    init_constants();
    init_userAgent();
    init_log2();
    init_src3();
    init_restError();
    tracingPolicyName = "tracingPolicy";
  }
});
function createPipelineFromOptions(options) {
  const pipeline = createEmptyPipeline();
  if (isNode) {
    if (options.tlsOptions) {
      pipeline.addPolicy(tlsPolicy(options.tlsOptions));
    }
    pipeline.addPolicy(proxyPolicy(options.proxyOptions));
    pipeline.addPolicy(decompressResponsePolicy());
  }
  pipeline.addPolicy(formDataPolicy());
  pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));
  pipeline.addPolicy(setClientRequestIdPolicy());
  pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
  pipeline.addPolicy(tracingPolicy(options.userAgentOptions), { afterPhase: "Retry" });
  if (isNode) {
    pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: "Retry" });
  }
  pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: "Sign" });
  return pipeline;
}
var init_createPipelineFromOptions = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/createPipelineFromOptions.js"() {
    "use strict";
    init_logPolicy();
    init_pipeline();
    init_redirectPolicy();
    init_userAgentPolicy();
    init_decompressResponsePolicy();
    init_defaultRetryPolicy();
    init_formDataPolicy();
    init_src3();
    init_proxyPolicy();
    init_setClientRequestIdPolicy();
    init_tlsPolicy();
    init_tracingPolicy();
  }
});
function normalizeName(name3) {
  return name3.toLowerCase();
}
function* headerIterator(map) {
  for (const entry of map.values()) {
    yield [entry.name, entry.value];
  }
}
function createHttpHeaders(rawHeaders) {
  return new HttpHeadersImpl(rawHeaders);
}
var HttpHeadersImpl;
var init_httpHeaders = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js"() {
    "use strict";
    HttpHeadersImpl = class {
      constructor(rawHeaders) {
        this._headersMap = /* @__PURE__ */ new Map();
        if (rawHeaders) {
          for (const headerName of Object.keys(rawHeaders)) {
            this.set(headerName, rawHeaders[headerName]);
          }
        }
      }
      /**
       * Set a header in this collection with the provided name and value. The name is
       * case-insensitive.
       * @param name - The name of the header to set. This value is case-insensitive.
       * @param value - The value of the header to set.
       */
      set(name3, value) {
        this._headersMap.set(normalizeName(name3), { name: name3, value: String(value) });
      }
      /**
       * Get the header value for the provided header name, or undefined if no header exists in this
       * collection with the provided name.
       * @param name - The name of the header. This value is case-insensitive.
       */
      get(name3) {
        var _a2;
        return (_a2 = this._headersMap.get(normalizeName(name3))) === null || _a2 === void 0 ? void 0 : _a2.value;
      }
      /**
       * Get whether or not this header collection contains a header entry for the provided header name.
       * @param name - The name of the header to set. This value is case-insensitive.
       */
      has(name3) {
        return this._headersMap.has(normalizeName(name3));
      }
      /**
       * Remove the header with the provided headerName.
       * @param name - The name of the header to remove.
       */
      delete(name3) {
        this._headersMap.delete(normalizeName(name3));
      }
      /**
       * Get the JSON object representation of this HTTP header collection.
       */
      toJSON(options = {}) {
        const result = {};
        if (options.preserveCase) {
          for (const entry of this._headersMap.values()) {
            result[entry.name] = entry.value;
          }
        } else {
          for (const [normalizedName, entry] of this._headersMap) {
            result[normalizedName] = entry.value;
          }
        }
        return result;
      }
      /**
       * Get the string representation of this HTTP header collection.
       */
      toString() {
        return JSON.stringify(this.toJSON({ preserveCase: true }));
      }
      /**
       * Iterate over tuples of header [name, value] pairs.
       */
      [Symbol.iterator]() {
        return headerIterator(this._headersMap);
      }
    };
  }
});
function isReadableStream(body) {
  return body && typeof body.pipe === "function";
}
function isStreamComplete(stream) {
  return new Promise((resolve) => {
    stream.on("close", resolve);
    stream.on("end", resolve);
    stream.on("error", resolve);
  });
}
function isArrayBuffer(body) {
  return body && typeof body.byteLength === "number";
}
function getResponseHeaders(res) {
  const headers = createHttpHeaders();
  for (const header of Object.keys(res.headers)) {
    const value = res.headers[header];
    if (Array.isArray(value)) {
      if (value.length > 0) {
        headers.set(header, value[0]);
      }
    } else if (value) {
      headers.set(header, value);
    }
  }
  return headers;
}
function getDecodedResponseStream(stream, headers) {
  const contentEncoding = headers.get("Content-Encoding");
  if (contentEncoding === "gzip") {
    const unzip = zlib.createGunzip();
    stream.pipe(unzip);
    return unzip;
  } else if (contentEncoding === "deflate") {
    const inflate = zlib.createInflate();
    stream.pipe(inflate);
    return inflate;
  }
  return stream;
}
function streamToText(stream) {
  return new Promise((resolve, reject) => {
    const buffer = [];
    stream.on("data", (chunk) => {
      if (Buffer.isBuffer(chunk)) {
        buffer.push(chunk);
      } else {
        buffer.push(Buffer.from(chunk));
      }
    });
    stream.on("end", () => {
      resolve(Buffer.concat(buffer).toString("utf8"));
    });
    stream.on("error", (e) => {
      if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
        reject(e);
      } else {
        reject(new RestError(`Error reading response as text: ${e.message}`, {
          code: RestError.PARSE_ERROR
        }));
      }
    });
  });
}
function getBodyLength(body) {
  if (!body) {
    return 0;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (isReadableStream(body)) {
    return null;
  } else if (isArrayBuffer(body)) {
    return body.byteLength;
  } else if (typeof body === "string") {
    return Buffer.from(body).length;
  } else {
    return null;
  }
}
function createNodeHttpClient() {
  return new NodeHttpClient();
}
var DEFAULT_TLS_SETTINGS, ReportTransform, NodeHttpClient;
var init_nodeHttpClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/nodeHttpClient.js"() {
    "use strict";
    init_src2();
    init_httpHeaders();
    init_restError();
    init_log2();
    DEFAULT_TLS_SETTINGS = {};
    ReportTransform = class extends import_stream.Transform {
      constructor(progressCallback) {
        super();
        this.loadedBytes = 0;
        this.progressCallback = progressCallback;
      }
      // eslint-disable-next-line @typescript-eslint/ban-types
      _transform(chunk, _encoding, callback) {
        this.push(chunk);
        this.loadedBytes += chunk.length;
        try {
          this.progressCallback({ loadedBytes: this.loadedBytes });
          callback();
        } catch (e) {
          callback(e);
        }
      }
    };
    NodeHttpClient = class {
      constructor() {
        this.cachedHttpsAgents = /* @__PURE__ */ new WeakMap();
      }
      /**
       * Makes a request over an underlying transport layer and returns the response.
       * @param request - The request to be made.
       */
      async sendRequest(request3) {
        var _a2, _b, _c;
        const abortController = new AbortController();
        let abortListener;
        if (request3.abortSignal) {
          if (request3.abortSignal.aborted) {
            throw new AbortError("The operation was aborted.");
          }
          abortListener = (event) => {
            if (event.type === "abort") {
              abortController.abort();
            }
          };
          request3.abortSignal.addEventListener("abort", abortListener);
        }
        if (request3.timeout > 0) {
          setTimeout(() => {
            abortController.abort();
          }, request3.timeout);
        }
        const acceptEncoding = request3.headers.get("Accept-Encoding");
        const shouldDecompress = (acceptEncoding === null || acceptEncoding === void 0 ? void 0 : acceptEncoding.includes("gzip")) || (acceptEncoding === null || acceptEncoding === void 0 ? void 0 : acceptEncoding.includes("deflate"));
        let body = typeof request3.body === "function" ? request3.body() : request3.body;
        if (body && !request3.headers.has("Content-Length")) {
          const bodyLength = getBodyLength(body);
          if (bodyLength !== null) {
            request3.headers.set("Content-Length", bodyLength);
          }
        }
        let responseStream;
        try {
          if (body && request3.onUploadProgress) {
            const onUploadProgress = request3.onUploadProgress;
            const uploadReportStream = new ReportTransform(onUploadProgress);
            uploadReportStream.on("error", (e) => {
              logger.error("Error in upload progress", e);
            });
            if (isReadableStream(body)) {
              body.pipe(uploadReportStream);
            } else {
              uploadReportStream.end(body);
            }
            body = uploadReportStream;
          }
          const res = await this.makeRequest(request3, abortController, body);
          const headers = getResponseHeaders(res);
          const status = (_a2 = res.statusCode) !== null && _a2 !== void 0 ? _a2 : 0;
          const response = {
            status,
            headers,
            request: request3
          };
          if (request3.method === "HEAD") {
            res.destroy();
            return response;
          }
          responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
          const onDownloadProgress = request3.onDownloadProgress;
          if (onDownloadProgress) {
            const downloadReportStream = new ReportTransform(onDownloadProgress);
            downloadReportStream.on("error", (e) => {
              logger.error("Error in download progress", e);
            });
            responseStream.pipe(downloadReportStream);
            responseStream = downloadReportStream;
          }
          if (
            // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
            ((_b = request3.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(Number.POSITIVE_INFINITY)) || ((_c = request3.streamResponseStatusCodes) === null || _c === void 0 ? void 0 : _c.has(response.status))
          ) {
            response.readableStreamBody = responseStream;
          } else {
            response.bodyAsText = await streamToText(responseStream);
          }
          return response;
        } finally {
          if (request3.abortSignal && abortListener) {
            let uploadStreamDone = Promise.resolve();
            if (isReadableStream(body)) {
              uploadStreamDone = isStreamComplete(body);
            }
            let downloadStreamDone = Promise.resolve();
            if (isReadableStream(responseStream)) {
              downloadStreamDone = isStreamComplete(responseStream);
            }
            Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
              var _a3;
              if (abortListener) {
                (_a3 = request3.abortSignal) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener("abort", abortListener);
              }
            }).catch((e) => {
              logger.warning("Error when cleaning up abortListener on httpRequest", e);
            });
          }
        }
      }
      makeRequest(request3, abortController, body) {
        var _a2;
        const url = new URL(request3.url);
        const isInsecure = url.protocol !== "https:";
        if (isInsecure && !request3.allowInsecureConnection) {
          throw new Error(`Cannot connect to ${request3.url} while allowInsecureConnection is false.`);
        }
        const agent = (_a2 = request3.agent) !== null && _a2 !== void 0 ? _a2 : this.getOrCreateAgent(request3, isInsecure);
        const options = {
          agent,
          hostname: url.hostname,
          path: `${url.pathname}${url.search}`,
          port: url.port,
          method: request3.method,
          headers: request3.headers.toJSON({ preserveCase: true })
        };
        return new Promise((resolve, reject) => {
          const req = isInsecure ? http2.request(options, resolve) : https2.request(options, resolve);
          req.once("error", (err) => {
            var _a3;
            reject(new RestError(err.message, { code: (_a3 = err.code) !== null && _a3 !== void 0 ? _a3 : RestError.REQUEST_SEND_ERROR, request: request3 }));
          });
          abortController.signal.addEventListener("abort", () => {
            const abortError = new AbortError("The operation was aborted.");
            req.destroy(abortError);
            reject(abortError);
          });
          if (body && isReadableStream(body)) {
            body.pipe(req);
          } else if (body) {
            if (typeof body === "string" || Buffer.isBuffer(body)) {
              req.end(body);
            } else if (isArrayBuffer(body)) {
              req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
            } else {
              logger.error("Unrecognized body type", body);
              reject(new RestError("Unrecognized body type"));
            }
          } else {
            req.end();
          }
        });
      }
      getOrCreateAgent(request3, isInsecure) {
        var _a2;
        const disableKeepAlive = request3.disableKeepAlive;
        if (isInsecure) {
          if (disableKeepAlive) {
            return http2.globalAgent;
          }
          if (!this.cachedHttpAgent) {
            this.cachedHttpAgent = new http2.Agent({ keepAlive: true });
          }
          return this.cachedHttpAgent;
        } else {
          if (disableKeepAlive && !request3.tlsSettings) {
            return https2.globalAgent;
          }
          const tlsSettings = (_a2 = request3.tlsSettings) !== null && _a2 !== void 0 ? _a2 : DEFAULT_TLS_SETTINGS;
          let agent = this.cachedHttpsAgents.get(tlsSettings);
          if (agent && agent.options.keepAlive === !disableKeepAlive) {
            return agent;
          }
          logger.info("No cached TLS Agent exist, creating a new Agent");
          agent = new https2.Agent(Object.assign({
            // keepAlive is true if disableKeepAlive is false.
            keepAlive: !disableKeepAlive
          }, tlsSettings));
          this.cachedHttpsAgents.set(tlsSettings, agent);
          return agent;
        }
      }
    };
  }
});
function createDefaultHttpClient() {
  return createNodeHttpClient();
}
var init_defaultHttpClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/defaultHttpClient.js"() {
    "use strict";
    init_nodeHttpClient();
  }
});
function generateUuid() {
  return v4_default();
}
var init_uuid = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/util/uuid.js"() {
    "use strict";
    init_esm_node();
  }
});
function createPipelineRequest(options) {
  return new PipelineRequestImpl(options);
}
var PipelineRequestImpl;
var init_pipelineRequest = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/pipelineRequest.js"() {
    "use strict";
    init_httpHeaders();
    init_uuid();
    PipelineRequestImpl = class {
      constructor(options) {
        var _a2, _b, _c, _d, _e, _f, _g;
        this.url = options.url;
        this.body = options.body;
        this.headers = (_a2 = options.headers) !== null && _a2 !== void 0 ? _a2 : createHttpHeaders();
        this.method = (_b = options.method) !== null && _b !== void 0 ? _b : "GET";
        this.timeout = (_c = options.timeout) !== null && _c !== void 0 ? _c : 0;
        this.formData = options.formData;
        this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== void 0 ? _d : false;
        this.proxySettings = options.proxySettings;
        this.streamResponseStatusCodes = options.streamResponseStatusCodes;
        this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
        this.abortSignal = options.abortSignal;
        this.tracingOptions = options.tracingOptions;
        this.onUploadProgress = options.onUploadProgress;
        this.onDownloadProgress = options.onDownloadProgress;
        this.requestId = options.requestId || generateUuid();
        this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
        this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
      }
    };
  }
});
async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
  async function tryGetAccessToken() {
    if (Date.now() < refreshTimeout) {
      try {
        return await getAccessToken();
      } catch (_a2) {
        return null;
      }
    } else {
      const finalToken = await getAccessToken();
      if (finalToken === null) {
        throw new Error("Failed to refresh access token.");
      }
      return finalToken;
    }
  }
  let token = await tryGetAccessToken();
  while (token === null) {
    await delay2(retryIntervalInMs);
    token = await tryGetAccessToken();
  }
  return token;
}
function createTokenCycler(credential, tokenCyclerOptions) {
  let refreshWorker = null;
  let token = null;
  let tenantId;
  const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
  const cycler = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return refreshWorker !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      var _a2;
      return !cycler.isRefreshing && ((_a2 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a2 !== void 0 ? _a2 : 0) - options.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
    }
  };
  function refresh(scopes, getTokenOptions) {
    var _a2;
    if (!cycler.isRefreshing) {
      const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
      refreshWorker = beginRefresh(
        tryGetAccessToken,
        options.retryIntervalInMs,
        // If we don't have a token, then we should timeout immediately
        (_a2 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a2 !== void 0 ? _a2 : Date.now()
      ).then((_token) => {
        refreshWorker = null;
        token = _token;
        tenantId = getTokenOptions.tenantId;
        return token;
      }).catch((reason) => {
        refreshWorker = null;
        token = null;
        tenantId = void 0;
        throw reason;
      });
    }
    return refreshWorker;
  }
  return async (scopes, tokenOptions) => {
    const mustRefresh = tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh;
    if (mustRefresh)
      return refresh(scopes, tokenOptions);
    if (cycler.shouldRefresh) {
      refresh(scopes, tokenOptions);
    }
    return token;
  };
}
var DEFAULT_CYCLER_OPTIONS;
var init_tokenCycler = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/util/tokenCycler.js"() {
    "use strict";
    init_helpers();
    DEFAULT_CYCLER_OPTIONS = {
      forcedRefreshWindowInMs: 1e3,
      retryIntervalInMs: 3e3,
      refreshWindowInMs: 1e3 * 60 * 2
      // Start refreshing 2m before expiry
    };
  }
});
async function defaultAuthorizeRequest(options) {
  const { scopes, getAccessToken, request: request3 } = options;
  const getTokenOptions = {
    abortSignal: request3.abortSignal,
    tracingOptions: request3.tracingOptions
  };
  const accessToken = await getAccessToken(scopes, getTokenOptions);
  if (accessToken) {
    options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
  }
}
function getChallenge(response) {
  const challenge = response.headers.get("WWW-Authenticate");
  if (response.status === 401 && challenge) {
    return challenge;
  }
  return;
}
function bearerTokenAuthenticationPolicy(options) {
  var _a2;
  const { credential, scopes, challengeCallbacks } = options;
  const logger25 = options.logger || logger;
  const callbacks = Object.assign({ authorizeRequest: (_a2 = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a2 !== void 0 ? _a2 : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);
  const getAccessToken = credential ? createTokenCycler(
    credential
    /* , options */
  ) : () => Promise.resolve(null);
  return {
    name: bearerTokenAuthenticationPolicyName,
    /**
     * If there's no challenge parameter:
     * - It will try to retrieve the token using the cache, or the credential's getToken.
     * - Then it will try the next policy with or without the retrieved token.
     *
     * It uses the challenge parameters to:
     * - Skip a first attempt to get the token from the credential if there's no cached token,
     *   since it expects the token to be retrievable only after the challenge.
     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
     * - Send an initial request to receive the challenge if it fails.
     * - Process a challenge if the response contains it.
     * - Retrieve a token with the challenge information, then re-send the request.
     */
    async sendRequest(request3, next) {
      if (!request3.url.toLowerCase().startsWith("https://")) {
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      }
      await callbacks.authorizeRequest({
        scopes: Array.isArray(scopes) ? scopes : [scopes],
        request: request3,
        getAccessToken,
        logger: logger25
      });
      let response;
      let error;
      try {
        response = await next(request3);
      } catch (err) {
        error = err;
        response = err.response;
      }
      if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response)) {
        const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request: request3,
          response,
          getAccessToken,
          logger: logger25
        });
        if (shouldSendRequest) {
          return next(request3);
        }
      }
      if (error) {
        throw error;
      } else {
        return response;
      }
    }
  };
}
var bearerTokenAuthenticationPolicyName;
var init_bearerTokenAuthenticationPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js"() {
    "use strict";
    init_tokenCycler();
    init_log2();
    bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
  }
});
var init_src5 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-rest-pipeline@1.9.2/node_modules/@azure/core-rest-pipeline/dist-esm/src/index.js"() {
    "use strict";
    init_createPipelineFromOptions();
    init_defaultHttpClient();
    init_httpHeaders();
    init_pipelineRequest();
    init_restError();
    init_bearerTokenAuthenticationPolicy();
  }
});
function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
  let parameterPath = parameter.parameterPath;
  const parameterMapper = parameter.mapper;
  let value;
  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
        if (!propertySearchResult.propertyFound && fallbackObject) {
          propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
        }
        let useDefaultValue = false;
        if (!propertySearchResult.propertyFound) {
          useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
        }
        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      }
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }
    for (const propertyName in parameterPath) {
      const propertyMapper = parameterMapper.type.modelProperties[propertyName];
      const propertyPath = parameterPath[propertyName];
      const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
        parameterPath: propertyPath,
        mapper: propertyMapper
      }, fallbackObject);
      if (propertyValue !== void 0) {
        if (!value) {
          value = {};
        }
        value[propertyName] = propertyValue;
      }
    }
  }
  return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
  const result = { propertyFound: false };
  let i = 0;
  for (; i < parameterPath.length; ++i) {
    const parameterPathPart = parameterPath[i];
    if (parent && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }
  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }
  return result;
}
function getOperationRequestInfo(request3) {
  let info = operationRequestMap.get(request3);
  if (!info) {
    info = {};
    operationRequestMap.set(request3, info);
  }
  return info;
}
var operationRequestMap;
var init_operationHelpers = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/operationHelpers.js"() {
    "use strict";
    operationRequestMap = /* @__PURE__ */ new WeakMap();
  }
});
function deserializationPolicy(options = {}) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const jsonContentTypes = (_b = (_a2 = options.expectedContentTypes) === null || _a2 === void 0 ? void 0 : _a2.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;
  const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;
  const parseXML = options.parseXML;
  const serializerOptions = options.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : "",
      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,
      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY
    }
  };
  return {
    name: deserializationPolicyName,
    async sendRequest(request3, next) {
      const response = await next(request3);
      return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
    }
  };
}
function getOperationResponseMap(parsedResponse) {
  let result;
  const request3 = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request3);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (operationSpec) {
    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {
      result = operationSpec.responses[parsedResponse.status];
    } else {
      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
    }
  }
  return result;
}
function shouldDeserializeResponse(parsedResponse) {
  const request3 = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request3);
  const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;
  let result;
  if (shouldDeserialize === void 0) {
    result = true;
  } else if (typeof shouldDeserialize === "boolean") {
    result = shouldDeserialize;
  } else {
    result = shouldDeserialize(parsedResponse);
  }
  return result;
}
async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
  const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
  if (!shouldDeserializeResponse(parsedResponse)) {
    return parsedResponse;
  }
  const operationInfo = getOperationRequestInfo(parsedResponse.request);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (!operationSpec || !operationSpec.responses) {
    return parsedResponse;
  }
  const responseSpec = getOperationResponseMap(parsedResponse);
  const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec);
  if (error) {
    throw error;
  } else if (shouldReturnResponse) {
    return parsedResponse;
  }
  if (responseSpec) {
    if (responseSpec.bodyMapper) {
      let valueToDeserialize = parsedResponse.parsedBody;
      if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {
        valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
      }
      try {
        parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody");
      } catch (deserializeError) {
        const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
          statusCode: parsedResponse.status,
          request: parsedResponse.request,
          response: parsedResponse
        });
        throw restError;
      }
    } else if (operationSpec.httpMethod === "HEAD") {
      parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
    }
    if (responseSpec.headersMapper) {
      parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
    }
  }
  return parsedResponse;
}
function isOperationSpecEmpty(operationSpec) {
  const expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function handleErrorResponse(parsedResponse, operationSpec, responseSpec) {
  var _a2;
  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
  if (isExpectedStatusCode) {
    if (responseSpec) {
      if (!responseSpec.isError) {
        return { error: null, shouldReturnResponse: false };
      }
    } else {
      return { error: null, shouldReturnResponse: false };
    }
  }
  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
  const initialErrorMessage = ((_a2 = parsedResponse.request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
  const error = new RestError(initialErrorMessage, {
    statusCode: parsedResponse.status,
    request: parsedResponse.request,
    response: parsedResponse
  });
  if (!errorResponseSpec) {
    throw error;
  }
  const defaultBodyMapper = errorResponseSpec.bodyMapper;
  const defaultHeadersMapper = errorResponseSpec.headersMapper;
  try {
    if (parsedResponse.parsedBody) {
      const parsedBody = parsedResponse.parsedBody;
      let deserializedError;
      if (defaultBodyMapper) {
        let valueToDeserialize = parsedBody;
        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {
          valueToDeserialize = [];
          const elementName = defaultBodyMapper.xmlElementName;
          if (typeof parsedBody === "object" && elementName) {
            valueToDeserialize = parsedBody[elementName];
          }
        }
        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody");
      }
      const internalError = parsedBody.error || deserializedError || parsedBody;
      error.code = internalError.code;
      if (internalError.message) {
        error.message = internalError.message;
      }
      if (defaultBodyMapper) {
        error.response.parsedBody = deserializedError;
      }
    }
    if (parsedResponse.headers && defaultHeadersMapper) {
      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
    }
  } catch (defaultError) {
    error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
  }
  return { error, shouldReturnResponse: false };
}
async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
  var _a2;
  if (!((_a2 = operationResponse.request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(operationResponse.status)) && operationResponse.bodyAsText) {
    const text = operationResponse.bodyAsText;
    const contentType = operationResponse.headers.get("Content-Type") || "";
    const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
    try {
      if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
        operationResponse.parsedBody = JSON.parse(text);
        return operationResponse;
      } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
        if (!parseXML) {
          throw new Error("Parsing XML not supported.");
        }
        const body = await parseXML(text, opts.xml);
        operationResponse.parsedBody = body;
        return operationResponse;
      }
    } catch (err) {
      const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
      const errCode = err.code || RestError.PARSE_ERROR;
      const e = new RestError(msg, {
        code: errCode,
        statusCode: operationResponse.status,
        request: operationResponse.request,
        response: operationResponse
      });
      throw e;
    }
  }
  return operationResponse;
}
var defaultJsonContentTypes, defaultXmlContentTypes, deserializationPolicyName;
var init_deserializationPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js"() {
    "use strict";
    init_interfaces();
    init_src5();
    init_serializer();
    init_operationHelpers();
    defaultJsonContentTypes = ["application/json", "text/json"];
    defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
    deserializationPolicyName = "deserializationPolicy";
  }
});
function getStreamingResponseStatusCodes(operationSpec) {
  const result = /* @__PURE__ */ new Set();
  for (const statusCode in operationSpec.responses) {
    const operationResponse = operationSpec.responses[statusCode];
    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperTypeNames.Stream) {
      result.add(Number(statusCode));
    }
  }
  return result;
}
function getPathStringFromParameter(parameter) {
  const { parameterPath, mapper } = parameter;
  let result;
  if (typeof parameterPath === "string") {
    result = parameterPath;
  } else if (Array.isArray(parameterPath)) {
    result = parameterPath.join(".");
  } else {
    result = mapper.serializedName;
  }
  return result;
}
var init_interfaceHelpers = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js"() {
    "use strict";
    init_serializer();
  }
});
function serializationPolicy(options = {}) {
  const stringifyXML = options.stringifyXML;
  return {
    name: serializationPolicyName,
    async sendRequest(request3, next) {
      const operationInfo = getOperationRequestInfo(request3);
      const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
      const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;
      if (operationSpec && operationArguments) {
        serializeHeaders(request3, operationArguments, operationSpec);
        serializeRequestBody(request3, operationArguments, operationSpec, stringifyXML);
      }
      return next(request3);
    }
  };
}
function serializeHeaders(request3, operationArguments, operationSpec) {
  var _a2, _b;
  if (operationSpec.headerParameters) {
    for (const headerParameter of operationSpec.headerParameters) {
      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);
      if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));
        const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
          for (const key of Object.keys(headerValue)) {
            request3.headers.set(headerCollectionPrefix + key, headerValue[key]);
          }
        } else {
          request3.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
        }
      }
    }
  }
  const customHeaders = (_b = (_a2 = operationArguments.options) === null || _a2 === void 0 ? void 0 : _a2.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;
  if (customHeaders) {
    for (const customHeaderName of Object.keys(customHeaders)) {
      request3.headers.set(customHeaderName, customHeaders[customHeaderName]);
    }
  }
}
function serializeRequestBody(request3, operationArguments, operationSpec, stringifyXML = function() {
  throw new Error("XML serialization unsupported!");
}) {
  var _a2, _b, _c, _d, _e;
  const serializerOptions = (_a2 = operationArguments.options) === null || _a2 === void 0 ? void 0 : _a2.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : "",
      includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,
      xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY
    }
  };
  const xmlCharKey = updatedOptions.xml.xmlCharKey;
  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    request3.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);
    const bodyMapper = operationSpec.requestBody.mapper;
    const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
    const typeName = bodyMapper.type.name;
    try {
      if (request3.body !== void 0 && request3.body !== null || nullable && request3.body === null || required) {
        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
        request3.body = operationSpec.serializer.serialize(bodyMapper, request3.body, requestBodyParameterPathString, updatedOptions);
        const isStream = typeName === MapperTypeNames.Stream;
        if (operationSpec.isXML) {
          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request3.body, updatedOptions);
          if (typeName === MapperTypeNames.Sequence) {
            request3.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
          } else if (!isStream) {
            request3.body = stringifyXML(value, {
              rootName: xmlName || serializedName,
              xmlCharKey
            });
          }
        } else if (typeName === MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match("text/plain")) || operationSpec.mediaType === "text")) {
          return;
        } else if (!isStream) {
          request3.body = JSON.stringify(request3.body);
        }
      }
    } catch (error) {
      throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    request3.formData = {};
    for (const formDataParameter of operationSpec.formDataParameters) {
      const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);
      if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
        request3.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
      }
    }
  }
}
function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
    return result;
  }
  return serializedValue;
}
function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
  if (!Array.isArray(obj)) {
    obj = [obj];
  }
  if (!xmlNamespaceKey || !xmlNamespace) {
    return { [elementName]: obj };
  }
  const result = { [elementName]: obj };
  result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
  return result;
}
var serializationPolicyName;
var init_serializationPolicy = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js"() {
    "use strict";
    init_interfaces();
    init_operationHelpers();
    init_serializer();
    init_interfaceHelpers();
    serializationPolicyName = "serializationPolicy";
  }
});
function createClientPipeline(options = {}) {
  const pipeline = createPipelineFromOptions(options !== null && options !== void 0 ? options : {});
  if (options.credentialOptions) {
    pipeline.addPolicy(bearerTokenAuthenticationPolicy({
      credential: options.credentialOptions.credential,
      scopes: options.credentialOptions.credentialScopes
    }));
  }
  pipeline.addPolicy(serializationPolicy(options.serializationOptions), { phase: "Serialize" });
  pipeline.addPolicy(deserializationPolicy(options.deserializationOptions), {
    phase: "Deserialize"
  });
  return pipeline;
}
var init_pipeline2 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/pipeline.js"() {
    "use strict";
    init_deserializationPolicy();
    init_src5();
    init_serializationPolicy();
  }
});
function getCachedDefaultHttpClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = createDefaultHttpClient();
  }
  return cachedHttpClient;
}
var cachedHttpClient;
var init_httpClientCache = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/httpClientCache.js"() {
    "use strict";
    init_src5();
  }
});
function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
  const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
  let isAbsolutePath = false;
  let requestUrl = replaceAll(baseUri, urlReplacements);
  if (operationSpec.path) {
    let path3 = replaceAll(operationSpec.path, urlReplacements);
    if (operationSpec.path === "/{nextLink}" && path3.startsWith("/")) {
      path3 = path3.substring(1);
    }
    if (isAbsoluteUrl(path3)) {
      requestUrl = path3;
      isAbsolutePath = true;
    } else {
      requestUrl = appendPath(requestUrl, path3);
    }
  }
  const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
  return requestUrl;
}
function replaceAll(input, replacements) {
  let result = input;
  for (const [searchValue, replaceValue] of replacements) {
    result = result.split(searchValue).join(replaceValue);
  }
  return result;
}
function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
  var _a2;
  const result = /* @__PURE__ */ new Map();
  if ((_a2 = operationSpec.urlParameters) === null || _a2 === void 0 ? void 0 : _a2.length) {
    for (const urlParameter of operationSpec.urlParameters) {
      let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);
      const parameterPathString = getPathStringFromParameter(urlParameter);
      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
      if (!urlParameter.skipEncoding) {
        urlParameterValue = encodeURIComponent(urlParameterValue);
      }
      result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
    }
  }
  return result;
}
function isAbsoluteUrl(url) {
  return url.includes("://");
}
function appendPath(url, pathToAppend) {
  if (!pathToAppend) {
    return url;
  }
  const parsedUrl = new URL(url);
  let newPath = parsedUrl.pathname;
  if (!newPath.endsWith("/")) {
    newPath = `${newPath}/`;
  }
  if (pathToAppend.startsWith("/")) {
    pathToAppend = pathToAppend.substring(1);
  }
  const searchStart = pathToAppend.indexOf("?");
  if (searchStart !== -1) {
    const path3 = pathToAppend.substring(0, searchStart);
    const search = pathToAppend.substring(searchStart + 1);
    newPath = newPath + path3;
    if (search) {
      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
    }
  } else {
    newPath = newPath + pathToAppend;
  }
  parsedUrl.pathname = newPath;
  return parsedUrl.toString();
}
function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
  var _a2;
  const result = /* @__PURE__ */ new Map();
  const sequenceParams = /* @__PURE__ */ new Set();
  if ((_a2 = operationSpec.queryParameters) === null || _a2 === void 0 ? void 0 : _a2.length) {
    for (const queryParameter of operationSpec.queryParameters) {
      if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
        sequenceParams.add(queryParameter.mapper.serializedName);
      }
      let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);
      if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));
        const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
        if (Array.isArray(queryParameterValue)) {
          queryParameterValue = queryParameterValue.map((item) => {
            if (item === null || item === void 0) {
              return "";
            }
            return item;
          });
        }
        if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
          continue;
        } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        if (!queryParameter.skipEncoding) {
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              return encodeURIComponent(item);
            });
          } else {
            queryParameterValue = encodeURIComponent(queryParameterValue);
          }
        }
        if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
      }
    }
  }
  return {
    queryParams: result,
    sequenceParams
  };
}
function simpleParseQueryParams(queryString) {
  const result = /* @__PURE__ */ new Map();
  if (!queryString || queryString[0] !== "?") {
    return result;
  }
  queryString = queryString.slice(1);
  const pairs = queryString.split("&");
  for (const pair of pairs) {
    const [name3, value] = pair.split("=", 2);
    const existingValue = result.get(name3);
    if (existingValue) {
      if (Array.isArray(existingValue)) {
        existingValue.push(value);
      } else {
        result.set(name3, [existingValue, value]);
      }
    } else {
      result.set(name3, value);
    }
  }
  return result;
}
function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
  if (queryParams.size === 0) {
    return url;
  }
  const parsedUrl = new URL(url);
  const combinedParams = simpleParseQueryParams(parsedUrl.search);
  for (const [name3, value] of queryParams) {
    const existingValue = combinedParams.get(name3);
    if (Array.isArray(existingValue)) {
      if (Array.isArray(value)) {
        existingValue.push(...value);
        const valueSet = new Set(existingValue);
        combinedParams.set(name3, Array.from(valueSet));
      } else {
        existingValue.push(value);
      }
    } else if (existingValue) {
      if (Array.isArray(value)) {
        value.unshift(existingValue);
      } else if (sequenceParams.has(name3)) {
        combinedParams.set(name3, [existingValue, value]);
      }
      if (!noOverwrite) {
        combinedParams.set(name3, value);
      }
    } else {
      combinedParams.set(name3, value);
    }
  }
  const searchPieces = [];
  for (const [name3, value] of combinedParams) {
    if (typeof value === "string") {
      searchPieces.push(`${name3}=${value}`);
    } else if (Array.isArray(value)) {
      for (const subValue of value) {
        searchPieces.push(`${name3}=${subValue}`);
      }
    } else {
      searchPieces.push(`${name3}=${value}`);
    }
  }
  parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
  return parsedUrl.toString();
}
var CollectionFormatToDelimiterMap;
var init_urlHelpers = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/urlHelpers.js"() {
    "use strict";
    init_operationHelpers();
    init_interfaceHelpers();
    CollectionFormatToDelimiterMap = {
      CSV: ",",
      SSV: " ",
      Multi: "Multi",
      TSV: "	",
      Pipes: "|"
    };
  }
});
var logger2;
var init_log3 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/log.js"() {
    "use strict";
    init_src();
    logger2 = createClientLogger("core-client");
  }
});
function createDefaultPipeline(options) {
  const credentialScopes = getCredentialScopes(options);
  const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : void 0;
  return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));
}
function getCredentialScopes(options) {
  if (options.credentialScopes) {
    const scopes = options.credentialScopes;
    return Array.isArray(scopes) ? scopes.map((scope) => new URL(scope).toString()) : new URL(scopes).toString();
  }
  if (options.endpoint) {
    return `${options.endpoint}/.default`;
  }
  if (options.baseUri) {
    return `${options.baseUri}/.default`;
  }
  if (options.credential && !options.credentialScopes) {
    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
  }
  return void 0;
}
var ServiceClient;
var init_serviceClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/serviceClient.js"() {
    "use strict";
    init_src5();
    init_pipeline2();
    init_utils();
    init_httpClientCache();
    init_operationHelpers();
    init_urlHelpers();
    init_interfaceHelpers();
    init_log3();
    ServiceClient = class {
      /**
       * The ServiceClient constructor
       * @param credential - The credentials used for authentication with the service.
       * @param options - The service client options that govern the behavior of the client.
       */
      constructor(options = {}) {
        var _a2, _b;
        this._requestContentType = options.requestContentType;
        this._endpoint = (_a2 = options.endpoint) !== null && _a2 !== void 0 ? _a2 : options.baseUri;
        if (options.baseUri) {
          logger2.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
        }
        this._allowInsecureConnection = options.allowInsecureConnection;
        this._httpClient = options.httpClient || getCachedDefaultHttpClient();
        this.pipeline = options.pipeline || createDefaultPipeline(options);
        if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {
          for (const { policy, position } of options.additionalPolicies) {
            const afterPhase = position === "perRetry" ? "Sign" : void 0;
            this.pipeline.addPolicy(policy, {
              afterPhase
            });
          }
        }
      }
      /**
       * Send the provided httpRequest.
       */
      async sendRequest(request3) {
        return this.pipeline.sendRequest(this._httpClient, request3);
      }
      /**
       * Send an HTTP request that is populated using the provided OperationSpec.
       * @typeParam T - The typed result of the request, based on the OperationSpec.
       * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
       * @param operationSpec - The OperationSpec to use to populate the httpRequest.
       */
      async sendOperationRequest(operationArguments, operationSpec) {
        const endpoint = operationSpec.baseUrl || this._endpoint;
        if (!endpoint) {
          throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
        }
        const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);
        const request3 = createPipelineRequest({
          url
        });
        request3.method = operationSpec.httpMethod;
        const operationInfo = getOperationRequestInfo(request3);
        operationInfo.operationSpec = operationSpec;
        operationInfo.operationArguments = operationArguments;
        const contentType = operationSpec.contentType || this._requestContentType;
        if (contentType && operationSpec.requestBody) {
          request3.headers.set("Content-Type", contentType);
        }
        const options = operationArguments.options;
        if (options) {
          const requestOptions = options.requestOptions;
          if (requestOptions) {
            if (requestOptions.timeout) {
              request3.timeout = requestOptions.timeout;
            }
            if (requestOptions.onUploadProgress) {
              request3.onUploadProgress = requestOptions.onUploadProgress;
            }
            if (requestOptions.onDownloadProgress) {
              request3.onDownloadProgress = requestOptions.onDownloadProgress;
            }
            if (requestOptions.shouldDeserialize !== void 0) {
              operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
            }
            if (requestOptions.allowInsecureConnection) {
              request3.allowInsecureConnection = true;
            }
          }
          if (options.abortSignal) {
            request3.abortSignal = options.abortSignal;
          }
          if (options.tracingOptions) {
            request3.tracingOptions = options.tracingOptions;
          }
        }
        if (this._allowInsecureConnection) {
          request3.allowInsecureConnection = true;
        }
        if (request3.streamResponseStatusCodes === void 0) {
          request3.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);
        }
        try {
          const rawResponse = await this.sendRequest(request3);
          const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);
          if (options === null || options === void 0 ? void 0 : options.onResponse) {
            options.onResponse(rawResponse, flatResponse);
          }
          return flatResponse;
        } catch (error) {
          if (typeof error === "object" && (error === null || error === void 0 ? void 0 : error.response)) {
            const rawResponse = error.response;
            const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
            error.details = flatResponse;
            if (options === null || options === void 0 ? void 0 : options.onResponse) {
              options.onResponse(rawResponse, flatResponse, error);
            }
          }
          throw error;
        }
      }
    };
  }
});
var init_src6 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+core-client@1.6.1/node_modules/@azure/core-client/dist-esm/src/index.js"() {
    "use strict";
    init_serviceClient();
  }
});
function isErrorResponse(errorResponse) {
  return errorResponse && typeof errorResponse.error === "string" && typeof errorResponse.error_description === "string";
}
function convertOAuthErrorResponseToErrorResponse(errorBody) {
  return {
    error: errorBody.error,
    errorDescription: errorBody.error_description,
    correlationId: errorBody.correlation_id,
    errorCodes: errorBody.error_codes,
    timestamp: errorBody.timestamp,
    traceId: errorBody.trace_id
  };
}
var CredentialUnavailableErrorName, CredentialUnavailableError, AuthenticationErrorName, AuthenticationError, AggregateAuthenticationErrorName, AggregateAuthenticationError, AuthenticationRequiredError;
var init_errors = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/errors.js"() {
    "use strict";
    CredentialUnavailableErrorName = "CredentialUnavailableError";
    CredentialUnavailableError = class extends Error {
      constructor(message) {
        super(message);
        this.name = CredentialUnavailableErrorName;
      }
    };
    AuthenticationErrorName = "AuthenticationError";
    AuthenticationError = class extends Error {
      // eslint-disable-next-line @typescript-eslint/ban-types
      constructor(statusCode, errorBody) {
        let errorResponse = {
          error: "unknown",
          errorDescription: "An unknown error occurred and no additional details are available."
        };
        if (isErrorResponse(errorBody)) {
          errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);
        } else if (typeof errorBody === "string") {
          try {
            const oauthErrorResponse = JSON.parse(errorBody);
            errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);
          } catch (e) {
            if (statusCode === 400) {
              errorResponse = {
                error: "authority_not_found",
                errorDescription: "The specified authority URL was not found."
              };
            } else {
              errorResponse = {
                error: "unknown_error",
                errorDescription: `An unknown error has occurred. Response body:

${errorBody}`
              };
            }
          }
        } else {
          errorResponse = {
            error: "unknown_error",
            errorDescription: "An unknown error occurred and no additional details are available."
          };
        }
        super(`${errorResponse.error} Status code: ${statusCode}
More details:
${errorResponse.errorDescription}`);
        this.statusCode = statusCode;
        this.errorResponse = errorResponse;
        this.name = AuthenticationErrorName;
      }
    };
    AggregateAuthenticationErrorName = "AggregateAuthenticationError";
    AggregateAuthenticationError = class extends Error {
      constructor(errors, errorMessage) {
        const errorDetail = errors.join("\n");
        super(`${errorMessage}
${errorDetail}`);
        this.errors = errors;
        this.name = AggregateAuthenticationErrorName;
      }
    };
    AuthenticationRequiredError = class extends Error {
      constructor(options) {
        super(options.message);
        this.scopes = options.scopes;
        this.getTokenOptions = options.getTokenOptions;
        this.name = "AuthenticationRequiredError";
      }
    };
  }
});
function getIdentityTokenEndpointSuffix(tenantId) {
  if (tenantId === "adfs") {
    return "oauth2/token";
  } else {
    return "oauth2/v2.0/token";
  }
}
var init_identityTokenEndpoint = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/util/identityTokenEndpoint.js"() {
    "use strict";
  }
});
var SDK_VERSION2, DeveloperSignOnClientId, DefaultTenantId, AzureAuthorityHosts, DefaultAuthorityHost;
var init_constants2 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/constants.js"() {
    "use strict";
    SDK_VERSION2 = `2.1.0`;
    DeveloperSignOnClientId = "04b07795-8ddb-461a-bbee-02f9e1bf7b46";
    DefaultTenantId = "common";
    (function(AzureAuthorityHosts2) {
      AzureAuthorityHosts2["AzureChina"] = "https://login.chinacloudapi.cn";
      AzureAuthorityHosts2["AzureGermany"] = "https://login.microsoftonline.de";
      AzureAuthorityHosts2["AzureGovernment"] = "https://login.microsoftonline.us";
      AzureAuthorityHosts2["AzurePublicCloud"] = "https://login.microsoftonline.com";
    })(AzureAuthorityHosts || (AzureAuthorityHosts = {}));
    DefaultAuthorityHost = AzureAuthorityHosts.AzurePublicCloud;
  }
});
var tracingClient;
var init_tracing = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/util/tracing.js"() {
    "use strict";
    init_src4();
    init_constants2();
    tracingClient = createTracingClient({
      namespace: "Microsoft.AAD",
      packageName: "@azure/identity",
      packageVersion: SDK_VERSION2
    });
  }
});
function processEnvVars(supportedEnvVars) {
  return supportedEnvVars.reduce((acc, envVariable) => {
    if (process.env[envVariable]) {
      acc.assigned.push(envVariable);
    } else {
      acc.missing.push(envVariable);
    }
    return acc;
  }, { missing: [], assigned: [] });
}
function formatSuccess(scope) {
  return `SUCCESS. Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
}
function formatError(scope, error) {
  let message = "ERROR.";
  if (scope === null || scope === void 0 ? void 0 : scope.length) {
    message += ` Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
  }
  return `${message} Error message: ${typeof error === "string" ? error : error.message}.`;
}
function credentialLoggerInstance(title, parent, log2 = logger3) {
  const fullTitle = parent ? `${parent.fullTitle} ${title}` : title;
  function info(message) {
    log2.info(`${fullTitle} =>`, message);
  }
  function warning(message) {
    log2.warning(`${fullTitle} =>`, message);
  }
  return {
    title,
    fullTitle,
    info,
    warning
  };
}
function credentialLogger(title, log2 = logger3) {
  const credLogger = credentialLoggerInstance(title, void 0, log2);
  return Object.assign(Object.assign({}, credLogger), { parent: log2, getToken: credentialLoggerInstance("=> getToken()", credLogger, log2) });
}
var logger3;
var init_logging = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/util/logging.js"() {
    "use strict";
    init_src();
    logger3 = createClientLogger("identity");
  }
});
function getIdentityClientAuthorityHost(options) {
  let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;
  if (isNode) {
    authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;
  }
  return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;
}
var noCorrelationId, IdentityClient;
var init_identityClient = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/client/identityClient.js"() {
    "use strict";
    init_src6();
    init_src3();
    init_src5();
    init_src2();
    init_errors();
    init_identityTokenEndpoint();
    init_constants2();
    init_tracing();
    init_logging();
    noCorrelationId = "noCorrelationId";
    IdentityClient = class extends ServiceClient {
      constructor(options) {
        var _a2, _b;
        const packageDetails = `azsdk-js-identity/${SDK_VERSION2}`;
        const userAgentPrefix = ((_a2 = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a2 === void 0 ? void 0 : _a2.userAgentPrefix) ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
        const baseUri = getIdentityClientAuthorityHost(options);
        if (!baseUri.startsWith("https:")) {
          throw new Error("The authorityHost address must use the 'https' protocol.");
        }
        super(Object.assign(Object.assign({ requestContentType: "application/json; charset=utf-8", retryOptions: {
          maxRetries: 3
        } }, options), { userAgentOptions: {
          userAgentPrefix
        }, baseUri }));
        this.authorityHost = baseUri;
        this.abortControllers = /* @__PURE__ */ new Map();
        this.allowLoggingAccountIdentifiers = (_b = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b === void 0 ? void 0 : _b.allowLoggingAccountIdentifiers;
      }
      async sendTokenRequest(request3, expiresOnParser5) {
        logger3.info(`IdentityClient: sending token request to [${request3.url}]`);
        const response = await this.sendRequest(request3);
        expiresOnParser5 = expiresOnParser5 || ((responseBody) => {
          return Date.now() + responseBody.expires_in * 1e3;
        });
        if (response.bodyAsText && (response.status === 200 || response.status === 201)) {
          const parsedBody = JSON.parse(response.bodyAsText);
          if (!parsedBody.access_token) {
            return null;
          }
          this.logIdentifiers(response);
          const token = {
            accessToken: {
              token: parsedBody.access_token,
              expiresOnTimestamp: expiresOnParser5(parsedBody)
            },
            refreshToken: parsedBody.refresh_token
          };
          logger3.info(`IdentityClient: [${request3.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);
          return token;
        } else {
          const error = new AuthenticationError(response.status, response.bodyAsText);
          logger3.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);
          throw error;
        }
      }
      async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser5, options = {}) {
        if (refreshToken === void 0) {
          return null;
        }
        logger3.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);
        const refreshParams = {
          grant_type: "refresh_token",
          client_id: clientId,
          refresh_token: refreshToken,
          scope: scopes
        };
        if (clientSecret !== void 0) {
          refreshParams.client_secret = clientSecret;
        }
        const query = new URLSearchParams(refreshParams);
        return tracingClient.withSpan("IdentityClient.refreshAccessToken", options, async (updatedOptions) => {
          try {
            const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);
            const request3 = createPipelineRequest({
              url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,
              method: "POST",
              body: query.toString(),
              abortSignal: options.abortSignal,
              headers: createHttpHeaders({
                Accept: "application/json",
                "Content-Type": "application/x-www-form-urlencoded"
              }),
              tracingOptions: updatedOptions.tracingOptions
            });
            const response = await this.sendTokenRequest(request3, expiresOnParser5);
            logger3.info(`IdentityClient: refreshed token for client ID: ${clientId}`);
            return response;
          } catch (err) {
            if (err.name === AuthenticationErrorName && err.errorResponse.error === "interaction_required") {
              logger3.info(`IdentityClient: interaction required for client ID: ${clientId}`);
              return null;
            } else {
              logger3.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);
              throw err;
            }
          }
        });
      }
      // Here is a custom layer that allows us to abort requests that go through MSAL,
      // since MSAL doesn't allow us to pass options all the way through.
      generateAbortSignal(correlationId) {
        const controller = new AbortController();
        const controllers = this.abortControllers.get(correlationId) || [];
        controllers.push(controller);
        this.abortControllers.set(correlationId, controllers);
        const existingOnAbort = controller.signal.onabort;
        controller.signal.onabort = (...params) => {
          this.abortControllers.set(correlationId, void 0);
          if (existingOnAbort) {
            existingOnAbort(...params);
          }
        };
        return controller.signal;
      }
      abortRequests(correlationId) {
        const key = correlationId || noCorrelationId;
        const controllers = [
          ...this.abortControllers.get(key) || [],
          // MSAL passes no correlation ID to the get requests...
          ...this.abortControllers.get(noCorrelationId) || []
        ];
        if (!controllers.length) {
          return;
        }
        for (const controller of controllers) {
          controller.abort();
        }
        this.abortControllers.set(key, void 0);
      }
      getCorrelationId(options) {
        var _a2;
        const parameter = (_a2 = options === null || options === void 0 ? void 0 : options.body) === null || _a2 === void 0 ? void 0 : _a2.split("&").map((part) => part.split("=")).find(([key]) => key === "client-request-id");
        return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;
      }
      // The MSAL network module methods follow
      async sendGetRequestAsync(url, options) {
        const request3 = createPipelineRequest({
          url,
          method: "GET",
          body: options === null || options === void 0 ? void 0 : options.body,
          headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),
          abortSignal: this.generateAbortSignal(noCorrelationId)
        });
        const response = await this.sendRequest(request3);
        this.logIdentifiers(response);
        return {
          body: response.bodyAsText ? JSON.parse(response.bodyAsText) : void 0,
          headers: response.headers.toJSON(),
          status: response.status
        };
      }
      async sendPostRequestAsync(url, options) {
        const request3 = createPipelineRequest({
          url,
          method: "POST",
          body: options === null || options === void 0 ? void 0 : options.body,
          headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),
          // MSAL doesn't send the correlation ID on the get requests.
          abortSignal: this.generateAbortSignal(this.getCorrelationId(options))
        });
        const response = await this.sendRequest(request3);
        this.logIdentifiers(response);
        return {
          body: response.bodyAsText ? JSON.parse(response.bodyAsText) : void 0,
          headers: response.headers.toJSON(),
          status: response.status
        };
      }
      /**
       * If allowLoggingAccountIdentifiers was set on the constructor options
       * we try to log the account identifiers by parsing the received access token.
       *
       * The account identifiers we try to log are:
       * - `appid`: The application or Client Identifier.
       * - `upn`: User Principal Name.
       *   - It might not be available in some authentication scenarios.
       *   - If it's not available, we put a placeholder: "No User Principal Name available".
       * - `tid`: Tenant Identifier.
       * - `oid`: Object Identifier of the authenticated user.
       */
      logIdentifiers(response) {
        if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {
          return;
        }
        const unavailableUpn = "No User Principal Name available";
        try {
          const parsed = response.parsedBody || JSON.parse(response.bodyAsText);
          const accessToken = parsed.access_token;
          if (!accessToken) {
            return;
          }
          const base64Metadata = accessToken.split(".")[1];
          const { appid, upn, tid, oid } = JSON.parse(Buffer.from(base64Metadata, "base64").toString("utf8"));
          logger3.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);
        } catch (e) {
          logger3.warning("allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:", e.message);
        }
      }
    };
  }
});
function checkTenantId(logger25, tenantId) {
  if (!tenantId.match(/^[0-9a-zA-Z-.:/]+$/)) {
    const error = new Error("Invalid tenant id provided. You can locate your tenant id by following the instructions listed here: https://docs.microsoft.com/partner-center/find-ids-and-domain-names.");
    logger25.info(formatError("", error));
    throw error;
  }
}
var init_checkTenantId = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/util/checkTenantId.js"() {
    "use strict";
    init_logging();
  }
});
function resolveTenantId(logger25, tenantId, clientId) {
  if (tenantId) {
    checkTenantId(logger25, tenantId);
    return tenantId;
  }
  if (!clientId) {
    clientId = DeveloperSignOnClientId;
  }
  if (clientId !== DeveloperSignOnClientId) {
    return "common";
  }
  return "organizations";
}
var init_resolveTenantId = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/util/resolveTenantId.js"() {
    "use strict";
    init_constants2();
    init_checkTenantId();
  }
});
function ensureValidMsalToken(scopes, logger25, msalToken, getTokenOptions) {
  const error = (message) => {
    logger25.getToken.info(message);
    return new AuthenticationRequiredError({
      scopes: Array.isArray(scopes) ? scopes : [scopes],
      getTokenOptions,
      message
    });
  };
  if (!msalToken) {
    throw error("No response");
  }
  if (!msalToken.expiresOn) {
    throw error(`Response had no "expiresOn" property.`);
  }
  if (!msalToken.accessToken) {
    throw error(`Response had no "accessToken" property.`);
  }
}
function getAuthority(tenantId, host) {
  if (!host) {
    host = DefaultAuthorityHost;
  }
  if (new RegExp(`${tenantId}/?$`).test(host)) {
    return host;
  }
  if (host.endsWith("/")) {
    return host + tenantId;
  } else {
    return `${host}/${tenantId}`;
  }
}
function getKnownAuthorities(tenantId, authorityHost) {
  if (tenantId === "adfs" && authorityHost) {
    return [authorityHost];
  }
  return [];
}
function publicToMsal(account) {
  const [environment] = account.authority.match(/([a-z]*\.[a-z]*\.[a-z]*)/) || [];
  return Object.assign(Object.assign({}, account), { localAccountId: account.homeAccountId, environment });
}
function msalToPublic(clientId, account) {
  const record = {
    authority: getAuthority(account.tenantId, account.environment),
    homeAccountId: account.homeAccountId,
    tenantId: account.tenantId || DefaultTenantId,
    username: account.username,
    clientId,
    version: LatestAuthenticationRecordVersion
  };
  return record;
}
function serializeAuthenticationRecord(record) {
  return JSON.stringify(record);
}
function deserializeAuthenticationRecord(serializedRecord) {
  const parsed = JSON.parse(serializedRecord);
  if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {
    throw Error("Unsupported AuthenticationRecord version");
  }
  return parsed;
}
var LatestAuthenticationRecordVersion, defaultLoggerCallback, MsalBaseUtilities;
var init_utils2 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/msal/utils.js"() {
    "use strict";
    init_dist();
    init_src3();
    init_src2();
    init_esm_node();
    init_logging();
    init_errors();
    init_constants2();
    LatestAuthenticationRecordVersion = "1.0";
    defaultLoggerCallback = (logger25, platform = isNode ? "Node" : "Browser") => (level, message, containsPii) => {
      if (containsPii) {
        return;
      }
      switch (level) {
        case LogLevel.Error:
          logger25.info(`MSAL ${platform} V2 error: ${message}`);
          return;
        case LogLevel.Info:
          logger25.info(`MSAL ${platform} V2 info message: ${message}`);
          return;
        case LogLevel.Verbose:
          logger25.info(`MSAL ${platform} V2 verbose message: ${message}`);
          return;
        case LogLevel.Warning:
          logger25.info(`MSAL ${platform} V2 warning: ${message}`);
          return;
      }
    };
    MsalBaseUtilities = class {
      constructor(options) {
        this.logger = options.logger;
        this.account = options.authenticationRecord;
      }
      /**
       * Generates a UUID
       */
      generateUuid() {
        return v4_default();
      }
      /**
       * Handles the MSAL authentication result.
       * If the result has an account, we update the local account reference.
       * If the token received is invalid, an error will be thrown depending on what's missing.
       */
      handleResult(scopes, clientId, result, getTokenOptions) {
        if (result === null || result === void 0 ? void 0 : result.account) {
          this.account = msalToPublic(clientId, result.account);
        }
        ensureValidMsalToken(scopes, this.logger, result, getTokenOptions);
        this.logger.getToken.info(formatSuccess(scopes));
        return {
          token: result.accessToken,
          expiresOnTimestamp: result.expiresOn.getTime()
        };
      }
      /**
       * Handles MSAL errors.
       */
      handleError(scopes, error, getTokenOptions) {
        if (error.name === "AuthError" || error.name === "ClientAuthError" || error.name === "BrowserAuthError") {
          const msalError = error;
          switch (msalError.errorCode) {
            case "endpoints_resolution_error":
              this.logger.info(formatError(scopes, error.message));
              return new CredentialUnavailableError(error.message);
            case "device_code_polling_cancelled":
              return new AbortError("The authentication has been aborted by the caller.");
            case "consent_required":
            case "interaction_required":
            case "login_required":
              this.logger.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));
              break;
            default:
              this.logger.info(formatError(scopes, `Failed to acquire token: ${error.message}`));
              break;
          }
        }
        if (error.name === "ClientConfigurationError" || error.name === "BrowserConfigurationAuthError" || error.name === "AbortError") {
          return error;
        }
        return new AuthenticationRequiredError({ scopes, getTokenOptions, message: error.message });
      }
    };
  }
});
function processMultiTenantRequest(tenantId, getTokenOptions) {
  if (!(getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.tenantId)) {
    return tenantId;
  }
  if (process.env.AZURE_IDENTITY_DISABLE_MULTITENANTAUTH) {
    throw new Error(multiTenantDisabledErrorMessage);
  }
  if (tenantId === "adfs") {
    throw new Error(multiTenantADFSErrorMessage);
  }
  return getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.tenantId;
}
var multiTenantDisabledErrorMessage, multiTenantADFSErrorMessage;
var init_validateMultiTenant = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/util/validateMultiTenant.js"() {
    "use strict";
    multiTenantDisabledErrorMessage = "A getToken request was attempted with a tenant different than the tenant configured at the initialization of the credential, but multi-tenant authentication has been disabled by the environment variable AZURE_IDENTITY_DISABLE_MULTITENANTAUTH.";
    multiTenantADFSErrorMessage = "A new tenant Id can't be assigned through the GetTokenOptions when a credential has been originally configured to use the tenant `adfs`.";
  }
});
var RegionalAuthority;
var init_regionalAuthority = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/regionalAuthority.js"() {
    "use strict";
    (function(RegionalAuthority2) {
      RegionalAuthority2["AutoDiscoverRegion"] = "AutoDiscoverRegion";
      RegionalAuthority2["USWest"] = "westus";
      RegionalAuthority2["USWest2"] = "westus2";
      RegionalAuthority2["USCentral"] = "centralus";
      RegionalAuthority2["USEast"] = "eastus";
      RegionalAuthority2["USEast2"] = "eastus2";
      RegionalAuthority2["USNorthCentral"] = "northcentralus";
      RegionalAuthority2["USSouthCentral"] = "southcentralus";
      RegionalAuthority2["USWestCentral"] = "westcentralus";
      RegionalAuthority2["CanadaCentral"] = "canadacentral";
      RegionalAuthority2["CanadaEast"] = "canadaeast";
      RegionalAuthority2["BrazilSouth"] = "brazilsouth";
      RegionalAuthority2["EuropeNorth"] = "northeurope";
      RegionalAuthority2["EuropeWest"] = "westeurope";
      RegionalAuthority2["UKSouth"] = "uksouth";
      RegionalAuthority2["UKWest"] = "ukwest";
      RegionalAuthority2["FranceCentral"] = "francecentral";
      RegionalAuthority2["FranceSouth"] = "francesouth";
      RegionalAuthority2["SwitzerlandNorth"] = "switzerlandnorth";
      RegionalAuthority2["SwitzerlandWest"] = "switzerlandwest";
      RegionalAuthority2["GermanyNorth"] = "germanynorth";
      RegionalAuthority2["GermanyWestCentral"] = "germanywestcentral";
      RegionalAuthority2["NorwayWest"] = "norwaywest";
      RegionalAuthority2["NorwayEast"] = "norwayeast";
      RegionalAuthority2["AsiaEast"] = "eastasia";
      RegionalAuthority2["AsiaSouthEast"] = "southeastasia";
      RegionalAuthority2["JapanEast"] = "japaneast";
      RegionalAuthority2["JapanWest"] = "japanwest";
      RegionalAuthority2["AustraliaEast"] = "australiaeast";
      RegionalAuthority2["AustraliaSouthEast"] = "australiasoutheast";
      RegionalAuthority2["AustraliaCentral"] = "australiacentral";
      RegionalAuthority2["AustraliaCentral2"] = "australiacentral2";
      RegionalAuthority2["IndiaCentral"] = "centralindia";
      RegionalAuthority2["IndiaSouth"] = "southindia";
      RegionalAuthority2["IndiaWest"] = "westindia";
      RegionalAuthority2["KoreaSouth"] = "koreasouth";
      RegionalAuthority2["KoreaCentral"] = "koreacentral";
      RegionalAuthority2["UAECentral"] = "uaecentral";
      RegionalAuthority2["UAENorth"] = "uaenorth";
      RegionalAuthority2["SouthAfricaNorth"] = "southafricanorth";
      RegionalAuthority2["SouthAfricaWest"] = "southafricawest";
      RegionalAuthority2["ChinaNorth"] = "chinanorth";
      RegionalAuthority2["ChinaEast"] = "chinaeast";
      RegionalAuthority2["ChinaNorth2"] = "chinanorth2";
      RegionalAuthority2["ChinaEast2"] = "chinaeast2";
      RegionalAuthority2["GermanyCentral"] = "germanycentral";
      RegionalAuthority2["GermanyNorthEast"] = "germanynortheast";
      RegionalAuthority2["GovernmentUSVirginia"] = "usgovvirginia";
      RegionalAuthority2["GovernmentUSIowa"] = "usgoviowa";
      RegionalAuthority2["GovernmentUSArizona"] = "usgovarizona";
      RegionalAuthority2["GovernmentUSTexas"] = "usgovtexas";
      RegionalAuthority2["GovernmentUSDodEast"] = "usdodeast";
      RegionalAuthority2["GovernmentUSDodCentral"] = "usdodcentral";
    })(RegionalAuthority || (RegionalAuthority = {}));
  }
});
var persistenceProvider, msalNodeFlowCacheControl, MsalNode;
var init_msalNodeCommon = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalNodeCommon.js"() {
    "use strict";
    init_msal_node_esm();
    init_identityClient();
    init_constants2();
    init_resolveTenantId();
    init_errors();
    init_utils2();
    init_validateMultiTenant();
    init_regionalAuthority();
    persistenceProvider = void 0;
    msalNodeFlowCacheControl = {
      setPersistence(pluginProvider) {
        persistenceProvider = pluginProvider;
      }
    };
    MsalNode = class extends MsalBaseUtilities {
      constructor(options) {
        var _a2, _b, _c;
        super(options);
        this.requiresConfidential = false;
        this.msalConfig = this.defaultNodeMsalConfig(options);
        this.tenantId = resolveTenantId(options.logger, options.tenantId, options.clientId);
        this.clientId = this.msalConfig.auth.clientId;
        if (options === null || options === void 0 ? void 0 : options.getAssertion) {
          this.getAssertion = options.getAssertion;
        }
        if (persistenceProvider !== void 0 && ((_a2 = options.tokenCachePersistenceOptions) === null || _a2 === void 0 ? void 0 : _a2.enabled)) {
          this.createCachePlugin = () => persistenceProvider(options.tokenCachePersistenceOptions);
        } else if ((_b = options.tokenCachePersistenceOptions) === null || _b === void 0 ? void 0 : _b.enabled) {
          throw new Error([
            "Persistent token caching was requested, but no persistence provider was configured.",
            "You must install the identity-cache-persistence plugin package (`npm install --save @azure/identity-cache-persistence`)",
            "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
            "`useIdentityPlugin(cachePersistencePlugin)` before using `tokenCachePersistenceOptions`."
          ].join(" "));
        }
        this.azureRegion = (_c = options.regionalAuthority) !== null && _c !== void 0 ? _c : process.env.AZURE_REGIONAL_AUTHORITY_NAME;
        if (this.azureRegion === RegionalAuthority.AutoDiscoverRegion) {
          this.azureRegion = "AUTO_DISCOVER";
        }
      }
      /**
       * Generates a MSAL configuration that generally works for Node.js
       */
      defaultNodeMsalConfig(options) {
        const clientId = options.clientId || DeveloperSignOnClientId;
        const tenantId = resolveTenantId(options.logger, options.tenantId, options.clientId);
        this.authorityHost = options.authorityHost || process.env.AZURE_AUTHORITY_HOST;
        const authority = getAuthority(tenantId, this.authorityHost);
        this.identityClient = new IdentityClient(Object.assign(Object.assign({}, options.tokenCredentialOptions), { authorityHost: authority, loggingOptions: options.loggingOptions }));
        let clientCapabilities = ["cp1"];
        if (process.env.AZURE_IDENTITY_DISABLE_CP1) {
          clientCapabilities = [];
        }
        return {
          auth: {
            clientId,
            authority,
            knownAuthorities: getKnownAuthorities(tenantId, authority),
            clientCapabilities
          },
          // Cache is defined in this.prepare();
          system: {
            networkClient: this.identityClient,
            loggerOptions: {
              loggerCallback: defaultLoggerCallback(options.logger)
            }
          }
        };
      }
      /**
       * Prepares the MSAL applications.
       */
      async init(options) {
        if (options === null || options === void 0 ? void 0 : options.abortSignal) {
          options.abortSignal.addEventListener("abort", () => {
            this.identityClient.abortRequests(options.correlationId);
          });
        }
        if (this.publicApp || this.confidentialApp) {
          return;
        }
        if (this.createCachePlugin !== void 0) {
          this.msalConfig.cache = {
            cachePlugin: await this.createCachePlugin()
          };
        }
        this.publicApp = new PublicClientApplication(this.msalConfig);
        if (this.getAssertion) {
          this.msalConfig.auth.clientAssertion = await this.getAssertion();
        }
        if (this.msalConfig.auth.clientSecret || this.msalConfig.auth.clientAssertion || this.msalConfig.auth.clientCertificate) {
          this.confidentialApp = new ConfidentialClientApplication(this.msalConfig);
        } else {
          if (this.requiresConfidential) {
            throw new Error("Unable to generate the MSAL confidential client. Missing either the client's secret, certificate or assertion.");
          }
        }
      }
      /**
       * Allows the cancellation of a MSAL request.
       */
      withCancellation(promise, abortSignal2, onCancel) {
        return new Promise((resolve, reject) => {
          promise.then((msalToken) => {
            return resolve(msalToken);
          }).catch(reject);
          if (abortSignal2) {
            abortSignal2.addEventListener("abort", () => {
              onCancel === null || onCancel === void 0 ? void 0 : onCancel();
            });
          }
        });
      }
      /**
       * Returns the existing account, attempts to load the account from MSAL.
       */
      async getActiveAccount() {
        var _a2, _b, _c;
        if (this.account) {
          return this.account;
        }
        const cache = (_b = (_a2 = this.confidentialApp) === null || _a2 === void 0 ? void 0 : _a2.getTokenCache()) !== null && _b !== void 0 ? _b : (_c = this.publicApp) === null || _c === void 0 ? void 0 : _c.getTokenCache();
        const accountsByTenant = await (cache === null || cache === void 0 ? void 0 : cache.getAllAccounts());
        if (!accountsByTenant) {
          return;
        }
        if (accountsByTenant.length === 1) {
          this.account = msalToPublic(this.clientId, accountsByTenant[0]);
        } else {
          this.logger.info(`More than one account was found authenticated for this Client ID and Tenant ID.
However, no "authenticationRecord" has been provided for this credential,
therefore we're unable to pick between these accounts.
A new login attempt will be requested, to ensure the correct account is picked.
To work with multiple accounts for the same Client ID and Tenant ID, please provide an "authenticationRecord" when initializing a credential to prevent this from happening.`);
          return;
        }
        return this.account;
      }
      /**
       * Attempts to retrieve a token from cache.
       */
      async getTokenSilent(scopes, options) {
        var _a2, _b;
        await this.getActiveAccount();
        if (!this.account) {
          throw new AuthenticationRequiredError({
            scopes,
            getTokenOptions: options,
            message: "Silent authentication failed. We couldn't retrieve an active account from the cache."
          });
        }
        const silentRequest = {
          // To be able to re-use the account, the Token Cache must also have been provided.
          account: publicToMsal(this.account),
          correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
          scopes,
          authority: options === null || options === void 0 ? void 0 : options.authority,
          claims: options === null || options === void 0 ? void 0 : options.claims
        };
        try {
          this.logger.info("Attempting to acquire token silently");
          const response = (_b = await ((_a2 = this.confidentialApp) === null || _a2 === void 0 ? void 0 : _a2.acquireTokenSilent(silentRequest))) !== null && _b !== void 0 ? _b : await this.publicApp.acquireTokenSilent(silentRequest);
          return this.handleResult(scopes, this.clientId, response || void 0);
        } catch (err) {
          throw this.handleError(scopes, err, options);
        }
      }
      /**
       * Wrapper around each MSAL flow get token operation: doGetToken.
       * If disableAutomaticAuthentication is sent through the constructor, it will prevent MSAL from requesting the user input.
       */
      async getToken(scopes, options = {}) {
        const tenantId = processMultiTenantRequest(this.tenantId, options) || this.tenantId;
        options.authority = getAuthority(tenantId, this.authorityHost);
        options.correlationId = (options === null || options === void 0 ? void 0 : options.correlationId) || this.generateUuid();
        await this.init(options);
        try {
          const optionsClaims = options.claims;
          if (optionsClaims) {
            this.cachedClaims = optionsClaims;
          }
          if (this.cachedClaims && !optionsClaims) {
            options.claims = this.cachedClaims;
          }
          return await this.getTokenSilent(scopes, options);
        } catch (err) {
          if (err.name !== "AuthenticationRequiredError") {
            throw err;
          }
          if (options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication) {
            throw new AuthenticationRequiredError({
              scopes,
              getTokenOptions: options,
              message: "Automatic authentication has been disabled. You may call the authentication() method."
            });
          }
          this.logger.info(`Silent authentication failed, falling back to interactive method.`);
          return this.doGetToken(scopes, options);
        }
      }
    };
  }
});
function checkUnsupportedTenant(tenantId) {
  const unsupportedTenantError = unsupportedTenantIds[tenantId];
  if (unsupportedTenantError) {
    throw new CredentialUnavailableError(unsupportedTenantError);
  }
}
function getPropertyFromVSCode(property) {
  const settingsPath = ["User", "settings.json"];
  const vsCodeFolder = "Code";
  const homedir = import_os2.default.homedir();
  function loadProperty(...pathSegments) {
    const fullPath = import_path.default.join(...pathSegments, vsCodeFolder, ...settingsPath);
    const settings = JSON.parse(import_fs.default.readFileSync(fullPath, { encoding: "utf8" }));
    return settings[property];
  }
  try {
    let appData;
    switch (process.platform) {
      case "win32":
        appData = process.env.APPDATA;
        return appData ? loadProperty(appData) : void 0;
      case "darwin":
        return loadProperty(homedir, "Library", "Application Support");
      case "linux":
        return loadProperty(homedir, ".config");
      default:
        return;
    }
  } catch (e) {
    logger4.info(`Failed to load the Visual Studio Code configuration file. Error: ${e.message}`);
    return;
  }
}
var CommonTenantId, AzureAccountClientId, logger4, findCredentials, vsCodeCredentialControl, unsupportedTenantIds, mapVSCodeAuthorityHosts, VisualStudioCodeCredential;
var init_visualStudioCodeCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/visualStudioCodeCredential.js"() {
    "use strict";
    init_constants2();
    init_checkTenantId();
    init_errors();
    init_identityClient();
    init_validateMultiTenant();
    init_logging();
    CommonTenantId = "common";
    AzureAccountClientId = "aebc6443-996d-45c2-90f0-388ff96faa56";
    logger4 = credentialLogger("VisualStudioCodeCredential");
    findCredentials = void 0;
    vsCodeCredentialControl = {
      setVsCodeCredentialFinder(finder) {
        findCredentials = finder;
      }
    };
    unsupportedTenantIds = {
      adfs: "The VisualStudioCodeCredential does not support authentication with ADFS tenants."
    };
    mapVSCodeAuthorityHosts = {
      AzureCloud: AzureAuthorityHosts.AzurePublicCloud,
      AzureChina: AzureAuthorityHosts.AzureChina,
      AzureGermanCloud: AzureAuthorityHosts.AzureGermany,
      AzureUSGovernment: AzureAuthorityHosts.AzureGovernment
    };
    VisualStudioCodeCredential = class {
      /**
       * Creates an instance of VisualStudioCodeCredential to use for automatically authenticating via VSCode.
       *
       * **Note**: `VisualStudioCodeCredential` is provided by a plugin package:
       * `@azure/identity-vscode`. If this package is not installed and registered
       * using the plugin API (`useIdentityPlugin`), then authentication using
       * `VisualStudioCodeCredential` will not be available.
       *
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(options) {
        this.cloudName = getPropertyFromVSCode("azure.cloud") || "AzureCloud";
        const authorityHost = mapVSCodeAuthorityHosts[this.cloudName];
        this.identityClient = new IdentityClient(Object.assign({ authorityHost }, options));
        if (options && options.tenantId) {
          checkTenantId(logger4, options.tenantId);
          this.tenantId = options.tenantId;
        } else {
          this.tenantId = CommonTenantId;
        }
        checkUnsupportedTenant(this.tenantId);
      }
      /**
       * Runs preparations for any further getToken request.
       */
      async prepare() {
        const settingsTenant = getPropertyFromVSCode("azure.tenant");
        if (settingsTenant) {
          this.tenantId = settingsTenant;
        }
        checkUnsupportedTenant(this.tenantId);
      }
      /**
       * Runs preparations for any further getToken, but only once.
       */
      prepareOnce() {
        if (!this.preparePromise) {
          this.preparePromise = this.prepare();
        }
        return this.preparePromise;
      }
      /**
       * Returns the token found by searching VSCode's authentication cache or
       * returns null if no token could be found.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                `TokenCredential` implementation might make.
       */
      async getToken(scopes, options) {
        var _a2, _b;
        await this.prepareOnce();
        const tenantId = processMultiTenantRequest(this.tenantId, options) || this.tenantId;
        if (findCredentials === void 0) {
          throw new CredentialUnavailableError([
            "No implementation of `VisualStudioCodeCredential` is available.",
            "You must install the identity-vscode plugin package (`npm install --save-dev @azure/identity-vscode`)",
            "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
            "`useIdentityPlugin(vsCodePlugin)` before creating a `VisualStudioCodeCredential`."
          ].join(" "));
        }
        let scopeString = typeof scopes === "string" ? scopes : scopes.join(" ");
        if (!scopeString.match(/^[0-9a-zA-Z-.:/]+$/)) {
          const error = new Error("Invalid scope was specified by the user or calling client");
          logger4.getToken.info(formatError(scopes, error));
          throw error;
        }
        if (scopeString.indexOf("offline_access") < 0) {
          scopeString += " offline_access";
        }
        const credentials = await findCredentials();
        const { password: refreshToken } = (_b = (_a2 = credentials.find(({ account }) => account === this.cloudName)) !== null && _a2 !== void 0 ? _a2 : credentials[0]) !== null && _b !== void 0 ? _b : {};
        if (refreshToken) {
          const tokenResponse = await this.identityClient.refreshAccessToken(tenantId, AzureAccountClientId, scopeString, refreshToken, void 0);
          if (tokenResponse) {
            logger4.getToken.info(formatSuccess(scopes));
            return tokenResponse.accessToken;
          } else {
            const error = new CredentialUnavailableError("Could not retrieve the token associated with Visual Studio Code. Have you connected using the 'Azure Account' extension recently? To troubleshoot, visit https://aka.ms/azsdk/js/identity/vscodecredential/troubleshoot.");
            logger4.getToken.info(formatError(scopes, error));
            throw error;
          }
        } else {
          const error = new CredentialUnavailableError("Could not retrieve the token associated with Visual Studio Code. Did you connect using the 'Azure Account' extension? To troubleshoot, visit https://aka.ms/azsdk/js/identity/vscodecredential/troubleshoot.");
          logger4.getToken.info(formatError(scopes, error));
          throw error;
        }
      }
    };
  }
});
function useIdentityPlugin(plugin) {
  plugin(pluginContext);
}
var pluginContext;
var init_consumer = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/plugins/consumer.js"() {
    "use strict";
    init_msalNodeCommon();
    init_visualStudioCodeCredential();
    pluginContext = {
      cachePluginControl: msalNodeFlowCacheControl,
      vsCodeCredentialControl
    };
  }
});
var logger5, ChainedTokenCredential;
var init_chainedTokenCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/chainedTokenCredential.js"() {
    "use strict";
    init_errors();
    init_tracing();
    init_logging();
    logger5 = credentialLogger("ChainedTokenCredential");
    ChainedTokenCredential = class {
      /**
       * Creates an instance of ChainedTokenCredential using the given credentials.
       *
       * @param sources - `TokenCredential` implementations to be tried in order.
       *
       * Example usage:
       * ```javascript
       * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
       * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);
       * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);
       * ```
       */
      constructor(...sources) {
        this.UnavailableMessage = "ChainedTokenCredential => failed to retrieve a token from the included credentials";
        this._sources = [];
        this._sources = sources;
      }
      /**
       * Returns the first access token returned by one of the chained
       * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}
       * when one or more credentials throws an {@link AuthenticationError} and
       * no credentials have returned an access token.
       *
       * This method is called automatically by Azure SDK client libraries. You may call this method
       * directly, but you must also handle token caching and token refreshing.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                `TokenCredential` implementation might make.
       */
      async getToken(scopes, options = {}) {
        let token = null;
        let successfulCredentialName = "";
        const errors = [];
        return tracingClient.withSpan("ChainedTokenCredential.getToken", options, async (updatedOptions) => {
          for (let i = 0; i < this._sources.length && token === null; i++) {
            try {
              token = await this._sources[i].getToken(scopes, updatedOptions);
              successfulCredentialName = this._sources[i].constructor.name;
            } catch (err) {
              if (err.name === "CredentialUnavailableError" || err.name === "AuthenticationRequiredError") {
                errors.push(err);
              } else {
                logger5.getToken.info(formatError(scopes, err));
                throw err;
              }
            }
          }
          if (!token && errors.length > 0) {
            const err = new AggregateAuthenticationError(errors, "ChainedTokenCredential authentication failed.");
            logger5.getToken.info(formatError(scopes, err));
            throw err;
          }
          logger5.getToken.info(`Result for ${successfulCredentialName}: ${formatSuccess(scopes)}`);
          if (token === null) {
            throw new CredentialUnavailableError("Failed to retrieve a valid token");
          }
          return token;
        });
      }
    };
  }
});
function ensureValidScope(scope, logger25) {
  if (!scope.match(/^[0-9a-zA-Z-.:/]+$/)) {
    const error = new Error("Invalid scope was specified by the user or calling client");
    logger25.getToken.info(formatError(scope, error));
    throw error;
  }
}
function getScopeResource(scope) {
  return scope.replace(/\/.default$/, "");
}
var init_scopeUtils = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/util/scopeUtils.js"() {
    "use strict";
    init_logging();
  }
});
var cliCredentialInternals, logger6, AzureCliCredential;
var init_azureCliCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/azureCliCredential.js"() {
    "use strict";
    init_tracing();
    init_errors();
    init_logging();
    init_scopeUtils();
    init_validateMultiTenant();
    init_checkTenantId();
    cliCredentialInternals = {
      /**
       * @internal
       */
      getSafeWorkingDir() {
        if (process.platform === "win32") {
          if (!process.env.SystemRoot) {
            throw new Error("Azure CLI credential expects a 'SystemRoot' environment variable");
          }
          return process.env.SystemRoot;
        } else {
          return "/bin";
        }
      },
      /**
       * Gets the access token from Azure CLI
       * @param resource - The resource to use when getting the token
       * @internal
       */
      async getAzureCliAccessToken(resource, tenantId) {
        let tenantSection = [];
        if (tenantId) {
          tenantSection = ["--tenant", tenantId];
        }
        return new Promise((resolve, reject) => {
          try {
            import_child_process.default.execFile("az", [
              "account",
              "get-access-token",
              "--output",
              "json",
              "--resource",
              resource,
              ...tenantSection
            ], { cwd: cliCredentialInternals.getSafeWorkingDir(), shell: true }, (error, stdout, stderr) => {
              resolve({ stdout, stderr, error });
            });
          } catch (err) {
            reject(err);
          }
        });
      }
    };
    logger6 = credentialLogger("AzureCliCredential");
    AzureCliCredential = class {
      /**
       * Creates an instance of the {@link AzureCliCredential}.
       *
       * To use this credential, ensure that you have already logged
       * in via the 'az' tool using the command "az login" from the commandline.
       *
       * @param options - Options, to optionally allow multi-tenant requests.
       */
      constructor(options) {
        this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        const tenantId = processMultiTenantRequest(this.tenantId, options);
        if (tenantId) {
          checkTenantId(logger6, tenantId);
        }
        const scope = typeof scopes === "string" ? scopes : scopes[0];
        logger6.getToken.info(`Using the scope ${scope}`);
        ensureValidScope(scope, logger6);
        const resource = getScopeResource(scope);
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
          var _a2, _b, _c, _d;
          try {
            const obj = await cliCredentialInternals.getAzureCliAccessToken(resource, tenantId);
            const specificScope = (_a2 = obj.stderr) === null || _a2 === void 0 ? void 0 : _a2.match("(.*)az login --scope(.*)");
            const isLoginError2 = ((_b = obj.stderr) === null || _b === void 0 ? void 0 : _b.match("(.*)az login(.*)")) && !specificScope;
            const isNotInstallError = ((_c = obj.stderr) === null || _c === void 0 ? void 0 : _c.match("az:(.*)not found")) || ((_d = obj.stderr) === null || _d === void 0 ? void 0 : _d.startsWith("'az' is not recognized"));
            if (isNotInstallError) {
              const error = new CredentialUnavailableError("Azure CLI could not be found. Please visit https://aka.ms/azure-cli for installation instructions and then, once installed, authenticate to your Azure account using 'az login'.");
              logger6.getToken.info(formatError(scopes, error));
              throw error;
            }
            if (isLoginError2) {
              const error = new CredentialUnavailableError("Please run 'az login' from a command prompt to authenticate before using this credential.");
              logger6.getToken.info(formatError(scopes, error));
              throw error;
            }
            try {
              const responseData = obj.stdout;
              const response = JSON.parse(responseData);
              logger6.getToken.info(formatSuccess(scopes));
              const returnValue = {
                token: response.accessToken,
                expiresOnTimestamp: new Date(response.expiresOn).getTime()
              };
              return returnValue;
            } catch (e) {
              if (obj.stderr) {
                throw new CredentialUnavailableError(obj.stderr);
              }
              throw e;
            }
          } catch (err) {
            const error = err.name === "CredentialUnavailableError" ? err : new CredentialUnavailableError(err.message || "Unknown error while trying to retrieve the access token");
            logger6.getToken.info(formatError(scopes, error));
            throw error;
          }
        });
      }
    };
  }
});
var processUtils;
var init_processUtils = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/util/processUtils.js"() {
    "use strict";
    processUtils = {
      /**
       * Promisifying childProcess.execFile
       * @internal
       */
      execFile(file, params, options) {
        return new Promise((resolve, reject) => {
          childProcess.execFile(file, params, options, (error, stdout, stderr) => {
            if (Buffer.isBuffer(stdout)) {
              stdout = stdout.toString("utf8");
            }
            if (Buffer.isBuffer(stderr)) {
              stderr = stderr.toString("utf8");
            }
            if (stderr || error) {
              reject(stderr ? new Error(stderr) : error);
            } else {
              resolve(stdout);
            }
          });
        });
      }
    };
  }
});
function formatCommand(commandName) {
  if (isWindows) {
    return `${commandName}.exe`;
  } else {
    return commandName;
  }
}
async function runCommands(commands) {
  const results = [];
  for (const command of commands) {
    const [file, ...parameters] = command;
    const result = await processUtils.execFile(file, parameters, { encoding: "utf8" });
    results.push(result);
  }
  return results;
}
var logger7, isWindows, powerShellErrors, powerShellPublicErrorMessages, isLoginError, isNotInstalledError, commandStack, AzurePowerShellCredential;
var init_azurePowerShellCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/azurePowerShellCredential.js"() {
    "use strict";
    init_errors();
    init_logging();
    init_tracing();
    init_scopeUtils();
    init_processUtils();
    init_validateMultiTenant();
    init_checkTenantId();
    logger7 = credentialLogger("AzurePowerShellCredential");
    isWindows = process.platform === "win32";
    powerShellErrors = {
      login: "Run Connect-AzAccount to login",
      installed: "The specified module 'Az.Accounts' with version '2.2.0' was not loaded because no valid module file was found in any module directory"
    };
    powerShellPublicErrorMessages = {
      login: "Please run 'Connect-AzAccount' from PowerShell to authenticate before using this credential.",
      installed: `The 'Az.Account' module >= 2.2.0 is not installed. Install the Azure Az PowerShell module with: "Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force".`,
      troubleshoot: `To troubleshoot, visit https://aka.ms/azsdk/js/identity/powershellcredential/troubleshoot.`
    };
    isLoginError = (err) => err.message.match(`(.*)${powerShellErrors.login}(.*)`);
    isNotInstalledError = (err) => err.message.match(powerShellErrors.installed);
    commandStack = [formatCommand("pwsh")];
    if (isWindows) {
      commandStack.push(formatCommand("powershell"));
    }
    AzurePowerShellCredential = class {
      /**
       * Creates an instance of the {@link AzurePowerShellCredential}.
       *
       * To use this credential:
       * - Install the Azure Az PowerShell module with:
       *   `Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force`.
       * - You have already logged in to Azure PowerShell using the command
       * `Connect-AzAccount` from the command line.
       *
       * @param options - Options, to optionally allow multi-tenant requests.
       */
      constructor(options) {
        this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;
      }
      /**
       * Gets the access token from Azure PowerShell
       * @param resource - The resource to use when getting the token
       */
      async getAzurePowerShellAccessToken(resource, tenantId) {
        for (const powerShellCommand of [...commandStack]) {
          try {
            await runCommands([[powerShellCommand, "/?"]]);
          } catch (e) {
            commandStack.shift();
            continue;
          }
          let tenantSection = "";
          if (tenantId) {
            tenantSection = `-TenantId "${tenantId}"`;
          }
          const results = await runCommands([
            [
              powerShellCommand,
              "-Command",
              "Import-Module Az.Accounts -MinimumVersion 2.2.0 -PassThru"
            ],
            [
              powerShellCommand,
              "-Command",
              `Get-AzAccessToken ${tenantSection} -ResourceUrl "${resource}" | ConvertTo-Json`
            ]
          ]);
          const result = results[1];
          try {
            return JSON.parse(result);
          } catch (e) {
            throw new Error(`Unable to parse the output of PowerShell. Received output: ${result}`);
          }
        }
        throw new Error(`Unable to execute PowerShell. Ensure that it is installed in your system`);
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If the authentication cannot be performed through PowerShell, a {@link CredentialUnavailableError} will be thrown.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
          const tenantId = processMultiTenantRequest(this.tenantId, options);
          if (tenantId) {
            checkTenantId(logger7, tenantId);
          }
          const scope = typeof scopes === "string" ? scopes : scopes[0];
          ensureValidScope(scope, logger7);
          logger7.getToken.info(`Using the scope ${scope}`);
          const resource = getScopeResource(scope);
          try {
            const response = await this.getAzurePowerShellAccessToken(resource, tenantId);
            logger7.getToken.info(formatSuccess(scopes));
            return {
              token: response.Token,
              expiresOnTimestamp: new Date(response.ExpiresOn).getTime()
            };
          } catch (err) {
            if (isNotInstalledError(err)) {
              const error2 = new CredentialUnavailableError(powerShellPublicErrorMessages.installed);
              logger7.getToken.info(formatError(scope, error2));
              throw error2;
            } else if (isLoginError(err)) {
              const error2 = new CredentialUnavailableError(powerShellPublicErrorMessages.login);
              logger7.getToken.info(formatError(scope, error2));
              throw error2;
            }
            const error = new CredentialUnavailableError(`${err}. ${powerShellPublicErrorMessages.troubleshoot}`);
            logger7.getToken.info(formatError(scope, error));
            throw error;
          }
        });
      }
    };
  }
});
var MsalClientSecret;
var init_msalClientSecret = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalClientSecret.js"() {
    "use strict";
    init_msalNodeCommon();
    MsalClientSecret = class extends MsalNode {
      constructor(options) {
        super(options);
        this.requiresConfidential = true;
        this.msalConfig.auth.clientSecret = options.clientSecret;
      }
      async doGetToken(scopes, options = {}) {
        try {
          const result = await this.confidentialApp.acquireTokenByClientCredential({
            scopes,
            correlationId: options.correlationId,
            azureRegion: this.azureRegion,
            authority: options.authority,
            claims: options.claims
          });
          return this.handleResult(scopes, this.clientId, result || void 0);
        } catch (err) {
          throw this.handleError(scopes, err, options);
        }
      }
    };
  }
});
var logger8, ClientSecretCredential;
var init_clientSecretCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/clientSecretCredential.js"() {
    "use strict";
    init_msalClientSecret();
    init_logging();
    init_tracing();
    logger8 = credentialLogger("ClientSecretCredential");
    ClientSecretCredential = class {
      /**
       * Creates an instance of the ClientSecretCredential with the details
       * needed to authenticate against Azure Active Directory with a client
       * secret.
       *
       * @param tenantId - The Azure Active Directory tenant (directory) ID.
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param clientSecret - A client secret that was generated for the App Registration.
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(tenantId, clientId, clientSecret, options = {}) {
        if (!tenantId || !clientId || !clientSecret) {
          throw new Error("ClientSecretCredential: tenantId, clientId, and clientSecret are required parameters. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.");
        }
        this.msalFlow = new MsalClientSecret(Object.assign(Object.assign({}, options), {
          logger: logger8,
          clientId,
          tenantId,
          clientSecret,
          tokenCredentialOptions: options
        }));
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          return this.msalFlow.getToken(arrayScopes, newOptions);
        });
      }
    };
  }
});
async function parseCertificate(configuration, sendCertificateChain) {
  const certificateParts = {};
  const certificate = configuration.certificate;
  const certificatePath = configuration.certificatePath;
  certificateParts.certificateContents = certificate || await readFileAsync(certificatePath, "utf8");
  if (sendCertificateChain) {
    certificateParts.x5c = certificateParts.certificateContents;
  }
  const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/g;
  const publicKeys = [];
  let match;
  do {
    match = certificatePattern.exec(certificateParts.certificateContents);
    if (match) {
      publicKeys.push(match[3]);
    }
  } while (match);
  if (publicKeys.length === 0) {
    throw new Error("The file at the specified path does not contain a PEM-encoded certificate.");
  }
  certificateParts.thumbprint = (0, import_crypto3.createHash)("sha1").update(Buffer.from(publicKeys[0], "base64")).digest("hex").toUpperCase();
  return certificateParts;
}
var readFileAsync, MsalClientCertificate;
var init_msalClientCertificate = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalClientCertificate.js"() {
    "use strict";
    init_msalNodeCommon();
    init_logging();
    readFileAsync = (0, import_util3.promisify)(import_fs2.readFile);
    MsalClientCertificate = class extends MsalNode {
      constructor(options) {
        super(options);
        this.requiresConfidential = true;
        this.configuration = options.configuration;
        this.sendCertificateChain = options.sendCertificateChain;
      }
      // Changing the MSAL configuration asynchronously
      async init(options) {
        try {
          const parts = await parseCertificate(this.configuration, this.sendCertificateChain);
          this.msalConfig.auth.clientCertificate = {
            thumbprint: parts.thumbprint,
            privateKey: parts.certificateContents,
            x5c: parts.x5c
          };
        } catch (error) {
          this.logger.info(formatError("", error));
          throw error;
        }
        return super.init(options);
      }
      async doGetToken(scopes, options = {}) {
        try {
          const clientCredReq = {
            scopes,
            correlationId: options.correlationId,
            azureRegion: this.azureRegion,
            authority: options.authority,
            claims: options.claims
          };
          const result = await this.confidentialApp.acquireTokenByClientCredential(clientCredReq);
          return this.handleResult(scopes, this.clientId, result || void 0);
        } catch (err) {
          throw this.handleError(scopes, err, options);
        }
      }
    };
  }
});
var credentialName, logger9, ClientCertificateCredential;
var init_clientCertificateCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/clientCertificateCredential.js"() {
    "use strict";
    init_msalClientCertificate();
    init_logging();
    init_tracing();
    credentialName = "ClientCertificateCredential";
    logger9 = credentialLogger(credentialName);
    ClientCertificateCredential = class {
      constructor(tenantId, clientId, certificatePathOrConfiguration, options = {}) {
        if (!tenantId || !clientId) {
          throw new Error(`${credentialName}: tenantId and clientId are required parameters.`);
        }
        const configuration = Object.assign({}, typeof certificatePathOrConfiguration === "string" ? {
          certificatePath: certificatePathOrConfiguration
        } : certificatePathOrConfiguration);
        const certificate = configuration.certificate;
        const certificatePath = configuration.certificatePath;
        if (!configuration || !(certificate || certificatePath)) {
          throw new Error(`${credentialName}: Provide either a PEM certificate in string form, or the path to that certificate in the filesystem. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
        }
        if (certificate && certificatePath) {
          throw new Error(`${credentialName}: To avoid unexpected behaviors, providing both the contents of a PEM certificate and the path to a PEM certificate is forbidden. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
        }
        this.msalFlow = new MsalClientCertificate(Object.assign(Object.assign({}, options), {
          configuration,
          logger: logger9,
          clientId,
          tenantId,
          sendCertificateChain: options.sendCertificateChain,
          tokenCredentialOptions: options
        }));
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${credentialName}.getToken`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          return this.msalFlow.getToken(arrayScopes, newOptions);
        });
      }
    };
  }
});
var MsalUsernamePassword;
var init_msalUsernamePassword = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalUsernamePassword.js"() {
    "use strict";
    init_msalNodeCommon();
    MsalUsernamePassword = class extends MsalNode {
      constructor(options) {
        super(options);
        this.username = options.username;
        this.password = options.password;
      }
      async doGetToken(scopes, options) {
        try {
          const requestOptions = {
            scopes,
            username: this.username,
            password: this.password,
            correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
            authority: options === null || options === void 0 ? void 0 : options.authority,
            claims: options === null || options === void 0 ? void 0 : options.claims
          };
          const result = await this.publicApp.acquireTokenByUsernamePassword(requestOptions);
          return this.handleResult(scopes, this.clientId, result || void 0);
        } catch (error) {
          throw this.handleError(scopes, error, options);
        }
      }
    };
  }
});
var logger10, UsernamePasswordCredential;
var init_usernamePasswordCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/usernamePasswordCredential.js"() {
    "use strict";
    init_logging();
    init_msalUsernamePassword();
    init_tracing();
    logger10 = credentialLogger("UsernamePasswordCredential");
    UsernamePasswordCredential = class {
      /**
       * Creates an instance of the UsernamePasswordCredential with the details
       * needed to authenticate against Azure Active Directory with a username
       * and password.
       *
       * @param tenantId - The Azure Active Directory tenant (directory).
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param username - The user account's e-mail address (user name).
       * @param password - The user account's account password
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(tenantId, clientId, username, password, options = {}) {
        if (!tenantId || !clientId || !username || !password) {
          throw new Error("UsernamePasswordCredential: tenantId, clientId, username and password are required parameters. To troubleshoot, visit https://aka.ms/azsdk/js/identity/usernamepasswordcredential/troubleshoot.");
        }
        this.msalFlow = new MsalUsernamePassword(Object.assign(Object.assign({}, options), {
          logger: logger10,
          clientId,
          tenantId,
          username,
          password,
          tokenCredentialOptions: options || {}
        }));
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the user provided the option `disableAutomaticAuthentication`,
       * once the token can't be retrieved silently,
       * this method won't attempt to request user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          return this.msalFlow.getToken(arrayScopes, newOptions);
        });
      }
    };
  }
});
var AllSupportedEnvironmentVariables, credentialName2, logger11, EnvironmentCredential;
var init_environmentCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/environmentCredential.js"() {
    "use strict";
    init_logging();
    init_clientSecretCredential();
    init_errors();
    init_checkTenantId();
    init_tracing();
    init_clientCertificateCredential();
    init_usernamePasswordCredential();
    AllSupportedEnvironmentVariables = [
      "AZURE_TENANT_ID",
      "AZURE_CLIENT_ID",
      "AZURE_CLIENT_SECRET",
      "AZURE_CLIENT_CERTIFICATE_PATH",
      "AZURE_USERNAME",
      "AZURE_PASSWORD"
    ];
    credentialName2 = "EnvironmentCredential";
    logger11 = credentialLogger(credentialName2);
    EnvironmentCredential = class {
      /**
       * Creates an instance of the EnvironmentCredential class and decides what credential to use depending on the available environment variables.
       *
       * Required environment variables:
       * - `AZURE_TENANT_ID`: The Azure Active Directory tenant (directory) ID.
       * - `AZURE_CLIENT_ID`: The client (application) ID of an App Registration in the tenant.
       *
       * Environment variables used for client credential authentication:
       * - `AZURE_CLIENT_SECRET`: A client secret that was generated for the App Registration.
       * - `AZURE_CLIENT_CERTIFICATE_PATH`: The path to a PEM certificate to use during the authentication, instead of the client secret.
       *
       * Alternatively, users can provide environment variables for username and password authentication:
       * - `AZURE_USERNAME`: Username to authenticate with.
       * - `AZURE_PASSWORD`: Password to authenticate with.
       *
       * If the environment variables required to perform the authentication are missing, a {@link CredentialUnavailableError} will be thrown.
       * If the authentication fails, or if there's an unknown error, an {@link AuthenticationError} will be thrown.
       *
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(options) {
        this._credential = void 0;
        const assigned = processEnvVars(AllSupportedEnvironmentVariables).assigned.join(", ");
        logger11.info(`Found the following environment variables: ${assigned}`);
        const tenantId = process.env.AZURE_TENANT_ID, clientId = process.env.AZURE_CLIENT_ID, clientSecret = process.env.AZURE_CLIENT_SECRET;
        if (tenantId) {
          checkTenantId(logger11, tenantId);
        }
        if (tenantId && clientId && clientSecret) {
          logger11.info(`Invoking ClientSecretCredential with tenant ID: ${tenantId}, clientId: ${clientId} and clientSecret: [REDACTED]`);
          this._credential = new ClientSecretCredential(tenantId, clientId, clientSecret, options);
          return;
        }
        const certificatePath = process.env.AZURE_CLIENT_CERTIFICATE_PATH;
        if (tenantId && clientId && certificatePath) {
          logger11.info(`Invoking ClientCertificateCredential with tenant ID: ${tenantId}, clientId: ${clientId} and certificatePath: ${certificatePath}`);
          this._credential = new ClientCertificateCredential(tenantId, clientId, { certificatePath }, options);
          return;
        }
        const username = process.env.AZURE_USERNAME;
        const password = process.env.AZURE_PASSWORD;
        if (tenantId && clientId && username && password) {
          logger11.info(`Invoking UsernamePasswordCredential with tenant ID: ${tenantId}, clientId: ${clientId} and username: ${username}`);
          this._credential = new UsernamePasswordCredential(tenantId, clientId, username, password, options);
        }
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - Optional parameters. See {@link GetTokenOptions}.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${credentialName2}.getToken`, options, async (newOptions) => {
          if (this._credential) {
            try {
              const result = await this._credential.getToken(scopes, newOptions);
              logger11.getToken.info(formatSuccess(scopes));
              return result;
            } catch (err) {
              const authenticationError = new AuthenticationError(400, {
                error: `${credentialName2} authentication failed. To troubleshoot, visit https://aka.ms/azsdk/js/identity/environmentcredential/troubleshoot.`,
                error_description: err.message.toString().split("More details:").join("")
              });
              logger11.getToken.info(formatError(scopes, authenticationError));
              throw authenticationError;
            }
          }
          throw new CredentialUnavailableError(`${credentialName2} is unavailable. No underlying credential could be used. To troubleshoot, visit https://aka.ms/azsdk/js/identity/environmentcredential/troubleshoot.`);
        });
      }
    };
  }
});
var DefaultScopeSuffix, imdsHost, imdsEndpointPath, imdsApiVersion, azureArcAPIVersion, azureFabricVersion;
var init_constants3 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/constants.js"() {
    "use strict";
    DefaultScopeSuffix = "/.default";
    imdsHost = "http://169.254.169.254";
    imdsEndpointPath = "/metadata/identity/oauth2/token";
    imdsApiVersion = "2018-02-01";
    azureArcAPIVersion = "2019-11-01";
    azureFabricVersion = "2019-07-01-preview";
  }
});
function mapScopesToResource(scopes) {
  let scope = "";
  if (Array.isArray(scopes)) {
    if (scopes.length !== 1) {
      return;
    }
    scope = scopes[0];
  } else if (typeof scopes === "string") {
    scope = scopes;
  }
  if (!scope.endsWith(DefaultScopeSuffix)) {
    return scope;
  }
  return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));
}
var init_utils3 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/utils.js"() {
    "use strict";
    init_constants3();
  }
});
function expiresOnParser(requestBody) {
  return Date.parse(requestBody.expires_on);
}
function prepareRequestOptions(scopes, clientId) {
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName}: Multiple scopes are not supported.`);
  }
  const queryParameters = {
    resource,
    "api-version": "2017-09-01"
  };
  if (clientId) {
    queryParameters.clientid = clientId;
  }
  const query = new URLSearchParams(queryParameters);
  if (!process.env.MSI_ENDPOINT) {
    throw new Error(`${msiName}: Missing environment variable: MSI_ENDPOINT`);
  }
  if (!process.env.MSI_SECRET) {
    throw new Error(`${msiName}: Missing environment variable: MSI_SECRET`);
  }
  return {
    url: `${process.env.MSI_ENDPOINT}?${query.toString()}`,
    method: "GET",
    headers: createHttpHeaders({
      Accept: "application/json",
      secret: process.env.MSI_SECRET
    })
  };
}
var msiName, logger12, appServiceMsi2017;
var init_appServiceMsi2017 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/appServiceMsi2017.js"() {
    "use strict";
    init_src5();
    init_logging();
    init_utils3();
    msiName = "ManagedIdentityCredential - AppServiceMSI 2017";
    logger12 = credentialLogger(msiName);
    appServiceMsi2017 = {
      async isAvailable({ scopes }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
          logger12.info(`${msiName}: Unavailable. Multiple scopes are not supported.`);
          return false;
        }
        const env = process.env;
        const result = Boolean(env.MSI_ENDPOINT && env.MSI_SECRET);
        if (!result) {
          logger12.info(`${msiName}: Unavailable. The environment variables needed are: MSI_ENDPOINT and MSI_SECRET.`);
        }
        return result;
      },
      async getToken(configuration, getTokenOptions = {}) {
        const { identityClient, scopes, clientId, resourceId } = configuration;
        if (resourceId) {
          logger12.warning(`${msiName}: managed Identity by resource Id is not supported. Argument resourceId might be ignored by the service.`);
        }
        logger12.info(`${msiName}: Using the endpoint and the secret coming form the environment variables: MSI_ENDPOINT=${process.env.MSI_ENDPOINT} and MSI_SECRET=[REDACTED].`);
        const request3 = createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions(scopes, clientId)), {
          // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
          allowInsecureConnection: true
        }));
        const tokenResponse = await identityClient.sendTokenRequest(request3, expiresOnParser);
        return tokenResponse && tokenResponse.accessToken || null;
      }
    };
  }
});
function prepareRequestOptions2(scopes, clientId, resourceId) {
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName2}: Multiple scopes are not supported.`);
  }
  const body = {
    resource
  };
  if (clientId) {
    body.client_id = clientId;
  }
  if (resourceId) {
    body.msi_res_id = resourceId;
  }
  if (!process.env.MSI_ENDPOINT) {
    throw new Error(`${msiName2}: Missing environment variable: MSI_ENDPOINT`);
  }
  const params = new URLSearchParams(body);
  return {
    url: process.env.MSI_ENDPOINT,
    method: "POST",
    body: params.toString(),
    headers: createHttpHeaders({
      Accept: "application/json",
      Metadata: "true",
      "Content-Type": "application/x-www-form-urlencoded"
    })
  };
}
var msiName2, logger13, cloudShellMsi;
var init_cloudShellMsi = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/cloudShellMsi.js"() {
    "use strict";
    init_src5();
    init_logging();
    init_utils3();
    msiName2 = "ManagedIdentityCredential - CloudShellMSI";
    logger13 = credentialLogger(msiName2);
    cloudShellMsi = {
      async isAvailable({ scopes }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
          logger13.info(`${msiName2}: Unavailable. Multiple scopes are not supported.`);
          return false;
        }
        const result = Boolean(process.env.MSI_ENDPOINT);
        if (!result) {
          logger13.info(`${msiName2}: Unavailable. The environment variable MSI_ENDPOINT is needed.`);
        }
        return result;
      },
      async getToken(configuration, getTokenOptions = {}) {
        const { identityClient, scopes, clientId, resourceId } = configuration;
        if (clientId) {
          logger13.warning(`${msiName2}: user-assigned identities not supported. The argument clientId might be ignored by the service.`);
        }
        if (resourceId) {
          logger13.warning(`${msiName2}: user defined managed Identity by resource Id not supported. The argument resourceId might be ignored by the service.`);
        }
        logger13.info(`${msiName2}: Using the endpoint coming form the environment variable MSI_ENDPOINT = ${process.env.MSI_ENDPOINT}.`);
        const request3 = createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions2(scopes, clientId, resourceId)), {
          // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
          allowInsecureConnection: true
        }));
        const tokenResponse = await identityClient.sendTokenRequest(request3);
        return tokenResponse && tokenResponse.accessToken || null;
      }
    };
  }
});
function expiresOnParser2(requestBody) {
  if (requestBody.expires_on) {
    const expires = +requestBody.expires_on * 1e3;
    logger14.info(`${msiName3}: Using expires_on: ${expires} (original value: ${requestBody.expires_on})`);
    return expires;
  } else {
    const expires = Date.now() + requestBody.expires_in * 1e3;
    logger14.info(`${msiName3}: IMDS using expires_in: ${expires} (original value: ${requestBody.expires_in})`);
    return expires;
  }
}
function prepareRequestOptions3(scopes, clientId, resourceId, options) {
  var _a2;
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName3}: Multiple scopes are not supported.`);
  }
  const { skipQuery, skipMetadataHeader } = options || {};
  let query = "";
  if (!skipQuery) {
    const queryParameters = {
      resource,
      "api-version": imdsApiVersion
    };
    if (clientId) {
      queryParameters.client_id = clientId;
    }
    if (resourceId) {
      queryParameters.msi_res_id = resourceId;
    }
    const params = new URLSearchParams(queryParameters);
    query = `?${params.toString()}`;
  }
  const url = new URL(imdsEndpointPath, (_a2 = process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST) !== null && _a2 !== void 0 ? _a2 : imdsHost);
  const rawHeaders = {
    Accept: "application/json",
    Metadata: "true"
  };
  if (skipMetadataHeader) {
    delete rawHeaders.Metadata;
  }
  return {
    // In this case, the `?` should be added in the "query" variable `skipQuery` is not set.
    url: `${url}${query}`,
    method: "GET",
    headers: createHttpHeaders(rawHeaders)
  };
}
var msiName3, logger14, imdsMsiRetryConfig, imdsMsi;
var init_imdsMsi = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/imdsMsi.js"() {
    "use strict";
    init_src3();
    init_src5();
    init_logging();
    init_errors();
    init_tracing();
    init_constants3();
    init_utils3();
    msiName3 = "ManagedIdentityCredential - IMDS";
    logger14 = credentialLogger(msiName3);
    imdsMsiRetryConfig = {
      maxRetries: 3,
      startDelayInMs: 800,
      intervalIncrement: 2
    };
    imdsMsi = {
      async isAvailable({ scopes, identityClient, clientId, resourceId, getTokenOptions = {} }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
          logger14.info(`${msiName3}: Unavailable. Multiple scopes are not supported.`);
          return false;
        }
        if (process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST) {
          return true;
        }
        if (!identityClient) {
          throw new Error("Missing IdentityClient");
        }
        const requestOptions = prepareRequestOptions3(resource, clientId, resourceId, {
          skipMetadataHeader: true,
          skipQuery: true
        });
        return tracingClient.withSpan("ManagedIdentityCredential-pingImdsEndpoint", getTokenOptions, async (options) => {
          var _a2, _b;
          requestOptions.tracingOptions = options.tracingOptions;
          try {
            const request3 = createPipelineRequest(requestOptions);
            request3.timeout = (_b = (_a2 = options.requestOptions) === null || _a2 === void 0 ? void 0 : _a2.timeout) !== null && _b !== void 0 ? _b : 300;
            request3.allowInsecureConnection = true;
            try {
              logger14.info(`${msiName3}: Pinging the Azure IMDS endpoint`);
              await identityClient.sendRequest(request3);
            } catch (err) {
              if (err.name === "RestError" && err.code === RestError.REQUEST_SEND_ERROR || err.name === "AbortError" || err.code === "ENETUNREACH" || // Network unreachable
              err.code === "ECONNREFUSED" || // connection refused
              err.code === "EHOSTDOWN") {
                logger14.info(`${msiName3}: The Azure IMDS endpoint is unavailable`);
                return false;
              }
            }
            logger14.info(`${msiName3}: The Azure IMDS endpoint is available`);
            return true;
          } catch (err) {
            logger14.info(`${msiName3}: Error when creating the WebResource for the Azure IMDS endpoint: ${err.message}`);
            throw err;
          }
        });
      },
      async getToken(configuration, getTokenOptions = {}) {
        const { identityClient, scopes, clientId, resourceId } = configuration;
        logger14.info(`${msiName3}: Using the Azure IMDS endpoint coming from the environment variable MSI_ENDPOINT=${process.env.MSI_ENDPOINT}, and using the cloud shell to proceed with the authentication.`);
        let nextDelayInMs = imdsMsiRetryConfig.startDelayInMs;
        for (let retries = 0; retries < imdsMsiRetryConfig.maxRetries; retries++) {
          try {
            const request3 = createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions3(scopes, clientId, resourceId)), { allowInsecureConnection: true }));
            const tokenResponse = await identityClient.sendTokenRequest(request3, expiresOnParser2);
            return tokenResponse && tokenResponse.accessToken || null;
          } catch (error) {
            if (error.statusCode === 404) {
              await delay(nextDelayInMs);
              nextDelayInMs *= imdsMsiRetryConfig.intervalIncrement;
              continue;
            }
            throw error;
          }
        }
        throw new AuthenticationError(404, `${msiName3}: Failed to retrieve IMDS token after ${imdsMsiRetryConfig.maxRetries} retries.`);
      }
    };
  }
});
function prepareRequestOptions4(scopes, clientId, resourceId) {
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName4}: Multiple scopes are not supported.`);
  }
  const queryParameters = {
    resource,
    "api-version": azureArcAPIVersion
  };
  if (clientId) {
    queryParameters.client_id = clientId;
  }
  if (resourceId) {
    queryParameters.msi_res_id = resourceId;
  }
  if (!process.env.IDENTITY_ENDPOINT) {
    throw new Error(`${msiName4}: Missing environment variable: IDENTITY_ENDPOINT`);
  }
  const query = new URLSearchParams(queryParameters);
  return createPipelineRequest({
    // Should be similar to: http://localhost:40342/metadata/identity/oauth2/token
    url: `${process.env.IDENTITY_ENDPOINT}?${query.toString()}`,
    method: "GET",
    headers: createHttpHeaders({
      Accept: "application/json",
      Metadata: "true"
    })
  });
}
function readFileAsync2(path3, options) {
  return new Promise((resolve, reject) => (0, import_fs3.readFile)(path3, options, (err, data) => {
    if (err) {
      reject(err);
    }
    resolve(data);
  }));
}
async function filePathRequest(identityClient, requestPrepareOptions) {
  const response = await identityClient.sendRequest(createPipelineRequest(requestPrepareOptions));
  if (response.status !== 401) {
    let message = "";
    if (response.bodyAsText) {
      message = ` Response: ${response.bodyAsText}`;
    }
    throw new AuthenticationError(response.status, `${msiName4}: To authenticate with Azure Arc MSI, status code 401 is expected on the first request. ${message}`);
  }
  const authHeader = response.headers.get("www-authenticate") || "";
  try {
    return authHeader.split("=").slice(1)[0];
  } catch (e) {
    throw Error(`Invalid www-authenticate header format: ${authHeader}`);
  }
}
var msiName4, logger15, arcMsi;
var init_arcMsi = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/arcMsi.js"() {
    "use strict";
    init_src5();
    init_errors();
    init_logging();
    init_utils3();
    init_constants3();
    msiName4 = "ManagedIdentityCredential - Azure Arc MSI";
    logger15 = credentialLogger(msiName4);
    arcMsi = {
      async isAvailable({ scopes }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
          logger15.info(`${msiName4}: Unavailable. Multiple scopes are not supported.`);
          return false;
        }
        const result = Boolean(process.env.IMDS_ENDPOINT && process.env.IDENTITY_ENDPOINT);
        if (!result) {
          logger15.info(`${msiName4}: The environment variables needed are: IMDS_ENDPOINT and IDENTITY_ENDPOINT`);
        }
        return result;
      },
      async getToken(configuration, getTokenOptions = {}) {
        var _a2;
        const { identityClient, scopes, clientId, resourceId } = configuration;
        if (clientId) {
          logger15.warning(`${msiName4}: user-assigned identities not supported. The argument clientId might be ignored by the service.`);
        }
        if (resourceId) {
          logger15.warning(`${msiName4}: user defined managed Identity by resource Id is not supported. Argument resourceId will be ignored.`);
        }
        logger15.info(`${msiName4}: Authenticating.`);
        const requestOptions = Object.assign(Object.assign({ disableJsonStringifyOnBody: true, deserializationMapper: void 0, abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions4(scopes, clientId, resourceId)), { allowInsecureConnection: true });
        const filePath = await filePathRequest(identityClient, requestOptions);
        if (!filePath) {
          throw new Error(`${msiName4}: Failed to find the token file.`);
        }
        const key = await readFileAsync2(filePath, { encoding: "utf-8" });
        (_a2 = requestOptions.headers) === null || _a2 === void 0 ? void 0 : _a2.set("Authorization", `Basic ${key}`);
        const request3 = createPipelineRequest(Object.assign(Object.assign({}, requestOptions), {
          // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
          allowInsecureConnection: true
        }));
        const tokenResponse = await identityClient.sendTokenRequest(request3);
        return tokenResponse && tokenResponse.accessToken || null;
      }
    };
  }
});
function prepareRequestOptions5(scopes, clientAssertion, clientId) {
  var _a2;
  const bodyParams = {
    scope: Array.isArray(scopes) ? scopes.join(" ") : scopes,
    client_assertion: clientAssertion,
    client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
    client_id: clientId,
    grant_type: "client_credentials"
  };
  const urlParams = new URLSearchParams(bodyParams);
  const url = new URL(`${process.env.AZURE_TENANT_ID}/oauth2/v2.0/token`, (_a2 = process.env.AZURE_AUTHORITY_HOST) !== null && _a2 !== void 0 ? _a2 : DefaultAuthorityHost);
  return {
    url: url.toString(),
    method: "POST",
    body: urlParams.toString(),
    headers: createHttpHeaders({
      Accept: "application/json"
    })
  };
}
function tokenExchangeMsi() {
  const azureFederatedTokenFilePath = process.env.AZURE_FEDERATED_TOKEN_FILE;
  let azureFederatedTokenFileContent = void 0;
  let cacheDate = void 0;
  async function readAssertion() {
    if (cacheDate !== void 0 && Date.now() - cacheDate >= 1e3 * 60 * 5) {
      azureFederatedTokenFileContent = void 0;
    }
    if (!azureFederatedTokenFileContent) {
      const file = await readFileAsync3(azureFederatedTokenFilePath, "utf8");
      const value = file.trim();
      if (!value) {
        throw new Error(`No content on the file ${azureFederatedTokenFilePath}, indicated by the environment variable AZURE_FEDERATED_TOKEN_FILE`);
      } else {
        azureFederatedTokenFileContent = value;
        cacheDate = Date.now();
      }
    }
    return azureFederatedTokenFileContent;
  }
  return {
    async isAvailable({ clientId }) {
      const env = process.env;
      const result = Boolean((clientId || env.AZURE_CLIENT_ID) && env.AZURE_TENANT_ID && azureFederatedTokenFilePath);
      if (!result) {
        logger16.info(`${msiName5}: Unavailable. The environment variables needed are: AZURE_CLIENT_ID (or the client ID sent through the parameters), AZURE_TENANT_ID and AZURE_FEDERATED_TOKEN_FILE`);
      }
      return result;
    },
    async getToken(configuration, getTokenOptions = {}) {
      const { identityClient, scopes, clientId } = configuration;
      logger16.info(`${msiName5}: Using the client assertion coming from environment variables.`);
      let assertion;
      try {
        assertion = await readAssertion();
      } catch (err) {
        throw new Error(`${msiName5}: Failed to read ${azureFederatedTokenFilePath}, indicated by the environment variable AZURE_FEDERATED_TOKEN_FILE`);
      }
      const request3 = createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions5(scopes, assertion, clientId || process.env.AZURE_CLIENT_ID)), {
        // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
        allowInsecureConnection: true
      }));
      const tokenResponse = await identityClient.sendTokenRequest(request3);
      return tokenResponse && tokenResponse.accessToken || null;
    }
  };
}
var msiName5, logger16, readFileAsync3;
var init_tokenExchangeMsi = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/tokenExchangeMsi.js"() {
    "use strict";
    init_src5();
    init_constants2();
    init_logging();
    msiName5 = "ManagedIdentityCredential - Token Exchange";
    logger16 = credentialLogger(msiName5);
    readFileAsync3 = (0, import_util4.promisify)(import_fs4.default.readFile);
  }
});
function expiresOnParser3(requestBody) {
  return Number(requestBody.expires_on);
}
function prepareRequestOptions6(scopes, clientId, resourceId) {
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName6}: Multiple scopes are not supported.`);
  }
  const queryParameters = {
    resource,
    "api-version": azureFabricVersion
  };
  if (clientId) {
    queryParameters.client_id = clientId;
  }
  if (resourceId) {
    queryParameters.msi_res_id = resourceId;
  }
  const query = new URLSearchParams(queryParameters);
  if (!process.env.IDENTITY_ENDPOINT) {
    throw new Error("Missing environment variable: IDENTITY_ENDPOINT");
  }
  if (!process.env.IDENTITY_HEADER) {
    throw new Error("Missing environment variable: IDENTITY_HEADER");
  }
  return {
    url: `${process.env.IDENTITY_ENDPOINT}?${query.toString()}`,
    method: "GET",
    headers: createHttpHeaders({
      Accept: "application/json",
      secret: process.env.IDENTITY_HEADER
    })
  };
}
var msiName6, logger17, fabricMsi;
var init_fabricMsi = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/fabricMsi.js"() {
    "use strict";
    init_src5();
    init_logging();
    init_utils3();
    init_constants3();
    msiName6 = "ManagedIdentityCredential - Fabric MSI";
    logger17 = credentialLogger(msiName6);
    fabricMsi = {
      async isAvailable({ scopes }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
          logger17.info(`${msiName6}: Unavailable. Multiple scopes are not supported.`);
          return false;
        }
        const env = process.env;
        const result = Boolean(env.IDENTITY_ENDPOINT && env.IDENTITY_HEADER && env.IDENTITY_SERVER_THUMBPRINT);
        if (!result) {
          logger17.info(`${msiName6}: Unavailable. The environment variables needed are: IDENTITY_ENDPOINT, IDENTITY_HEADER and IDENTITY_SERVER_THUMBPRINT`);
        }
        return result;
      },
      async getToken(configuration, getTokenOptions = {}) {
        const { scopes, identityClient, clientId, resourceId } = configuration;
        if (resourceId) {
          logger17.warning(`${msiName6}: user defined managed Identity by resource Id is not supported. Argument resourceId might be ignored by the service.`);
        }
        logger17.info([
          `${msiName6}:`,
          "Using the endpoint and the secret coming from the environment variables:",
          `IDENTITY_ENDPOINT=${process.env.IDENTITY_ENDPOINT},`,
          "IDENTITY_HEADER=[REDACTED] and",
          "IDENTITY_SERVER_THUMBPRINT=[REDACTED]."
        ].join(" "));
        const request3 = createPipelineRequest(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions6(scopes, clientId, resourceId)));
        request3.agent = new import_https2.default.Agent({
          // This is necessary because Service Fabric provides a self-signed certificate.
          // The alternative path is to verify the certificate using the IDENTITY_SERVER_THUMBPRINT env variable.
          rejectUnauthorized: false
        });
        const tokenResponse = await identityClient.sendTokenRequest(request3, expiresOnParser3);
        return tokenResponse && tokenResponse.accessToken || null;
      }
    };
  }
});
function expiresOnParser4(requestBody) {
  return Date.parse(requestBody.expires_on);
}
function prepareRequestOptions7(scopes, clientId, resourceId) {
  const resource = mapScopesToResource(scopes);
  if (!resource) {
    throw new Error(`${msiName7}: Multiple scopes are not supported.`);
  }
  const queryParameters = {
    resource,
    "api-version": "2019-08-01"
  };
  if (clientId) {
    queryParameters.client_id = clientId;
  }
  if (resourceId) {
    queryParameters.mi_res_id = resourceId;
  }
  const query = new URLSearchParams(queryParameters);
  if (!process.env.IDENTITY_ENDPOINT) {
    throw new Error(`${msiName7}: Missing environment variable: IDENTITY_ENDPOINT`);
  }
  if (!process.env.IDENTITY_HEADER) {
    throw new Error(`${msiName7}: Missing environment variable: IDENTITY_HEADER`);
  }
  return {
    url: `${process.env.IDENTITY_ENDPOINT}?${query.toString()}`,
    method: "GET",
    headers: createHttpHeaders({
      Accept: "application/json",
      "X-IDENTITY-HEADER": process.env.IDENTITY_HEADER
    })
  };
}
var msiName7, logger18, appServiceMsi2019;
var init_appServiceMsi2019 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/appServiceMsi2019.js"() {
    "use strict";
    init_src5();
    init_logging();
    init_utils3();
    msiName7 = "ManagedIdentityCredential - AppServiceMSI 2019";
    logger18 = credentialLogger(msiName7);
    appServiceMsi2019 = {
      async isAvailable({ scopes }) {
        const resource = mapScopesToResource(scopes);
        if (!resource) {
          logger18.info(`${msiName7}: Unavailable. Multiple scopes are not supported.`);
          return false;
        }
        const env = process.env;
        const result = Boolean(env.IDENTITY_ENDPOINT && env.IDENTITY_HEADER);
        if (!result) {
          logger18.info(`${msiName7}: Unavailable. The environment variables needed are: IDENTITY_ENDPOINT and IDENTITY_HEADER.`);
        }
        return result;
      },
      async getToken(configuration, getTokenOptions = {}) {
        const { identityClient, scopes, clientId, resourceId } = configuration;
        logger18.info(`${msiName7}: Using the endpoint and the secret coming form the environment variables: IDENTITY_ENDPOINT=${process.env.IDENTITY_ENDPOINT} and IDENTITY_HEADER=[REDACTED].`);
        const request3 = createPipelineRequest(Object.assign(Object.assign({ abortSignal: getTokenOptions.abortSignal }, prepareRequestOptions7(scopes, clientId, resourceId)), {
          // Generally, MSI endpoints use the HTTP protocol, without transport layer security (TLS).
          allowInsecureConnection: true
        }));
        const tokenResponse = await identityClient.sendTokenRequest(request3, expiresOnParser4);
        return tokenResponse && tokenResponse.accessToken || null;
      }
    };
  }
});
var logger19, ManagedIdentityCredential;
var init_managedIdentityCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/index.js"() {
    "use strict";
    init_identityClient();
    init_errors();
    init_logging();
    init_appServiceMsi2017();
    init_tracing();
    init_cloudShellMsi();
    init_imdsMsi();
    init_arcMsi();
    init_tokenExchangeMsi();
    init_fabricMsi();
    init_appServiceMsi2019();
    logger19 = credentialLogger("ManagedIdentityCredential");
    ManagedIdentityCredential = class _ManagedIdentityCredential {
      /**
       * @internal
       * @hidden
       */
      constructor(clientIdOrOptions, options) {
        this.isEndpointUnavailable = null;
        let _options;
        if (typeof clientIdOrOptions === "string") {
          this.clientId = clientIdOrOptions;
          _options = options;
        } else {
          this.clientId = clientIdOrOptions === null || clientIdOrOptions === void 0 ? void 0 : clientIdOrOptions.clientId;
          _options = clientIdOrOptions;
        }
        this.resourceId = _options === null || _options === void 0 ? void 0 : _options.resourceId;
        if (this.clientId && this.resourceId) {
          throw new Error(`${_ManagedIdentityCredential.name} - Client Id and Resource Id can't be provided at the same time.`);
        }
        this.identityClient = new IdentityClient(_options);
        this.isAvailableIdentityClient = new IdentityClient(Object.assign(Object.assign({}, _options), { retryOptions: {
          maxRetries: 0
        } }));
      }
      async cachedAvailableMSI(scopes, getTokenOptions) {
        if (this.cachedMSI) {
          return this.cachedMSI;
        }
        const MSIs = [
          arcMsi,
          fabricMsi,
          appServiceMsi2019,
          appServiceMsi2017,
          cloudShellMsi,
          tokenExchangeMsi(),
          imdsMsi
        ];
        for (const msi of MSIs) {
          if (await msi.isAvailable({
            scopes,
            identityClient: this.isAvailableIdentityClient,
            clientId: this.clientId,
            resourceId: this.resourceId,
            getTokenOptions
          })) {
            this.cachedMSI = msi;
            return msi;
          }
        }
        throw new CredentialUnavailableError(`${_ManagedIdentityCredential.name} - No MSI credential available`);
      }
      async authenticateManagedIdentity(scopes, getTokenOptions) {
        const { span, updatedOptions } = tracingClient.startSpan(`${_ManagedIdentityCredential.name}.authenticateManagedIdentity`, getTokenOptions);
        try {
          const availableMSI = await this.cachedAvailableMSI(scopes, updatedOptions);
          return availableMSI.getToken({
            identityClient: this.identityClient,
            scopes,
            clientId: this.clientId,
            resourceId: this.resourceId
          }, updatedOptions);
        } catch (err) {
          span.setStatus({
            status: "error",
            error: err
          });
          throw err;
        } finally {
          span.end();
        }
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       * If an unexpected error occurs, an {@link AuthenticationError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options) {
        let result = null;
        const { span, updatedOptions } = tracingClient.startSpan(`${_ManagedIdentityCredential.name}.getToken`, options);
        try {
          if (this.isEndpointUnavailable !== true) {
            result = await this.authenticateManagedIdentity(scopes, updatedOptions);
            if (result === null) {
              this.isEndpointUnavailable = true;
              const error = new CredentialUnavailableError("The managed identity endpoint was reached, yet no tokens were received.");
              logger19.getToken.info(formatError(scopes, error));
              throw error;
            }
            this.isEndpointUnavailable = false;
          } else {
            const error = new CredentialUnavailableError("The managed identity endpoint is not currently available");
            logger19.getToken.info(formatError(scopes, error));
            throw error;
          }
          logger19.getToken.info(formatSuccess(scopes));
          return result;
        } catch (err) {
          if (err.name === "AuthenticationRequiredError") {
            throw err;
          }
          span.setStatus({
            status: "error",
            error: err
          });
          if (err.code === "ENETUNREACH") {
            const error = new CredentialUnavailableError(`${_ManagedIdentityCredential.name}: Unavailable. Network unreachable. Message: ${err.message}`);
            logger19.getToken.info(formatError(scopes, error));
            throw error;
          }
          if (err.code === "EHOSTUNREACH") {
            const error = new CredentialUnavailableError(`${_ManagedIdentityCredential.name}: Unavailable. No managed identity endpoint found. Message: ${err.message}`);
            logger19.getToken.info(formatError(scopes, error));
            throw error;
          }
          if (err.statusCode === 400) {
            throw new CredentialUnavailableError(`${_ManagedIdentityCredential.name}: The managed identity endpoint is indicating there's no available identity. Message: ${err.message}`);
          }
          if (err.statusCode === void 0) {
            throw new CredentialUnavailableError(`${_ManagedIdentityCredential.name}: Authentication failed. Message ${err.message}`);
          }
          throw new AuthenticationError(err.statusCode, {
            error: `${_ManagedIdentityCredential.name} authentication failed.`,
            error_description: err.message
          });
        } finally {
          span.end();
        }
      }
    };
  }
});
var DefaultManagedIdentityCredential, defaultCredentials, DefaultAzureCredential;
var init_defaultAzureCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/defaultAzureCredential.js"() {
    "use strict";
    init_chainedTokenCredential();
    init_azureCliCredential();
    init_azurePowerShellCredential();
    init_environmentCredential();
    init_managedIdentityCredential();
    init_visualStudioCodeCredential();
    DefaultManagedIdentityCredential = class extends ManagedIdentityCredential {
      // Constructor overload with just the other default options
      // Last constructor overload with Union of all options not required since the above two constructor overloads have optional properties
      constructor(options) {
        var _a2;
        const managedIdentityClientId = (_a2 = options === null || options === void 0 ? void 0 : options.managedIdentityClientId) !== null && _a2 !== void 0 ? _a2 : process.env.AZURE_CLIENT_ID;
        const managedResourceId = options === null || options === void 0 ? void 0 : options.managedIdentityResourceId;
        if (managedResourceId) {
          const managedIdentityResourceIdOptions = Object.assign(Object.assign({}, options), { resourceId: managedResourceId });
          super(managedIdentityResourceIdOptions);
        } else if (managedIdentityClientId) {
          const managedIdentityClientOptions = Object.assign(Object.assign({}, options), { clientId: managedIdentityClientId });
          super(managedIdentityClientOptions);
        } else {
          super(options);
        }
      }
    };
    defaultCredentials = [
      EnvironmentCredential,
      DefaultManagedIdentityCredential,
      VisualStudioCodeCredential,
      AzureCliCredential,
      AzurePowerShellCredential
    ];
    DefaultAzureCredential = class extends ChainedTokenCredential {
      constructor(options) {
        super(...defaultCredentials.map((ctor) => new ctor(options)));
        this.UnavailableMessage = "DefaultAzureCredential => failed to retrieve a token from the included credentials. To troubleshoot, visit https://aka.ms/azsdk/js/identity/defaultazurecredential/troubleshoot.";
      }
    };
  }
});
var MsalClientAssertion;
var init_msalClientAssertion = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalClientAssertion.js"() {
    "use strict";
    init_src3();
    init_msalNodeCommon();
    MsalClientAssertion = class extends MsalNode {
      constructor(options) {
        super(options);
        this.requiresConfidential = true;
        this.getAssertion = options.getAssertion;
      }
      async doGetToken(scopes, options = {}) {
        try {
          const assertion = await this.getAssertion();
          const result = await this.confidentialApp.acquireTokenByClientCredential({
            scopes,
            correlationId: options.correlationId,
            azureRegion: this.azureRegion,
            authority: options.authority,
            claims: options.claims,
            clientAssertion: assertion
          });
          return this.handleResult(scopes, this.clientId, result || void 0);
        } catch (err) {
          let err2 = err;
          if (err === null || err === void 0) {
            err2 = new Error(JSON.stringify(err));
          } else {
            err2 = isError(err) ? err : new Error(String(err));
          }
          throw this.handleError(scopes, err2, options);
        }
      }
    };
  }
});
var logger20, ClientAssertionCredential;
var init_clientAssertionCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/clientAssertionCredential.js"() {
    "use strict";
    init_logging();
    init_tracing();
    init_msalClientAssertion();
    logger20 = credentialLogger("ClientAssertionCredential");
    ClientAssertionCredential = class {
      /**
       * Creates an instance of the ClientAssertionCredential with the details
       * needed to authenticate against Azure Active Directory with a client
       * assertion provided by the developer through the `getAssertion` function parameter.
       *
       * @param tenantId - The Azure Active Directory tenant (directory) ID.
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param getAssertion - A function that retrieves the assertion for the credential to use.
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(tenantId, clientId, getAssertion, options = {}) {
        if (!tenantId || !clientId || !getAssertion) {
          throw new Error("ClientAssertionCredential: tenantId, clientId, and clientAssertion are required parameters.");
        }
        this.tenantId = tenantId;
        this.clientId = clientId;
        this.options = options;
        this.msalFlow = new MsalClientAssertion(Object.assign(Object.assign({}, options), { logger: logger20, clientId: this.clientId, tenantId: this.tenantId, tokenCredentialOptions: this.options, getAssertion }));
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          return this.msalFlow.getToken(arrayScopes, newOptions);
        });
      }
    };
  }
});
var require_is_docker = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/is-docker@2.2.1/node_modules/is-docker/index.js"(exports, module2) {
    "use strict";
    var fs4 = (0, import_chunk_FVJ3R4NJ.__require)("fs");
    var isDocker;
    function hasDockerEnv() {
      try {
        fs4.statSync("/.dockerenv");
        return true;
      } catch (_2) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs4.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_2) {
        return false;
      }
    }
    module2.exports = () => {
      if (isDocker === void 0) {
        isDocker = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker;
    };
  }
});
var require_is_wsl = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/is-wsl@2.2.0/node_modules/is-wsl/index.js"(exports, module2) {
    "use strict";
    var os3 = (0, import_chunk_FVJ3R4NJ.__require)("os");
    var fs4 = (0, import_chunk_FVJ3R4NJ.__require)("fs");
    var isDocker = require_is_docker();
    var isWsl = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os3.release().toLowerCase().includes("microsoft")) {
        if (isDocker()) {
          return false;
        }
        return true;
      }
      try {
        return fs4.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
      } catch (_2) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      module2.exports = isWsl;
    } else {
      module2.exports = isWsl();
    }
  }
});
var require_define_lazy_prop = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/define-lazy-prop@2.0.0/node_modules/define-lazy-prop/index.js"(exports, module2) {
    "use strict";
    module2.exports = (object, propertyName, fn) => {
      const define2 = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
      Object.defineProperty(object, propertyName, {
        configurable: true,
        enumerable: true,
        get() {
          const result = fn();
          define2(result);
          return result;
        },
        set(value) {
          define2(value);
        }
      });
      return object;
    };
  }
});
var require_open = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/open@8.4.0/node_modules/open/index.js"(exports, module2) {
    "use strict";
    var path3 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    var childProcess2 = (0, import_chunk_FVJ3R4NJ.__require)("child_process");
    var { promises: fs4, constants: fsConstants } = (0, import_chunk_FVJ3R4NJ.__require)("fs");
    var isWsl = require_is_wsl();
    var isDocker = require_is_docker();
    var defineLazyProperty = require_define_lazy_prop();
    var localXdgOpenPath = path3.join(__dirname, "xdg-open");
    var { platform, arch: arch2 } = process;
    var getWslDrivesMountPoint = /* @__PURE__ */ (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await fs4.access(configFilePath, fsConstants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await fs4.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    var pTryEach = async (array, mapper) => {
      let latestError;
      for (const item of array) {
        try {
          return await mapper(item);
        } catch (error) {
          latestError = error;
        }
      }
      throw latestError;
    };
    var baseOpen = async (options) => {
      options = {
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false,
        ...options
      };
      if (Array.isArray(options.app)) {
        return pTryEach(options.app, (singleApp) => baseOpen({
          ...options,
          app: singleApp
        }));
      }
      let { name: app, arguments: appArguments = [] } = options.app || {};
      appArguments = [...appArguments];
      if (Array.isArray(app)) {
        return pTryEach(app, (appName) => baseOpen({
          ...options,
          app: {
            name: appName,
            arguments: appArguments
          }
        }));
      }
      let command;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform === "darwin") {
        command = "open";
        if (options.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options.background) {
          cliArguments.push("--background");
        }
        if (options.newInstance) {
          cliArguments.push("--new");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (platform === "win32" || isWsl && !isDocker()) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push(
          "-NoProfile",
          "-NonInteractive",
          "\u2013ExecutionPolicy",
          "Bypass",
          "-EncodedCommand"
        );
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          if (options.target) {
            appArguments.unshift(options.target);
          }
        } else if (options.target) {
          encodedArguments.push(`"${options.target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        options.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname || __dirname === "/";
          let exeLocalXdgOpen = false;
          try {
            await fs4.access(localXdgOpenPath, fsConstants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      if (options.target) {
        cliArguments.push(options.target);
      }
      if (platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess2.spawn(command, cliArguments, childProcessOptions);
      if (options.wait) {
        return new Promise((resolve, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (options.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    var open2 = (target, options) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      return baseOpen({
        ...options,
        target
      });
    };
    var openApp = (name3, options) => {
      if (typeof name3 !== "string") {
        throw new TypeError("Expected a `name`");
      }
      const { arguments: appArguments = [] } = options || {};
      if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
        throw new TypeError("Expected `appArguments` as Array type");
      }
      return baseOpen({
        ...options,
        app: {
          name: name3,
          arguments: appArguments
        }
      });
    };
    function detectArchBinary(binary) {
      if (typeof binary === "string" || Array.isArray(binary)) {
        return binary;
      }
      const { [arch2]: archBinary } = binary;
      if (!archBinary) {
        throw new Error(`${arch2} is not supported`);
      }
      return archBinary;
    }
    function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
      if (wsl && isWsl) {
        return detectArchBinary(wsl);
      }
      if (!platformBinary) {
        throw new Error(`${platform} is not supported`);
      }
      return detectArchBinary(platformBinary);
    }
    var apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable", "chromium"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: ["microsoft-edge", "microsoft-edge-dev"]
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    open2.apps = apps;
    open2.openApp = openApp;
    module2.exports = open2;
  }
});
var require_stoppable = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/stoppable@1.1.0/node_modules/stoppable/lib/stoppable.js"(exports, module2) {
    "use strict";
    var https4 = (0, import_chunk_FVJ3R4NJ.__require)("https");
    module2.exports = (server, grace) => {
      grace = typeof grace === "undefined" ? Infinity : grace;
      const reqsPerSocket = /* @__PURE__ */ new Map();
      let stopped = false;
      let gracefully = true;
      if (server instanceof https4.Server) {
        server.on("secureConnection", onConnection);
      } else {
        server.on("connection", onConnection);
      }
      server.on("request", onRequest);
      server.stop = stop;
      server._pendingSockets = reqsPerSocket;
      return server;
      function onConnection(socket) {
        reqsPerSocket.set(socket, 0);
        socket.once("close", () => reqsPerSocket.delete(socket));
      }
      function onRequest(req, res) {
        reqsPerSocket.set(req.socket, reqsPerSocket.get(req.socket) + 1);
        res.once("finish", () => {
          const pending = reqsPerSocket.get(req.socket) - 1;
          reqsPerSocket.set(req.socket, pending);
          if (stopped && pending === 0) {
            req.socket.end();
          }
        });
      }
      function stop(callback) {
        setImmediate(() => {
          stopped = true;
          if (grace < Infinity) {
            setTimeout(destroyAll, grace).unref();
          }
          server.close((e) => {
            if (callback) {
              callback(e, gracefully);
            }
          });
          reqsPerSocket.forEach(endIfIdle);
        });
      }
      function endIfIdle(requests, socket) {
        if (requests === 0)
          socket.end();
      }
      function destroyAll() {
        gracefully = false;
        reqsPerSocket.forEach((reqs, socket) => socket.end());
        setImmediate(() => {
          reqsPerSocket.forEach((reqs, socket) => socket.destroy());
        });
      }
    };
  }
});
var import_open, import_stoppable, interactiveBrowserMockable, MsalOpenBrowser;
var init_msalOpenBrowser = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalOpenBrowser.js"() {
    "use strict";
    init_msal_node_esm();
    import_open = (0, import_chunk_FVJ3R4NJ.__toESM)(require_open());
    import_stoppable = (0, import_chunk_FVJ3R4NJ.__toESM)(require_stoppable());
    init_logging();
    init_errors();
    init_msalNodeCommon();
    init_utils2();
    interactiveBrowserMockable = {
      open: import_open.default
    };
    MsalOpenBrowser = class extends MsalNode {
      constructor(options) {
        super(options);
        this.logger = credentialLogger("Node.js MSAL Open Browser");
        this.redirectUri = options.redirectUri;
        this.loginHint = options.loginHint;
        const url = new URL(this.redirectUri);
        this.port = parseInt(url.port);
        if (isNaN(this.port)) {
          this.port = 80;
        }
        this.hostname = url.hostname;
      }
      async acquireTokenByCode(request3) {
        return this.publicApp.acquireTokenByCode(request3);
      }
      doGetToken(scopes, options) {
        return new Promise((resolve, reject) => {
          const socketToDestroy = [];
          const requestListener = (req, res) => {
            var _a2;
            if (!req.url) {
              reject(new Error(`Interactive Browser Authentication Error "Did not receive token with a valid expiration"`));
              return;
            }
            let url;
            try {
              url = new URL(req.url, this.redirectUri);
            } catch (e) {
              reject(new Error(`Interactive Browser Authentication Error "Did not receive token with a valid expiration"`));
              return;
            }
            const tokenRequest = {
              code: url.searchParams.get("code"),
              redirectUri: this.redirectUri,
              scopes,
              authority: options === null || options === void 0 ? void 0 : options.authority,
              codeVerifier: (_a2 = this.pkceCodes) === null || _a2 === void 0 ? void 0 : _a2.verifier
            };
            this.acquireTokenByCode(tokenRequest).then((authResponse) => {
              if (authResponse === null || authResponse === void 0 ? void 0 : authResponse.account) {
                this.account = msalToPublic(this.clientId, authResponse.account);
              }
              const successMessage = `Authentication Complete. You can close the browser and return to the application.`;
              if (authResponse && authResponse.expiresOn) {
                const expiresOnTimestamp = authResponse === null || authResponse === void 0 ? void 0 : authResponse.expiresOn.valueOf();
                res.writeHead(200);
                res.end(successMessage);
                this.logger.getToken.info(formatSuccess(scopes));
                resolve({
                  expiresOnTimestamp,
                  token: authResponse.accessToken
                });
              } else {
                const errorMessage = formatError(scopes, `${url.searchParams.get("error")}. ${url.searchParams.get("error_description")}`);
                res.writeHead(500);
                res.end(errorMessage);
                this.logger.getToken.info(errorMessage);
                reject(new Error(`Interactive Browser Authentication Error "Did not receive token with a valid expiration"`));
              }
              cleanup();
              return;
            }).catch(() => {
              const errorMessage = formatError(scopes, `${url.searchParams.get("error")}. ${url.searchParams.get("error_description")}`);
              res.writeHead(500);
              res.end(errorMessage);
              this.logger.getToken.info(errorMessage);
              reject(new Error(`Interactive Browser Authentication Error "Did not receive token with a valid expiration"`));
              cleanup();
            });
          };
          const app = import_http2.default.createServer(requestListener);
          const server = (0, import_stoppable.default)(app);
          const listen = app.listen(this.port, this.hostname, () => this.logger.info(`InteractiveBrowserCredential listening on port ${this.port}!`));
          function cleanup() {
            if (listen) {
              listen.close();
            }
            for (const socket of socketToDestroy) {
              socket.destroy();
            }
            if (server) {
              server.close();
              server.stop();
            }
          }
          app.on("connection", (socket) => socketToDestroy.push(socket));
          app.on("error", (err) => {
            cleanup();
            const code = err.code;
            if (code === "EACCES" || code === "EADDRINUSE") {
              reject(new CredentialUnavailableError([
                `InteractiveBrowserCredential: Access denied to port ${this.port}.`,
                `Try sending a redirect URI with a different port, as follows:`,
                '`new InteractiveBrowserCredential({ redirectUri: "http://localhost:1337" })`'
              ].join(" ")));
            } else {
              reject(new CredentialUnavailableError(`InteractiveBrowserCredential: Failed to start the necessary web server. Error: ${err.message}`));
            }
          });
          app.on("listening", () => {
            const openPromise = this.openAuthCodeUrl(scopes, options);
            const abortSignal2 = options === null || options === void 0 ? void 0 : options.abortSignal;
            if (abortSignal2) {
              abortSignal2.addEventListener("abort", () => {
                cleanup();
                reject(new Error("Aborted"));
              });
            }
            openPromise.then().catch((e) => {
              cleanup();
              reject(e);
            });
          });
        });
      }
      async openAuthCodeUrl(scopeArray, options) {
        const cryptoProvider = new CryptoProvider();
        this.pkceCodes = await cryptoProvider.generatePkceCodes();
        const authCodeUrlParameters = {
          scopes: scopeArray,
          correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
          redirectUri: this.redirectUri,
          authority: options === null || options === void 0 ? void 0 : options.authority,
          claims: options === null || options === void 0 ? void 0 : options.claims,
          loginHint: this.loginHint,
          codeChallenge: this.pkceCodes.challenge,
          codeChallengeMethod: "S256"
          // Use SHA256 Algorithm
        };
        const response = await this.publicApp.getAuthCodeUrl(authCodeUrlParameters);
        try {
          await interactiveBrowserMockable.open(response, { wait: true, newInstance: true });
        } catch (e) {
          throw new CredentialUnavailableError(`InteractiveBrowserCredential: Could not open a browser window. Error: ${e.message}`);
        }
      }
    };
  }
});
var logger21, InteractiveBrowserCredential;
var init_interactiveBrowserCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/interactiveBrowserCredential.js"() {
    "use strict";
    init_logging();
    init_tracing();
    init_msalOpenBrowser();
    logger21 = credentialLogger("InteractiveBrowserCredential");
    InteractiveBrowserCredential = class {
      /**
       * Creates an instance of InteractiveBrowserCredential with the details needed.
       *
       * This credential uses the [Authorization Code Flow](https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-auth-code-flow).
       * On Node.js, it will open a browser window while it listens for a redirect response from the authentication service.
       * On browsers, it authenticates via popups. The `loginStyle` optional parameter can be set to `redirect` to authenticate by redirecting the user to an Azure secure login page, which then will redirect the user back to the web application where the authentication started.
       *
       * For Node.js, if a `clientId` is provided, the Azure Active Directory application will need to be configured to have a "Mobile and desktop applications" redirect endpoint.
       * Follow our guide on [setting up Redirect URIs for Desktop apps that calls to web APIs](https://docs.microsoft.com/azure/active-directory/develop/scenario-desktop-app-registration#redirect-uris).
       *
       * @param options - Options for configuring the client which makes the authentication requests.
       */
      constructor(options = {}) {
        const redirectUri = typeof options.redirectUri === "function" ? options.redirectUri() : options.redirectUri || "http://localhost";
        this.msalFlow = new MsalOpenBrowser(Object.assign(Object.assign({}, options), {
          tokenCredentialOptions: options,
          logger: logger21,
          redirectUri
        }));
        this.disableAutomaticAuthentication = options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication;
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the user provided the option `disableAutomaticAuthentication`,
       * once the token can't be retrieved silently,
       * this method won't attempt to request user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          return this.msalFlow.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
        });
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.
       *
       * On Node.js, this credential has [Proof Key for Code Exchange (PKCE)](https://datatracker.ietf.org/doc/html/rfc7636) enabled by default.
       * PKCE is a security feature that mitigates authentication code interception attacks.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                  TokenCredential implementation might make.
       */
      async authenticate(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          await this.msalFlow.getToken(arrayScopes, newOptions);
          return this.msalFlow.getActiveAccount();
        });
      }
    };
  }
});
var MsalDeviceCode;
var init_msalDeviceCode = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalDeviceCode.js"() {
    "use strict";
    init_msalNodeCommon();
    MsalDeviceCode = class extends MsalNode {
      constructor(options) {
        super(options);
        this.userPromptCallback = options.userPromptCallback;
      }
      async doGetToken(scopes, options) {
        try {
          const requestOptions = {
            deviceCodeCallback: this.userPromptCallback,
            scopes,
            cancel: false,
            correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
            authority: options === null || options === void 0 ? void 0 : options.authority,
            claims: options === null || options === void 0 ? void 0 : options.claims
          };
          const promise = this.publicApp.acquireTokenByDeviceCode(requestOptions);
          const deviceResponse = await this.withCancellation(promise, options === null || options === void 0 ? void 0 : options.abortSignal, () => {
            requestOptions.cancel = true;
          });
          return this.handleResult(scopes, this.clientId, deviceResponse || void 0);
        } catch (error) {
          throw this.handleError(scopes, error, options);
        }
      }
    };
  }
});
function defaultDeviceCodePromptCallback(deviceCodeInfo) {
  console.log(deviceCodeInfo.message);
}
var logger22, DeviceCodeCredential;
var init_deviceCodeCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/deviceCodeCredential.js"() {
    "use strict";
    init_logging();
    init_msalDeviceCode();
    init_tracing();
    logger22 = credentialLogger("DeviceCodeCredential");
    DeviceCodeCredential = class {
      /**
       * Creates an instance of DeviceCodeCredential with the details needed
       * to initiate the device code authorization flow with Azure Active Directory.
       *
       * A message will be logged, giving users a code that they can use to authenticate once they go to https://microsoft.com/devicelogin
       *
       * Developers can configure how this message is shown by passing a custom `userPromptCallback`:
       *
       * ```js
       * const credential = new DeviceCodeCredential({
       *   tenantId: env.AZURE_TENANT_ID,
       *   clientId: env.AZURE_CLIENT_ID,
       *   userPromptCallback: (info) => {
       *     console.log("CUSTOMIZED PROMPT CALLBACK", info.message);
       *   }
       * });
       * ```
       *
       * @param options - Options for configuring the client which makes the authentication requests.
       */
      constructor(options) {
        this.msalFlow = new MsalDeviceCode(Object.assign(Object.assign({}, options), { logger: logger22, userPromptCallback: (options === null || options === void 0 ? void 0 : options.userPromptCallback) || defaultDeviceCodePromptCallback, tokenCredentialOptions: options || {} }));
        this.disableAutomaticAuthentication = options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication;
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the user provided the option `disableAutomaticAuthentication`,
       * once the token can't be retrieved silently,
       * this method won't attempt to request user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          return this.msalFlow.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
        });
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                  TokenCredential implementation might make.
       */
      async authenticate(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          await this.msalFlow.getToken(arrayScopes, newOptions);
          return this.msalFlow.getActiveAccount();
        });
      }
    };
  }
});
var MsalAuthorizationCode;
var init_msalAuthorizationCode = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalAuthorizationCode.js"() {
    "use strict";
    init_logging();
    init_msalNodeCommon();
    MsalAuthorizationCode = class extends MsalNode {
      constructor(options) {
        super(options);
        this.logger = credentialLogger("Node.js MSAL Authorization Code");
        this.redirectUri = options.redirectUri;
        this.authorizationCode = options.authorizationCode;
        if (options.clientSecret) {
          this.msalConfig.auth.clientSecret = options.clientSecret;
        }
      }
      async getAuthCodeUrl(options) {
        await this.init();
        return (this.confidentialApp || this.publicApp).getAuthCodeUrl(options);
      }
      async doGetToken(scopes, options) {
        var _a2;
        try {
          const result = await ((_a2 = this.confidentialApp || this.publicApp) === null || _a2 === void 0 ? void 0 : _a2.acquireTokenByCode({
            scopes,
            redirectUri: this.redirectUri,
            code: this.authorizationCode,
            correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
            authority: options === null || options === void 0 ? void 0 : options.authority,
            claims: options === null || options === void 0 ? void 0 : options.claims
          }));
          return this.handleResult(scopes, this.clientId, result || void 0);
        } catch (err) {
          throw this.handleError(scopes, err, options);
        }
      }
    };
  }
});
var logger23, AuthorizationCodeCredential;
var init_authorizationCodeCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/authorizationCodeCredential.js"() {
    "use strict";
    init_logging();
    init_checkTenantId();
    init_msalAuthorizationCode();
    init_tracing();
    logger23 = credentialLogger("AuthorizationCodeCredential");
    AuthorizationCodeCredential = class {
      /**
       * @hidden
       * @internal
       */
      constructor(tenantId, clientId, clientSecretOrAuthorizationCode, authorizationCodeOrRedirectUri, redirectUriOrOptions, options) {
        checkTenantId(logger23, tenantId);
        let clientSecret = clientSecretOrAuthorizationCode;
        if (typeof redirectUriOrOptions === "string") {
          this.authorizationCode = authorizationCodeOrRedirectUri;
          this.redirectUri = redirectUriOrOptions;
        } else {
          this.authorizationCode = clientSecretOrAuthorizationCode;
          this.redirectUri = authorizationCodeOrRedirectUri;
          clientSecret = void 0;
          options = redirectUriOrOptions;
        }
        this.msalFlow = new MsalAuthorizationCode(Object.assign(Object.assign({}, options), {
          clientSecret,
          clientId,
          tenantId,
          tokenCredentialOptions: options || {},
          logger: logger23,
          redirectUri: this.redirectUri,
          authorizationCode: this.authorizationCode
        }));
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          return this.msalFlow.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
        });
      }
    };
  }
});
var MsalOnBehalfOf;
var init_msalOnBehalfOf = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/msal/nodeFlows/msalOnBehalfOf.js"() {
    "use strict";
    init_logging();
    init_msalClientCertificate();
    init_msalNodeCommon();
    MsalOnBehalfOf = class extends MsalNode {
      constructor(options) {
        super(options);
        this.logger.info("Initialized MSAL's On-Behalf-Of flow");
        this.requiresConfidential = true;
        this.userAssertionToken = options.userAssertionToken;
        this.certificatePath = options.certificatePath;
        this.sendCertificateChain = options.sendCertificateChain;
        this.clientSecret = options.clientSecret;
      }
      // Changing the MSAL configuration asynchronously
      async init(options) {
        if (this.certificatePath) {
          try {
            const parts = await parseCertificate({ certificatePath: this.certificatePath }, this.sendCertificateChain);
            this.msalConfig.auth.clientCertificate = {
              thumbprint: parts.thumbprint,
              privateKey: parts.certificateContents,
              x5c: parts.x5c
            };
          } catch (error) {
            this.logger.info(formatError("", error));
            throw error;
          }
        } else {
          this.msalConfig.auth.clientSecret = this.clientSecret;
        }
        return super.init(options);
      }
      async doGetToken(scopes, options = {}) {
        try {
          const result = await this.confidentialApp.acquireTokenOnBehalfOf({
            scopes,
            correlationId: options.correlationId,
            authority: options.authority,
            claims: options.claims,
            oboAssertion: this.userAssertionToken
          });
          return this.handleResult(scopes, this.clientId, result || void 0);
        } catch (err) {
          throw this.handleError(scopes, err, options);
        }
      }
    };
  }
});
var credentialName3, logger24, OnBehalfOfCredential;
var init_onBehalfOfCredential = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/credentials/onBehalfOfCredential.js"() {
    "use strict";
    init_msalOnBehalfOf();
    init_logging();
    init_tracing();
    credentialName3 = "OnBehalfOfCredential";
    logger24 = credentialLogger(credentialName3);
    OnBehalfOfCredential = class {
      constructor(options) {
        this.options = options;
        const { clientSecret } = options;
        const { certificatePath } = options;
        const { tenantId, clientId, userAssertionToken } = options;
        if (!tenantId || !clientId || !(clientSecret || certificatePath) || !userAssertionToken) {
          throw new Error(`${credentialName3}: tenantId, clientId, clientSecret (or certificatePath) and userAssertionToken are required parameters.`);
        }
        this.msalFlow = new MsalOnBehalfOf(Object.assign(Object.assign({}, this.options), { logger: logger24, tokenCredentialOptions: this.options }));
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure the underlying network requests.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${credentialName3}.getToken`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          return this.msalFlow.getToken(arrayScopes, newOptions);
        });
      }
    };
  }
});
var src_exports = {};
(0, import_chunk_FVJ3R4NJ.__export)(src_exports, {
  AggregateAuthenticationError: () => AggregateAuthenticationError,
  AggregateAuthenticationErrorName: () => AggregateAuthenticationErrorName,
  AuthenticationError: () => AuthenticationError,
  AuthenticationErrorName: () => AuthenticationErrorName,
  AuthenticationRequiredError: () => AuthenticationRequiredError,
  AuthorizationCodeCredential: () => AuthorizationCodeCredential,
  AzureAuthorityHosts: () => AzureAuthorityHosts,
  AzureCliCredential: () => AzureCliCredential,
  AzurePowerShellCredential: () => AzurePowerShellCredential,
  ChainedTokenCredential: () => ChainedTokenCredential,
  ClientAssertionCredential: () => ClientAssertionCredential,
  ClientCertificateCredential: () => ClientCertificateCredential,
  ClientSecretCredential: () => ClientSecretCredential,
  CredentialUnavailableError: () => CredentialUnavailableError,
  CredentialUnavailableErrorName: () => CredentialUnavailableErrorName,
  DefaultAzureCredential: () => DefaultAzureCredential,
  DeviceCodeCredential: () => DeviceCodeCredential,
  EnvironmentCredential: () => EnvironmentCredential,
  InteractiveBrowserCredential: () => InteractiveBrowserCredential,
  ManagedIdentityCredential: () => ManagedIdentityCredential,
  OnBehalfOfCredential: () => OnBehalfOfCredential,
  UsernamePasswordCredential: () => UsernamePasswordCredential,
  VisualStudioCodeCredential: () => VisualStudioCodeCredential,
  deserializeAuthenticationRecord: () => deserializeAuthenticationRecord,
  getDefaultAzureCredential: () => getDefaultAzureCredential,
  logger: () => logger3,
  serializeAuthenticationRecord: () => serializeAuthenticationRecord,
  useIdentityPlugin: () => useIdentityPlugin
});
function getDefaultAzureCredential() {
  return new DefaultAzureCredential();
}
var init_src7 = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@azure+identity@2.1.0/node_modules/@azure/identity/dist-esm/src/index.js"() {
    "use strict";
    init_consumer();
    init_defaultAzureCredential();
    init_errors();
    init_utils2();
    init_chainedTokenCredential();
    init_defaultAzureCredential();
    init_environmentCredential();
    init_clientSecretCredential();
    init_clientCertificateCredential();
    init_clientAssertionCredential();
    init_azureCliCredential();
    init_interactiveBrowserCredential();
    init_managedIdentityCredential();
    init_deviceCodeCredential();
    init_usernamePasswordCredential();
    init_authorizationCodeCredential();
    init_azurePowerShellCredential();
    init_visualStudioCodeCredential();
    init_onBehalfOfCredential();
    init_logging();
    init_constants2();
  }
});
var require_debug = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/debug.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _events = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var util2 = _interopRequireWildcard((0, import_chunk_FVJ3R4NJ.__require)("util"));
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Debug = class extends _events.EventEmitter {
      /*
        @options    Which debug details should be sent.
                    data    - dump of packet data
                    payload - details of decoded payload
      */
      constructor({
        data = false,
        payload = false,
        packet = false,
        token = false
      } = {}) {
        super();
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "options");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "indent");
        this.options = {
          data,
          payload,
          packet,
          token
        };
        this.indent = "  ";
      }
      packet(direction, packet) {
        if (this.haveListeners() && this.options.packet) {
          this.log("");
          this.log(direction);
          this.log(packet.headerToString(this.indent));
        }
      }
      data(packet) {
        if (this.haveListeners() && this.options.data) {
          this.log(packet.dataToString(this.indent));
        }
      }
      payload(generatePayloadText) {
        if (this.haveListeners() && this.options.payload) {
          this.log(generatePayloadText());
        }
      }
      token(token) {
        if (this.haveListeners() && this.options.token) {
          this.log(util2.inspect(token, {
            showHidden: false,
            depth: 5,
            colors: true
          }));
        }
      }
      haveListeners() {
        return this.listeners("debug").length > 0;
      }
      log(text) {
        this.emit("debug", text);
      }
    };
    var _default = Debug;
    exports.default = _default;
    module2.exports = Debug;
  }
});
var require_abort_error = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/errors/abort-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AbortError2 = class extends Error {
      constructor() {
        super("The operation was aborted");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "code");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    exports.default = AbortError2;
  }
});
var require_sender = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/sender.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sendInParallel = sendInParallel;
    exports.sendMessage = sendMessage;
    var _dgram = _interopRequireDefault((0, import_chunk_FVJ3R4NJ.__require)("dgram"));
    var _net = _interopRequireDefault((0, import_chunk_FVJ3R4NJ.__require)("net"));
    var punycode = _interopRequireWildcard((0, import_chunk_FVJ3R4NJ.__require)("punycode"));
    var _abortError = _interopRequireDefault(require_abort_error());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function sendInParallel(addresses, port, request3, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      return await new Promise((resolve, reject) => {
        const sockets = [];
        let errorCount = 0;
        const onError = (err) => {
          errorCount++;
          if (errorCount === addresses.length) {
            signal.removeEventListener("abort", onAbort);
            clearSockets();
            reject(err);
          }
        };
        const onMessage = (message) => {
          signal.removeEventListener("abort", onAbort);
          clearSockets();
          resolve(message);
        };
        const onAbort = () => {
          clearSockets();
          reject(new _abortError.default());
        };
        const clearSockets = () => {
          for (const socket of sockets) {
            socket.removeListener("error", onError);
            socket.removeListener("message", onMessage);
            socket.close();
          }
        };
        signal.addEventListener("abort", onAbort, {
          once: true
        });
        for (let j = 0; j < addresses.length; j++) {
          const udpType = addresses[j].family === 6 ? "udp6" : "udp4";
          const socket = _dgram.default.createSocket(udpType);
          sockets.push(socket);
          socket.on("error", onError);
          socket.on("message", onMessage);
          socket.send(request3, 0, request3.length, port, addresses[j].address);
        }
      });
    }
    async function sendMessage(host, port, lookup, signal, request3) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      let addresses;
      if (_net.default.isIP(host)) {
        addresses = [{
          address: host,
          family: _net.default.isIPv6(host) ? 6 : 4
        }];
      } else {
        addresses = await new Promise((resolve, reject) => {
          const onAbort = () => {
            reject(new _abortError.default());
          };
          signal.addEventListener("abort", onAbort);
          lookup(punycode.toASCII(host), {
            all: true
          }, (err, addresses2) => {
            signal.removeEventListener("abort", onAbort);
            err ? reject(err) : resolve(addresses2);
          });
        });
      }
      return await sendInParallel(addresses, port, request3, signal);
    }
  }
});
var require_node_abort_controller = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/node-abort-controller@3.1.1/node_modules/node-abort-controller/index.js"(exports, module2) {
    "use strict";
    var { EventEmitter } = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var AbortSignal2 = class {
      constructor() {
        this.eventEmitter = new EventEmitter();
        this.onabort = null;
        this.aborted = false;
        this.reason = void 0;
      }
      toString() {
        return "[object AbortSignal]";
      }
      get [Symbol.toStringTag]() {
        return "AbortSignal";
      }
      removeEventListener(name3, handler) {
        this.eventEmitter.removeListener(name3, handler);
      }
      addEventListener(name3, handler) {
        this.eventEmitter.on(name3, handler);
      }
      dispatchEvent(type2) {
        const event = { type: type2, target: this };
        const handlerName = `on${type2}`;
        if (typeof this[handlerName] === "function")
          this[handlerName](event);
        this.eventEmitter.emit(type2, event);
      }
      throwIfAborted() {
        if (this.aborted) {
          throw this.reason;
        }
      }
      static abort(reason) {
        const controller = new AbortController2();
        controller.abort();
        return controller.signal;
      }
      static timeout(time) {
        const controller = new AbortController2();
        setTimeout(() => controller.abort(new Error("TimeoutError")), time);
        return controller.signal;
      }
    };
    var AbortController2 = class {
      constructor() {
        this.signal = new AbortSignal2();
      }
      abort(reason) {
        if (this.signal.aborted)
          return;
        this.signal.aborted = true;
        if (reason)
          this.signal.reason = reason;
        else
          this.signal.reason = new Error("AbortError");
        this.signal.dispatchEvent("abort");
      }
      toString() {
        return "[object AbortController]";
      }
      get [Symbol.toStringTag]() {
        return "AbortController";
      }
    };
    module2.exports = { AbortController: AbortController2, AbortSignal: AbortSignal2 };
  }
});
var require_timeout_error = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/errors/timeout-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimeoutError = class extends Error {
      constructor() {
        super("The operation was aborted due to timeout");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "code");
        this.code = "TIMEOUT_ERR";
        this.name = "TimeoutError";
      }
    };
    exports.default = TimeoutError;
  }
});
var require_with_timeout = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/utils/with-timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.withTimeout = withTimeout;
    var _nodeAbortController = require_node_abort_controller();
    var _timeoutError = _interopRequireDefault(require_timeout_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function withTimeout(timeout, func, signal) {
      const timeoutController = new _nodeAbortController.AbortController();
      const abortCurrentAttempt = () => {
        timeoutController.abort();
      };
      const timer = setTimeout(abortCurrentAttempt, timeout);
      signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", abortCurrentAttempt, {
        once: true
      });
      try {
        return await func(timeoutController.signal);
      } catch (err) {
        if (err instanceof Error && err.name === "AbortError" && !(signal && signal.aborted)) {
          throw new _timeoutError.default();
        }
        throw err;
      } finally {
        signal === null || signal === void 0 ? void 0 : signal.removeEventListener("abort", abortCurrentAttempt);
        clearTimeout(timer);
      }
    }
  }
});
var require_instance_lookup = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/instance-lookup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.instanceLookup = instanceLookup;
    exports.parseBrowserResponse = parseBrowserResponse;
    var _dns = _interopRequireDefault((0, import_chunk_FVJ3R4NJ.__require)("dns"));
    var _abortError = _interopRequireDefault(require_abort_error());
    var _sender = require_sender();
    var _withTimeout = require_with_timeout();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SQL_SERVER_BROWSER_PORT = 1434;
    var TIMEOUT = 2 * 1e3;
    var RETRIES = 3;
    var MYSTERY_HEADER_LENGTH = 3;
    async function instanceLookup(options) {
      const server = options.server;
      if (typeof server !== "string") {
        throw new TypeError('Invalid arguments: "server" must be a string');
      }
      const instanceName = options.instanceName;
      if (typeof instanceName !== "string") {
        throw new TypeError('Invalid arguments: "instanceName" must be a string');
      }
      const timeout = options.timeout === void 0 ? TIMEOUT : options.timeout;
      if (typeof timeout !== "number") {
        throw new TypeError('Invalid arguments: "timeout" must be a number');
      }
      const retries = options.retries === void 0 ? RETRIES : options.retries;
      if (typeof retries !== "number") {
        throw new TypeError('Invalid arguments: "retries" must be a number');
      }
      if (options.lookup !== void 0 && typeof options.lookup !== "function") {
        throw new TypeError('Invalid arguments: "lookup" must be a function');
      }
      const lookup = options.lookup ?? _dns.default.lookup;
      if (options.port !== void 0 && typeof options.port !== "number") {
        throw new TypeError('Invalid arguments: "port" must be a number');
      }
      const port = options.port ?? SQL_SERVER_BROWSER_PORT;
      const signal = options.signal;
      if (signal.aborted) {
        throw new _abortError.default();
      }
      let response;
      for (let i = 0; i <= retries; i++) {
        try {
          response = await (0, _withTimeout.withTimeout)(timeout, async (signal2) => {
            const request3 = Buffer.from([2]);
            return await (0, _sender.sendMessage)(options.server, port, lookup, signal2, request3);
          }, signal);
        } catch (err) {
          if (!signal.aborted && err instanceof Error && err.name === "TimeoutError") {
            continue;
          }
          throw err;
        }
      }
      if (!response) {
        throw new Error("Failed to get response from SQL Server Browser on " + server);
      }
      const message = response.toString("ascii", MYSTERY_HEADER_LENGTH);
      const foundPort = parseBrowserResponse(message, instanceName);
      if (!foundPort) {
        throw new Error("Port for " + instanceName + " not found in " + options.server);
      }
      return foundPort;
    }
    function parseBrowserResponse(response, instanceName) {
      let getPort;
      const instances = response.split(";;");
      for (let i = 0, len = instances.length; i < len; i++) {
        const instance = instances[i];
        const parts = instance.split(";");
        for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {
          const name3 = parts[p];
          const value = parts[p + 1];
          if (name3 === "tcp" && getPort) {
            const port = parseInt(value, 10);
            return port;
          }
          if (name3 === "InstanceName") {
            if (value.toUpperCase() === instanceName.toUpperCase()) {
              getPort = true;
            } else {
              getPort = false;
            }
          }
        }
      }
    }
  }
});
var require_transient_error_lookup = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/transient-error-lookup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TransientErrorLookup = void 0;
    var TransientErrorLookup = class {
      isTransientError(error) {
        const transientErrors = [4060, 10928, 10929, 40197, 40501, 40613];
        return transientErrors.indexOf(error) !== -1;
      }
    };
    exports.TransientErrorLookup = TransientErrorLookup;
  }
});
var require_sprintf = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/sprintf-js@1.1.2/node_modules/sprintf-js/src/sprintf.js"(exports) {
    "use strict";
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign2;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign2 = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign2 = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign2 + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign2 + arg + pad : pad_character === "0" ? sign2 + pad + arg : pad + sign2 + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports !== "undefined") {
        exports["sprintf"] = sprintf;
        exports["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});
var require_packet = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/packet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TYPE = exports.Packet = exports.OFFSET = exports.HEADER_LENGTH = void 0;
    exports.isPacketComplete = isPacketComplete;
    exports.packetLength = packetLength;
    var _sprintfJs = require_sprintf();
    var HEADER_LENGTH = 8;
    exports.HEADER_LENGTH = HEADER_LENGTH;
    var TYPE = {
      SQL_BATCH: 1,
      RPC_REQUEST: 3,
      TABULAR_RESULT: 4,
      ATTENTION: 6,
      BULK_LOAD: 7,
      TRANSACTION_MANAGER: 14,
      LOGIN7: 16,
      NTLMAUTH_PKT: 17,
      PRELOGIN: 18,
      FEDAUTH_TOKEN: 8
    };
    exports.TYPE = TYPE;
    var typeByValue = {};
    for (const name3 in TYPE) {
      typeByValue[TYPE[name3]] = name3;
    }
    var STATUS = {
      NORMAL: 0,
      EOM: 1,
      IGNORE: 2,
      RESETCONNECTION: 8,
      RESETCONNECTIONSKIPTRAN: 16
    };
    var OFFSET = {
      Type: 0,
      Status: 1,
      Length: 2,
      SPID: 4,
      PacketID: 6,
      Window: 7
    };
    exports.OFFSET = OFFSET;
    var DEFAULT_SPID = 0;
    var DEFAULT_PACKETID = 1;
    var DEFAULT_WINDOW = 0;
    var NL = "\n";
    var Packet = class {
      constructor(typeOrBuffer) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "buffer");
        if (typeOrBuffer instanceof Buffer) {
          this.buffer = typeOrBuffer;
        } else {
          const type2 = typeOrBuffer;
          this.buffer = Buffer.alloc(HEADER_LENGTH, 0);
          this.buffer.writeUInt8(type2, OFFSET.Type);
          this.buffer.writeUInt8(STATUS.NORMAL, OFFSET.Status);
          this.buffer.writeUInt16BE(DEFAULT_SPID, OFFSET.SPID);
          this.buffer.writeUInt8(DEFAULT_PACKETID, OFFSET.PacketID);
          this.buffer.writeUInt8(DEFAULT_WINDOW, OFFSET.Window);
          this.setLength();
        }
      }
      setLength() {
        this.buffer.writeUInt16BE(this.buffer.length, OFFSET.Length);
      }
      length() {
        return this.buffer.readUInt16BE(OFFSET.Length);
      }
      resetConnection(reset) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (reset) {
          status |= STATUS.RESETCONNECTION;
        } else {
          status &= 255 - STATUS.RESETCONNECTION;
        }
        this.buffer.writeUInt8(status, OFFSET.Status);
      }
      last(last) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (arguments.length > 0) {
          if (last) {
            status |= STATUS.EOM;
          } else {
            status &= 255 - STATUS.EOM;
          }
          this.buffer.writeUInt8(status, OFFSET.Status);
        }
        return this.isLast();
      }
      ignore(last) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (last) {
          status |= STATUS.IGNORE;
        } else {
          status &= 255 - STATUS.IGNORE;
        }
        this.buffer.writeUInt8(status, OFFSET.Status);
      }
      isLast() {
        return !!(this.buffer.readUInt8(OFFSET.Status) & STATUS.EOM);
      }
      packetId(packetId) {
        if (packetId) {
          this.buffer.writeUInt8(packetId % 256, OFFSET.PacketID);
        }
        return this.buffer.readUInt8(OFFSET.PacketID);
      }
      addData(data) {
        this.buffer = Buffer.concat([this.buffer, data]);
        this.setLength();
        return this;
      }
      data() {
        return this.buffer.slice(HEADER_LENGTH);
      }
      type() {
        return this.buffer.readUInt8(OFFSET.Type);
      }
      statusAsString() {
        const status = this.buffer.readUInt8(OFFSET.Status);
        const statuses = [];
        for (const name3 in STATUS) {
          const value = STATUS[name3];
          if (status & value) {
            statuses.push(name3);
          } else {
            statuses.push(void 0);
          }
        }
        return statuses.join(" ").trim();
      }
      headerToString(indent = "") {
        const text = (0, _sprintfJs.sprintf)("type:0x%02X(%s), status:0x%02X(%s), length:0x%04X, spid:0x%04X, packetId:0x%02X, window:0x%02X", this.buffer.readUInt8(OFFSET.Type), typeByValue[this.buffer.readUInt8(OFFSET.Type)], this.buffer.readUInt8(OFFSET.Status), this.statusAsString(), this.buffer.readUInt16BE(OFFSET.Length), this.buffer.readUInt16BE(OFFSET.SPID), this.buffer.readUInt8(OFFSET.PacketID), this.buffer.readUInt8(OFFSET.Window));
        return indent + text;
      }
      dataToString(indent = "") {
        const BYTES_PER_GROUP = 4;
        const CHARS_PER_GROUP = 8;
        const BYTES_PER_LINE = 32;
        const data = this.data();
        let dataDump = "";
        let chars = "";
        for (let offset = 0; offset < data.length; offset++) {
          if (offset % BYTES_PER_LINE === 0) {
            dataDump += indent;
            dataDump += (0, _sprintfJs.sprintf)("%04X  ", offset);
          }
          if (data[offset] < 32 || data[offset] > 126) {
            chars += ".";
            if ((offset + 1) % CHARS_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
              chars += " ";
            }
          } else {
            chars += String.fromCharCode(data[offset]);
          }
          if (data[offset] != null) {
            dataDump += (0, _sprintfJs.sprintf)("%02X", data[offset]);
          }
          if ((offset + 1) % BYTES_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
            dataDump += " ";
          }
          if ((offset + 1) % BYTES_PER_LINE === 0) {
            dataDump += "  " + chars;
            chars = "";
            if (offset < data.length - 1) {
              dataDump += NL;
            }
          }
        }
        if (chars.length) {
          dataDump += "  " + chars;
        }
        return dataDump;
      }
      toString(indent = "") {
        return this.headerToString(indent) + "\n" + this.dataToString(indent + indent);
      }
      payloadString() {
        return "";
      }
    };
    exports.Packet = Packet;
    function isPacketComplete(potentialPacketBuffer) {
      if (potentialPacketBuffer.length < HEADER_LENGTH) {
        return false;
      } else {
        return potentialPacketBuffer.length >= potentialPacketBuffer.readUInt16BE(OFFSET.Length);
      }
    }
    function packetLength(potentialPacketBuffer) {
      return potentialPacketBuffer.readUInt16BE(OFFSET.Length);
    }
  }
});
var require_prelogin_payload = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/prelogin-payload.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _sprintfJs = require_sprintf();
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var optionBufferSize = 20;
    var TOKEN = {
      VERSION: 0,
      ENCRYPTION: 1,
      INSTOPT: 2,
      THREADID: 3,
      MARS: 4,
      FEDAUTHREQUIRED: 6,
      TERMINATOR: 255
    };
    var ENCRYPT = {
      OFF: 0,
      ON: 1,
      NOT_SUP: 2,
      REQ: 3
    };
    var encryptByValue = {};
    for (const name3 in ENCRYPT) {
      const value = ENCRYPT[name3];
      encryptByValue[value] = name3;
    }
    var MARS = {
      OFF: 0,
      ON: 1
    };
    var marsByValue = {};
    for (const name3 in MARS) {
      const value = MARS[name3];
      marsByValue[value] = name3;
    }
    var PreloginPayload = class {
      constructor(bufferOrOptions = {
        encrypt: false,
        version: {
          major: 0,
          minor: 0,
          build: 0,
          subbuild: 0
        }
      }) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "data");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "options");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "version");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "encryption");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "encryptionString");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "instance");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "threadId");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "mars");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "marsString");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "fedAuthRequired");
        if (bufferOrOptions instanceof Buffer) {
          this.data = bufferOrOptions;
          this.options = {
            encrypt: false,
            version: {
              major: 0,
              minor: 0,
              build: 0,
              subbuild: 0
            }
          };
        } else {
          this.options = bufferOrOptions;
          this.createOptions();
        }
        this.extractOptions();
      }
      createOptions() {
        const options = [this.createVersionOption(), this.createEncryptionOption(), this.createInstanceOption(), this.createThreadIdOption(), this.createMarsOption(), this.createFedAuthOption()];
        let length = 0;
        for (let i = 0, len = options.length; i < len; i++) {
          const option = options[i];
          length += 5 + option.data.length;
        }
        length++;
        this.data = Buffer.alloc(length, 0);
        let optionOffset = 0;
        let optionDataOffset = 5 * options.length + 1;
        for (let j = 0, len = options.length; j < len; j++) {
          const option = options[j];
          this.data.writeUInt8(option.token, optionOffset + 0);
          this.data.writeUInt16BE(optionDataOffset, optionOffset + 1);
          this.data.writeUInt16BE(option.data.length, optionOffset + 3);
          optionOffset += 5;
          option.data.copy(this.data, optionDataOffset);
          optionDataOffset += option.data.length;
        }
        this.data.writeUInt8(TOKEN.TERMINATOR, optionOffset);
      }
      createVersionOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(this.options.version.major);
        buffer.writeUInt8(this.options.version.minor);
        buffer.writeUInt16BE(this.options.version.build);
        buffer.writeUInt16BE(this.options.version.subbuild);
        return {
          token: TOKEN.VERSION,
          data: buffer.data
        };
      }
      createEncryptionOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        if (this.options.encrypt) {
          buffer.writeUInt8(ENCRYPT.ON);
        } else {
          buffer.writeUInt8(ENCRYPT.NOT_SUP);
        }
        return {
          token: TOKEN.ENCRYPTION,
          data: buffer.data
        };
      }
      createInstanceOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(0);
        return {
          token: TOKEN.INSTOPT,
          data: buffer.data
        };
      }
      createThreadIdOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt32BE(0);
        return {
          token: TOKEN.THREADID,
          data: buffer.data
        };
      }
      createMarsOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(MARS.OFF);
        return {
          token: TOKEN.MARS,
          data: buffer.data
        };
      }
      createFedAuthOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(1);
        return {
          token: TOKEN.FEDAUTHREQUIRED,
          data: buffer.data
        };
      }
      extractOptions() {
        let offset = 0;
        while (this.data[offset] !== TOKEN.TERMINATOR) {
          let dataOffset = this.data.readUInt16BE(offset + 1);
          const dataLength = this.data.readUInt16BE(offset + 3);
          switch (this.data[offset]) {
            case TOKEN.VERSION:
              this.extractVersion(dataOffset);
              break;
            case TOKEN.ENCRYPTION:
              this.extractEncryption(dataOffset);
              break;
            case TOKEN.INSTOPT:
              this.extractInstance(dataOffset);
              break;
            case TOKEN.THREADID:
              if (dataLength > 0) {
                this.extractThreadId(dataOffset);
              }
              break;
            case TOKEN.MARS:
              this.extractMars(dataOffset);
              break;
            case TOKEN.FEDAUTHREQUIRED:
              this.extractFedAuth(dataOffset);
              break;
          }
          offset += 5;
          dataOffset += dataLength;
        }
      }
      extractVersion(offset) {
        this.version = {
          major: this.data.readUInt8(offset + 0),
          minor: this.data.readUInt8(offset + 1),
          build: this.data.readUInt16BE(offset + 2),
          subbuild: this.data.readUInt16BE(offset + 4)
        };
      }
      extractEncryption(offset) {
        this.encryption = this.data.readUInt8(offset);
        this.encryptionString = encryptByValue[this.encryption];
      }
      extractInstance(offset) {
        this.instance = this.data.readUInt8(offset);
      }
      extractThreadId(offset) {
        this.threadId = this.data.readUInt32BE(offset);
      }
      extractMars(offset) {
        this.mars = this.data.readUInt8(offset);
        this.marsString = marsByValue[this.mars];
      }
      extractFedAuth(offset) {
        this.fedAuthRequired = this.data.readUInt8(offset);
      }
      toString(indent = "") {
        return indent + "PreLogin - " + (0, _sprintfJs.sprintf)("version:%d.%d.%d.%d, encryption:0x%02X(%s), instopt:0x%02X, threadId:0x%08X, mars:0x%02X(%s)", this.version.major, this.version.minor, this.version.build, this.version.subbuild, this.encryption ? this.encryption : 0, this.encryptionString ? this.encryptionString : "", this.instance ? this.instance : 0, this.threadId ? this.threadId : 0, this.mars ? this.mars : 0, this.marsString ? this.marsString : "");
      }
    };
    var _default = PreloginPayload;
    exports.default = _default;
    module2.exports = PreloginPayload;
  }
});
var require_tds_versions = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/tds-versions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.versionsByValue = exports.versions = void 0;
    var versions = {
      "7_1": 1895825409,
      "7_2": 1913192450,
      "7_3_A": 1930035203,
      "7_3_B": 1930100739,
      "7_4": 1946157060,
      "8_0": 134217728
    };
    exports.versions = versions;
    var versionsByValue = {};
    exports.versionsByValue = versionsByValue;
    for (const name3 in versions) {
      versionsByValue[versions[name3]] = name3;
    }
  }
});
var require_login7_payload = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/login7-payload.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _sprintfJs = require_sprintf();
    var _tdsVersions = require_tds_versions();
    var FLAGS_1 = {
      ENDIAN_LITTLE: 0,
      ENDIAN_BIG: 1,
      CHARSET_ASCII: 0,
      CHARSET_EBCDIC: 2,
      FLOAT_IEEE_754: 0,
      FLOAT_VAX: 4,
      FLOAT_ND5000: 8,
      BCP_DUMPLOAD_ON: 0,
      BCP_DUMPLOAD_OFF: 16,
      USE_DB_ON: 0,
      USE_DB_OFF: 32,
      INIT_DB_WARN: 0,
      INIT_DB_FATAL: 64,
      SET_LANG_WARN_OFF: 0,
      SET_LANG_WARN_ON: 128
    };
    var FLAGS_2 = {
      INIT_LANG_WARN: 0,
      INIT_LANG_FATAL: 1,
      ODBC_OFF: 0,
      ODBC_ON: 2,
      F_TRAN_BOUNDARY: 4,
      F_CACHE_CONNECT: 8,
      USER_NORMAL: 0,
      USER_SERVER: 16,
      USER_REMUSER: 32,
      USER_SQLREPL: 64,
      INTEGRATED_SECURITY_OFF: 0,
      INTEGRATED_SECURITY_ON: 128
    };
    var TYPE_FLAGS = {
      SQL_DFLT: 0,
      SQL_TSQL: 8,
      OLEDB_OFF: 0,
      OLEDB_ON: 16,
      READ_WRITE_INTENT: 0,
      READ_ONLY_INTENT: 32
    };
    var FLAGS_3 = {
      CHANGE_PASSWORD_NO: 0,
      CHANGE_PASSWORD_YES: 1,
      BINARY_XML: 2,
      SPAWN_USER_INSTANCE: 4,
      UNKNOWN_COLLATION_HANDLING: 8,
      EXTENSION_USED: 16
    };
    var FEDAUTH_OPTIONS = {
      FEATURE_ID: 2,
      LIBRARY_SECURITYTOKEN: 1,
      LIBRARY_ADAL: 2,
      FEDAUTH_YES_ECHO: 1,
      FEDAUTH_NO_ECHO: 0,
      ADAL_WORKFLOW_USER_PASS: 1,
      ADAL_WORKFLOW_INTEGRATED: 2
    };
    var FEATURE_EXT_TERMINATOR = 255;
    var Login7Payload = class {
      constructor({
        tdsVersion,
        packetSize,
        clientProgVer,
        clientPid,
        connectionId,
        clientTimeZone,
        clientLcid
      }) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "tdsVersion");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "packetSize");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "clientProgVer");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "clientPid");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "connectionId");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "clientTimeZone");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "clientLcid");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "readOnlyIntent");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "initDbFatal");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "userName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "password");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "serverName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "appName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "hostname");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "libraryName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "language");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "database");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "clientId");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "sspi");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "attachDbFile");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "changePassword");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "fedAuth");
        this.tdsVersion = tdsVersion;
        this.packetSize = packetSize;
        this.clientProgVer = clientProgVer;
        this.clientPid = clientPid;
        this.connectionId = connectionId;
        this.clientTimeZone = clientTimeZone;
        this.clientLcid = clientLcid;
        this.readOnlyIntent = false;
        this.initDbFatal = false;
        this.fedAuth = void 0;
        this.userName = void 0;
        this.password = void 0;
        this.serverName = void 0;
        this.appName = void 0;
        this.hostname = void 0;
        this.libraryName = void 0;
        this.language = void 0;
        this.database = void 0;
        this.clientId = void 0;
        this.sspi = void 0;
        this.attachDbFile = void 0;
        this.changePassword = void 0;
      }
      toBuffer() {
        const fixedData = Buffer.alloc(94);
        const buffers = [fixedData];
        let offset = 0;
        let dataOffset = fixedData.length;
        offset = fixedData.writeUInt32LE(0, offset);
        offset = fixedData.writeUInt32LE(this.tdsVersion, offset);
        offset = fixedData.writeUInt32LE(this.packetSize, offset);
        offset = fixedData.writeUInt32LE(this.clientProgVer, offset);
        offset = fixedData.writeUInt32LE(this.clientPid, offset);
        offset = fixedData.writeUInt32LE(this.connectionId, offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags1(), offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags2(), offset);
        offset = fixedData.writeUInt8(this.buildTypeFlags(), offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags3(), offset);
        offset = fixedData.writeInt32LE(this.clientTimeZone, offset);
        offset = fixedData.writeUInt32LE(this.clientLcid, offset);
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.hostname) {
          const buffer = Buffer.from(this.hostname, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(dataOffset, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.userName) {
          const buffer = Buffer.from(this.userName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.password) {
          const buffer = Buffer.from(this.password, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(this.scramblePassword(buffer));
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.appName) {
          const buffer = Buffer.from(this.appName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.serverName) {
          const buffer = Buffer.from(this.serverName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        const extensions = this.buildFeatureExt();
        offset = fixedData.writeUInt16LE(4, offset);
        const extensionOffset = Buffer.alloc(4);
        extensionOffset.writeUInt32LE(dataOffset += 4, 0);
        dataOffset += extensions.length;
        buffers.push(extensionOffset, extensions);
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.libraryName) {
          const buffer = Buffer.from(this.libraryName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.language) {
          const buffer = Buffer.from(this.language, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.database) {
          const buffer = Buffer.from(this.database, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        if (this.clientId) {
          this.clientId.copy(fixedData, offset, 0, 6);
        }
        offset += 6;
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.sspi) {
          if (this.sspi.length > 65535) {
            offset = fixedData.writeUInt16LE(65535, offset);
          } else {
            offset = fixedData.writeUInt16LE(this.sspi.length, offset);
          }
          buffers.push(this.sspi);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.attachDbFile) {
          const buffer = Buffer.from(this.attachDbFile, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.changePassword) {
          const buffer = Buffer.from(this.changePassword, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        if (this.sspi && this.sspi.length > 65535) {
          fixedData.writeUInt32LE(this.sspi.length, offset);
        } else {
          fixedData.writeUInt32LE(0, offset);
        }
        const data = Buffer.concat(buffers);
        data.writeUInt32LE(data.length, 0);
        return data;
      }
      buildOptionFlags1() {
        let flags1 = FLAGS_1.ENDIAN_LITTLE | FLAGS_1.CHARSET_ASCII | FLAGS_1.FLOAT_IEEE_754 | FLAGS_1.BCP_DUMPLOAD_OFF | FLAGS_1.USE_DB_OFF | FLAGS_1.SET_LANG_WARN_ON;
        if (this.initDbFatal) {
          flags1 |= FLAGS_1.INIT_DB_FATAL;
        } else {
          flags1 |= FLAGS_1.INIT_DB_WARN;
        }
        return flags1;
      }
      buildFeatureExt() {
        const buffers = [];
        const fedAuth = this.fedAuth;
        if (fedAuth) {
          switch (fedAuth.type) {
            case "ADAL":
              const buffer = Buffer.alloc(7);
              buffer.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, 0);
              buffer.writeUInt32LE(2, 1);
              buffer.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_ADAL << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), 5);
              buffer.writeUInt8(fedAuth.workflow === "integrated" ? 2 : FEDAUTH_OPTIONS.ADAL_WORKFLOW_USER_PASS, 6);
              buffers.push(buffer);
              break;
            case "SECURITYTOKEN":
              const token = Buffer.from(fedAuth.fedAuthToken, "ucs2");
              const buf = Buffer.alloc(10);
              let offset = 0;
              offset = buf.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, offset);
              offset = buf.writeUInt32LE(token.length + 4 + 1, offset);
              offset = buf.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_SECURITYTOKEN << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), offset);
              buf.writeInt32LE(token.length, offset);
              buffers.push(buf);
              buffers.push(token);
              break;
          }
        }
        if (this.tdsVersion >= _tdsVersions.versions["7_4"]) {
          const UTF8_SUPPORT_FEATURE_ID = 10;
          const UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8 = 1;
          const buf = Buffer.alloc(6);
          buf.writeUInt8(UTF8_SUPPORT_FEATURE_ID, 0);
          buf.writeUInt32LE(1, 1);
          buf.writeUInt8(UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8, 5);
          buffers.push(buf);
        }
        buffers.push(Buffer.from([FEATURE_EXT_TERMINATOR]));
        return Buffer.concat(buffers);
      }
      buildOptionFlags2() {
        let flags2 = FLAGS_2.INIT_LANG_WARN | FLAGS_2.ODBC_OFF | FLAGS_2.USER_NORMAL;
        if (this.sspi) {
          flags2 |= FLAGS_2.INTEGRATED_SECURITY_ON;
        } else {
          flags2 |= FLAGS_2.INTEGRATED_SECURITY_OFF;
        }
        return flags2;
      }
      buildTypeFlags() {
        let typeFlags = TYPE_FLAGS.SQL_DFLT | TYPE_FLAGS.OLEDB_OFF;
        if (this.readOnlyIntent) {
          typeFlags |= TYPE_FLAGS.READ_ONLY_INTENT;
        } else {
          typeFlags |= TYPE_FLAGS.READ_WRITE_INTENT;
        }
        return typeFlags;
      }
      buildOptionFlags3() {
        return FLAGS_3.CHANGE_PASSWORD_NO | FLAGS_3.UNKNOWN_COLLATION_HANDLING | FLAGS_3.EXTENSION_USED;
      }
      scramblePassword(password) {
        for (let b = 0, len = password.length; b < len; b++) {
          let byte = password[b];
          const lowNibble = byte & 15;
          const highNibble = byte >> 4;
          byte = lowNibble << 4 | highNibble;
          byte = byte ^ 165;
          password[b] = byte;
        }
        return password;
      }
      toString(indent = "") {
        return indent + "Login7 - " + (0, _sprintfJs.sprintf)("TDS:0x%08X, PacketSize:0x%08X, ClientProgVer:0x%08X, ClientPID:0x%08X, ConnectionID:0x%08X", this.tdsVersion, this.packetSize, this.clientProgVer, this.clientPid, this.connectionId) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Flags1:0x%02X, Flags2:0x%02X, TypeFlags:0x%02X, Flags3:0x%02X, ClientTimezone:%d, ClientLCID:0x%08X", this.buildOptionFlags1(), this.buildOptionFlags2(), this.buildTypeFlags(), this.buildOptionFlags3(), this.clientTimeZone, this.clientLcid) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Hostname:'%s', Username:'%s', Password:'%s', AppName:'%s', ServerName:'%s', LibraryName:'%s'", this.hostname, this.userName, this.password, this.appName, this.serverName, this.libraryName) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Language:'%s', Database:'%s', SSPI:'%s', AttachDbFile:'%s', ChangePassword:'%s'", this.language, this.database, this.sspi, this.attachDbFile, this.changePassword);
      }
    };
    var _default = Login7Payload;
    exports.default = _default;
    module2.exports = Login7Payload;
  }
});
var require_md4 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/js-md4@0.3.2/node_modules/js-md4/src/md4.js"(exports, module2) {
    "use strict";
    (function() {
      "use strict";
      var root = typeof window === "object" ? window : {};
      var NODE_JS = !root.JS_MD4_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      }
      var COMMON_JS = !root.JS_MD4_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_MD4_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [128, 32768, 8388608, -2147483648];
      var SHIFT = [0, 8, 16, 24];
      var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer"];
      var blocks = [], buffer8;
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        buffer8 = new Uint8Array(buffer);
        blocks = new Uint32Array(buffer);
      }
      var createOutputMethod = function(outputType) {
        return function(message) {
          return new Md4(true).update(message)[outputType]();
        };
      };
      var createMethod = function() {
        var method = createOutputMethod("hex");
        if (NODE_JS) {
          method = nodeWrap(method);
        }
        method.create = function() {
          return new Md4();
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type2 = OUTPUT_TYPES[i];
          method[type2] = createOutputMethod(type2);
        }
        return method;
      };
      var nodeWrap = function(method) {
        var crypto3 = (0, import_chunk_FVJ3R4NJ.__require)("crypto");
        var Buffer2 = (0, import_chunk_FVJ3R4NJ.__require)("buffer").Buffer;
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto3.createHash("md4").update(message, "utf8").digest("hex");
          } else if (ARRAY_BUFFER && message instanceof ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (message.length === void 0) {
            return method(message);
          }
          return crypto3.createHash("md4").update(new Buffer2(message)).digest("hex");
        };
        return nodeMethod;
      };
      function Md4(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
          this.buffer8 = buffer8;
        } else {
          if (ARRAY_BUFFER) {
            var buffer2 = new ArrayBuffer(68);
            this.buffer8 = new Uint8Array(buffer2);
            this.blocks = new Uint32Array(buffer2);
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
        }
        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      Md4.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString = typeof message !== "string";
        if (notString && ARRAY_BUFFER && message instanceof ArrayBuffer) {
          message = new Uint8Array(message);
        }
        var code, index = 0, i, length = message.length || 0, blocks2 = this.blocks;
        var buffer82 = this.buffer8;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = blocks2[16];
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                buffer82[i++] = message[index];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            }
          } else {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  buffer82[i++] = code;
                } else if (code < 2048) {
                  buffer82[i++] = 192 | code >> 6;
                  buffer82[i++] = 128 | code & 63;
                } else if (code < 55296 || code >= 57344) {
                  buffer82[i++] = 224 | code >> 12;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  buffer82[i++] = 240 | code >> 18;
                  buffer82[i++] = 128 | code >> 12 & 63;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                }
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        return this;
      };
      Md4.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[i >> 2] |= EXTRA[i & 3];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = blocks2[16];
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.bytes << 3;
        this.hash();
      };
      Md4.prototype.hash = function() {
        var a, b, c, d, ab, bc, cd, da, blocks2 = this.blocks;
        if (this.first) {
          a = blocks2[0] - 1;
          a = a << 3 | a >>> 29;
          d = (a & 4023233417 | ~a & 2562383102) + blocks2[1] + 271733878;
          d = d << 7 | d >>> 25;
          c = (d & a | ~d & 4023233417) + blocks2[2] - 1732584194;
          c = c << 11 | c >>> 21;
          b = (c & d | ~c & a) + blocks2[3] - 271733879;
          b = b << 19 | b >>> 13;
        } else {
          a = this.h0;
          b = this.h1;
          c = this.h2;
          d = this.h3;
          a += (b & c | ~b & d) + blocks2[0];
          a = a << 3 | a >>> 29;
          d += (a & b | ~a & c) + blocks2[1];
          d = d << 7 | d >>> 25;
          c += (d & a | ~d & b) + blocks2[2];
          c = c << 11 | c >>> 21;
          b += (c & d | ~c & a) + blocks2[3];
          b = b << 19 | b >>> 13;
        }
        a += (b & c | ~b & d) + blocks2[4];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[5];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[6];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[7];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[8];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[9];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[10];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[11];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[12];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[13];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[14];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[15];
        b = b << 19 | b >>> 13;
        bc = b & c;
        a += (bc | b & d | c & d) + blocks2[0] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[4] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[8] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[12] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[1] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[5] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[9] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[13] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[2] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[6] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[10] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[14] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[3] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[7] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[11] + 1518500249;
        c = c << 9 | c >>> 23;
        b += (c & d | c & a | da) + blocks2[15] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[0] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[8] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[4] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[12] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[2] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[10] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[6] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[14] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[1] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[9] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[5] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[13] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[3] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[11] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[7] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[15] + 1859775393;
        b = b << 15 | b >>> 17;
        if (this.first) {
          this.h0 = a + 1732584193 << 0;
          this.h1 = b - 271733879 << 0;
          this.h2 = c - 1732584194 << 0;
          this.h3 = d + 271733878 << 0;
          this.first = false;
        } else {
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
        }
      };
      Md4.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
      };
      Md4.prototype.toString = Md4.prototype.hex;
      Md4.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return [
          h0 & 255,
          h0 >> 8 & 255,
          h0 >> 16 & 255,
          h0 >> 24 & 255,
          h1 & 255,
          h1 >> 8 & 255,
          h1 >> 16 & 255,
          h1 >> 24 & 255,
          h2 & 255,
          h2 >> 8 & 255,
          h2 >> 16 & 255,
          h2 >> 24 & 255,
          h3 & 255,
          h3 >> 8 & 255,
          h3 >> 16 & 255,
          h3 >> 24 & 255
        ];
      };
      Md4.prototype.array = Md4.prototype.digest;
      Md4.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(16);
        var blocks2 = new Uint32Array(buffer2);
        blocks2[0] = this.h0;
        blocks2[1] = this.h1;
        blocks2[2] = this.h2;
        blocks2[3] = this.h3;
        return buffer2;
      };
      Md4.prototype.buffer = Md4.prototype.arrayBuffer;
      var exports2 = createMethod();
      if (COMMON_JS) {
        module2.exports = exports2;
      } else {
        root.md4 = exports2;
        if (AMD) {
          define(function() {
            return exports2;
          });
        }
      }
    })();
  }
});
var require_ntlm_payload = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/ntlm-payload.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var crypto3 = _interopRequireWildcard((0, import_chunk_FVJ3R4NJ.__require)("crypto"));
    var _jsMd = _interopRequireDefault(require_md4());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NTLMResponsePayload = class {
      constructor(loginData) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "data");
        this.data = this.createResponse(loginData);
      }
      toString(indent = "") {
        return indent + "NTLM Auth";
      }
      createResponse(challenge) {
        const client_nonce = this.createClientNonce();
        const lmv2len = 24;
        const ntlmv2len = 16;
        const domain = challenge.domain;
        const username = challenge.userName;
        const password = challenge.password;
        const ntlmData = challenge.ntlmpacket;
        const server_data = ntlmData.target;
        const server_nonce = ntlmData.nonce;
        const bufferLength = 64 + domain.length * 2 + username.length * 2 + lmv2len + ntlmv2len + 8 + 8 + 8 + 4 + server_data.length + 4;
        const data = new _writableTrackingBuffer.default(bufferLength);
        data.position = 0;
        data.writeString("NTLMSSP\0", "utf8");
        data.writeUInt32LE(3);
        const baseIdx = 64;
        const dnIdx = baseIdx;
        const unIdx = dnIdx + domain.length * 2;
        const l2Idx = unIdx + username.length * 2;
        const ntIdx = l2Idx + lmv2len;
        data.writeUInt16LE(lmv2len);
        data.writeUInt16LE(lmv2len);
        data.writeUInt32LE(l2Idx);
        data.writeUInt16LE(ntlmv2len);
        data.writeUInt16LE(ntlmv2len);
        data.writeUInt32LE(ntIdx);
        data.writeUInt16LE(domain.length * 2);
        data.writeUInt16LE(domain.length * 2);
        data.writeUInt32LE(dnIdx);
        data.writeUInt16LE(username.length * 2);
        data.writeUInt16LE(username.length * 2);
        data.writeUInt32LE(unIdx);
        data.writeUInt16LE(0);
        data.writeUInt16LE(0);
        data.writeUInt32LE(baseIdx);
        data.writeUInt16LE(0);
        data.writeUInt16LE(0);
        data.writeUInt32LE(baseIdx);
        data.writeUInt16LE(33281);
        data.writeUInt16LE(8);
        data.writeString(domain, "ucs2");
        data.writeString(username, "ucs2");
        const lmv2Data = this.lmv2Response(domain, username, password, server_nonce, client_nonce);
        data.copyFrom(lmv2Data);
        const genTime = (/* @__PURE__ */ new Date()).getTime();
        const ntlmDataBuffer = this.ntlmv2Response(domain, username, password, server_nonce, server_data, client_nonce, genTime);
        data.copyFrom(ntlmDataBuffer);
        data.writeUInt32LE(257);
        data.writeUInt32LE(0);
        const timestamp = this.createTimestamp(genTime);
        data.copyFrom(timestamp);
        data.copyFrom(client_nonce);
        data.writeUInt32LE(0);
        data.copyFrom(server_data);
        data.writeUInt32LE(0);
        return data.data;
      }
      createClientNonce() {
        const client_nonce = Buffer.alloc(8, 0);
        let nidx = 0;
        while (nidx < 8) {
          client_nonce.writeUInt8(Math.ceil(Math.random() * 255), nidx);
          nidx++;
        }
        return client_nonce;
      }
      ntlmv2Response(domain, user, password, serverNonce, targetInfo, clientNonce, mytime) {
        const timestamp = this.createTimestamp(mytime);
        const hash = this.ntv2Hash(domain, user, password);
        const dataLength = 40 + targetInfo.length;
        const data = Buffer.alloc(dataLength, 0);
        serverNonce.copy(data, 0, 0, 8);
        data.writeUInt32LE(257, 8);
        data.writeUInt32LE(0, 12);
        timestamp.copy(data, 16, 0, 8);
        clientNonce.copy(data, 24, 0, 8);
        data.writeUInt32LE(0, 32);
        targetInfo.copy(data, 36, 0, targetInfo.length);
        data.writeUInt32LE(0, 36 + targetInfo.length);
        return this.hmacMD5(data, hash);
      }
      createTimestamp(time) {
        const tenthsOfAMicrosecond = (BigInt(time) + BigInt(11644473600)) * BigInt(1e7);
        const lo = Number(tenthsOfAMicrosecond & BigInt(4294967295));
        const hi = Number(tenthsOfAMicrosecond >> BigInt(32) & BigInt(4294967295));
        const result = Buffer.alloc(8);
        result.writeUInt32LE(lo, 0);
        result.writeUInt32LE(hi, 4);
        return result;
      }
      lmv2Response(domain, user, password, serverNonce, clientNonce) {
        const hash = this.ntv2Hash(domain, user, password);
        const data = Buffer.alloc(serverNonce.length + clientNonce.length, 0);
        serverNonce.copy(data);
        clientNonce.copy(data, serverNonce.length, 0, clientNonce.length);
        const newhash = this.hmacMD5(data, hash);
        const response = Buffer.alloc(newhash.length + clientNonce.length, 0);
        newhash.copy(response);
        clientNonce.copy(response, newhash.length, 0, clientNonce.length);
        return response;
      }
      ntv2Hash(domain, user, password) {
        const hash = this.ntHash(password);
        const identity = Buffer.from(user.toUpperCase() + domain.toUpperCase(), "ucs2");
        return this.hmacMD5(identity, hash);
      }
      ntHash(text) {
        const unicodeString = Buffer.from(text, "ucs2");
        return Buffer.from(_jsMd.default.arrayBuffer(unicodeString));
      }
      hmacMD5(data, key) {
        return crypto3.createHmac("MD5", key).update(data).digest();
      }
    };
    var _default = NTLMResponsePayload;
    exports.default = _default;
    module2.exports = NTLMResponsePayload;
  }
});
var require_errors = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RequestError = exports.ConnectionError = void 0;
    var ConnectionError = class extends Error {
      constructor(message, code) {
        super(message);
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "code");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "isTransient");
        this.code = code;
      }
    };
    exports.ConnectionError = ConnectionError;
    var RequestError = class extends Error {
      constructor(message, code) {
        super(message);
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "code");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "number");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "state");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "class");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "serverName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "procName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "lineNumber");
        this.code = code;
      }
    };
    exports.RequestError = RequestError;
  }
});
var require_types = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/always-encrypted/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SQLServerStatementColumnEncryptionSetting = exports.SQLServerEncryptionType = exports.DescribeParameterEncryptionResultSet2 = exports.DescribeParameterEncryptionResultSet1 = void 0;
    var SQLServerEncryptionType = /* @__PURE__ */ function(SQLServerEncryptionType2) {
      SQLServerEncryptionType2[SQLServerEncryptionType2["Deterministic"] = 1] = "Deterministic";
      SQLServerEncryptionType2[SQLServerEncryptionType2["Randomized"] = 2] = "Randomized";
      SQLServerEncryptionType2[SQLServerEncryptionType2["PlainText"] = 0] = "PlainText";
      return SQLServerEncryptionType2;
    }({});
    exports.SQLServerEncryptionType = SQLServerEncryptionType;
    var DescribeParameterEncryptionResultSet1 = /* @__PURE__ */ function(DescribeParameterEncryptionResultSet12) {
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyOrdinal"] = 0] = "KeyOrdinal";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["DbId"] = 1] = "DbId";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyId"] = 2] = "KeyId";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyVersion"] = 3] = "KeyVersion";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyMdVersion"] = 4] = "KeyMdVersion";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["EncryptedKey"] = 5] = "EncryptedKey";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["ProviderName"] = 6] = "ProviderName";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyPath"] = 7] = "KeyPath";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyEncryptionAlgorithm"] = 8] = "KeyEncryptionAlgorithm";
      return DescribeParameterEncryptionResultSet12;
    }({});
    exports.DescribeParameterEncryptionResultSet1 = DescribeParameterEncryptionResultSet1;
    var DescribeParameterEncryptionResultSet2 = /* @__PURE__ */ function(DescribeParameterEncryptionResultSet22) {
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ParameterOrdinal"] = 0] = "ParameterOrdinal";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ParameterName"] = 1] = "ParameterName";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncryptionAlgorithm"] = 2] = "ColumnEncryptionAlgorithm";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncrytionType"] = 3] = "ColumnEncrytionType";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncryptionKeyOrdinal"] = 4] = "ColumnEncryptionKeyOrdinal";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["NormalizationRuleVersion"] = 5] = "NormalizationRuleVersion";
      return DescribeParameterEncryptionResultSet22;
    }({});
    exports.DescribeParameterEncryptionResultSet2 = DescribeParameterEncryptionResultSet2;
    var SQLServerStatementColumnEncryptionSetting = /* @__PURE__ */ function(SQLServerStatementColumnEncryptionSetting2) {
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["UseConnectionSetting"] = 0] = "UseConnectionSetting";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["Enabled"] = 1] = "Enabled";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["ResultSetOnly"] = 2] = "ResultSetOnly";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["Disabled"] = 3] = "Disabled";
      return SQLServerStatementColumnEncryptionSetting2;
    }({});
    exports.SQLServerStatementColumnEncryptionSetting = SQLServerStatementColumnEncryptionSetting;
  }
});
var require_request2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/request.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _events = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var _errors = require_errors();
    var _types = require_types();
    var Request = class extends _events.EventEmitter {
      /**
       * @param sqlTextOrProcedure
       *   The SQL statement to be executed
       *
       * @param callback
       *   The callback to execute once the request has been fully completed.
       */
      constructor(sqlTextOrProcedure, callback, options) {
        super();
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "sqlTextOrProcedure");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "parameters");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "parametersByName");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "preparing");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "canceled");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "paused");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "userCallback");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "handle");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "error");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "connection");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "timeout");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "rows");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "rst");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "rowCount");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "callback");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "shouldHonorAE");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "statementColumnEncryptionSetting");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "cryptoMetadataLoaded");
        this.sqlTextOrProcedure = sqlTextOrProcedure;
        this.parameters = [];
        this.parametersByName = {};
        this.preparing = false;
        this.handle = void 0;
        this.canceled = false;
        this.paused = false;
        this.error = void 0;
        this.connection = void 0;
        this.timeout = void 0;
        this.userCallback = callback;
        this.statementColumnEncryptionSetting = options && options.statementColumnEncryptionSetting || _types.SQLServerStatementColumnEncryptionSetting.UseConnectionSetting;
        this.cryptoMetadataLoaded = false;
        this.callback = function(err, rowCount, rows) {
          if (this.preparing) {
            this.preparing = false;
            if (err) {
              this.emit("error", err);
            } else {
              this.emit("prepared");
            }
          } else {
            this.userCallback(err, rowCount, rows);
            this.emit("requestCompleted");
          }
        };
      }
      /**
       * This event, describing result set columns, will be emitted before row
       * events are emitted. This event may be emited multiple times when more
       * than one recordset is produced by the statement.
       *
       * An array like object, where the columns can be accessed either by index
       * or name. Columns with a name that is an integer are not accessible by name,
       * as it would be interpreted as an array index.
       */
      /**
       * The request has been prepared and can be used in subsequent calls to execute and unprepare.
       */
      /**
       * The request encountered an error and has not been prepared.
       */
      /**
       * A row resulting from execution of the SQL statement.
       */
      /**
       * All rows from a result set have been provided (through `row` events).
       *
       * This token is used to indicate the completion of a SQL statement.
       * As multiple SQL statements can be sent to the server in a single SQL batch, multiple `done` can be generated.
       * An `done` event is emited for each SQL statement in the SQL batch except variable declarations.
       * For execution of SQL statements within stored procedures, `doneProc` and `doneInProc` events are used in place of `done`.
       *
       * If you are using [[Connection.execSql]] then SQL server may treat the multiple calls with the same query as a stored procedure.
       * When this occurs, the `doneProc` and `doneInProc` events may be emitted instead. You must handle both events to ensure complete coverage.
       */
      /**
       * `request.on('doneInProc', function (rowCount, more, rows) { });`
       *
       * Indicates the completion status of a SQL statement within a stored procedure. All rows from a statement
       * in a stored procedure have been provided (through `row` events).
       *
       * This event may also occur when executing multiple calls with the same query using [[execSql]].
       */
      /**
       * Indicates the completion status of a stored procedure. This is also generated for stored procedures
       * executed through SQL statements.\
       * This event may also occur when executing multiple calls with the same query using [[execSql]].
       */
      /**
       * A value for an output parameter (that was added to the request with [[addOutputParameter]]).
       * See also `Using Parameters`.
       */
      /**
       * This event gives the columns by which data is ordered, if `ORDER BY` clause is executed in SQL Server.
       */
      on(event, listener) {
        return super.on(event, listener);
      }
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      emit(event, ...args) {
        return super.emit(event, ...args);
      }
      /**
       * @param name
       *   The parameter name. This should correspond to a parameter in the SQL,
       *   or a parameter that a called procedure expects. The name should not start with `@`.
       *
       * @param type
       *   One of the supported data types.
       *
       * @param value
       *   The value that the parameter is to be given. The Javascript type of the
       *   argument should match that documented for data types.
       *
       * @param options
       *   Additional type options. Optional.
       */
      // TODO: `type` must be a valid TDS value type
      addParameter(name3, type2, value, options) {
        const {
          output = false,
          length,
          precision,
          scale
        } = options ?? {};
        const parameter = {
          type: type2,
          name: name3,
          value,
          output,
          length,
          precision,
          scale
        };
        this.parameters.push(parameter);
        this.parametersByName[name3] = parameter;
      }
      /**
       * @param name
       *   The parameter name. This should correspond to a parameter in the SQL,
       *   or a parameter that a called procedure expects.
       *
       * @param type
       *   One of the supported data types.
       *
       * @param value
       *   The value that the parameter is to be given. The Javascript type of the
       *   argument should match that documented for data types
       *
       * @param options
       *   Additional type options. Optional.
       */
      addOutputParameter(name3, type2, value, options) {
        this.addParameter(name3, type2, value, {
          ...options,
          output: true
        });
      }
      /**
       * @private
       */
      makeParamsParameter(parameters) {
        let paramsParameter = "";
        for (let i = 0, len = parameters.length; i < len; i++) {
          const parameter = parameters[i];
          if (paramsParameter.length > 0) {
            paramsParameter += ", ";
          }
          paramsParameter += "@" + parameter.name + " ";
          paramsParameter += parameter.type.declaration(parameter);
          if (parameter.output) {
            paramsParameter += " OUTPUT";
          }
        }
        return paramsParameter;
      }
      /**
       * @private
       */
      validateParameters(collation) {
        for (let i = 0, len = this.parameters.length; i < len; i++) {
          const parameter = this.parameters[i];
          try {
            parameter.value = parameter.type.validate(parameter.value, collation);
          } catch (error) {
            throw new _errors.RequestError("Validation failed for parameter '" + parameter.name + "'. " + error.message, "EPARAM");
          }
        }
      }
      /**
       * Temporarily suspends the flow of data from the database. No more `row` events will be emitted until [[resume] is called.
       * If this request is already in a paused state, calling [[pause]] has no effect.
       */
      pause() {
        if (this.paused) {
          return;
        }
        this.emit("pause");
        this.paused = true;
      }
      /**
       * Resumes the flow of data from the database.
       * If this request is not in a paused state, calling [[resume]] has no effect.
       */
      resume() {
        if (!this.paused) {
          return;
        }
        this.paused = false;
        this.emit("resume");
      }
      /**
       * Cancels a request while waiting for a server response.
       */
      cancel() {
        if (this.canceled) {
          return;
        }
        this.canceled = true;
        this.emit("cancel");
      }
      /**
       * Sets a timeout for this request.
       *
       * @param timeout
       *   The number of milliseconds before the request is considered failed,
       *   or `0` for no timeout. When no timeout is set for the request,
       *   the [[ConnectionOptions.requestTimeout]] of the [[Connection]] is used.
       */
      setTimeout(timeout) {
        this.timeout = timeout;
      }
    };
    var _default = Request;
    exports.default = _default;
    module2.exports = Request;
  }
});
var require_all_headers = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/all-headers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.writeToTrackingBuffer = writeToTrackingBuffer;
    var TYPE = {
      QUERY_NOTIFICATIONS: 1,
      TXN_DESCRIPTOR: 2,
      TRACE_ACTIVITY: 3
    };
    var TXNDESCRIPTOR_HEADER_DATA_LEN = 4 + 8;
    var TXNDESCRIPTOR_HEADER_LEN = 4 + 2 + TXNDESCRIPTOR_HEADER_DATA_LEN;
    function writeToTrackingBuffer(buffer, txnDescriptor, outstandingRequestCount) {
      buffer.writeUInt32LE(0);
      buffer.writeUInt32LE(TXNDESCRIPTOR_HEADER_LEN);
      buffer.writeUInt16LE(TYPE.TXN_DESCRIPTOR);
      buffer.writeBuffer(txnDescriptor);
      buffer.writeUInt32LE(outstandingRequestCount);
      const data = buffer.data;
      data.writeUInt32LE(data.length, 0);
      return buffer;
    }
  }
});
var require_rpcrequest_payload = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/rpcrequest-payload.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var STATUS = {
      BY_REF_VALUE: 1,
      DEFAULT_VALUE: 2
    };
    var RpcRequestPayload = class {
      constructor(procedure, parameters, txnDescriptor, options, collation) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "procedure");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "parameters");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "options");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "txnDescriptor");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "collation");
        this.procedure = procedure;
        this.parameters = parameters;
        this.options = options;
        this.txnDescriptor = txnDescriptor;
        this.collation = collation;
      }
      [Symbol.iterator]() {
        return this.generateData();
      }
      *generateData() {
        const buffer = new _writableTrackingBuffer.default(500);
        if (this.options.tdsVersion >= "7_2") {
          const outstandingRequestCount = 1;
          (0, _allHeaders.writeToTrackingBuffer)(buffer, this.txnDescriptor, outstandingRequestCount);
        }
        if (typeof this.procedure === "string") {
          buffer.writeUsVarchar(this.procedure);
        } else {
          buffer.writeUShort(65535);
          buffer.writeUShort(this.procedure);
        }
        const optionFlags = 0;
        buffer.writeUInt16LE(optionFlags);
        yield buffer.data;
        const parametersLength = this.parameters.length;
        for (let i = 0; i < parametersLength; i++) {
          yield* this.generateParameterData(this.parameters[i]);
        }
      }
      toString(indent = "") {
        return indent + ("RPC Request - " + this.procedure);
      }
      *generateParameterData(parameter) {
        const buffer = new _writableTrackingBuffer.default(1 + 2 + Buffer.byteLength(parameter.name, "ucs-2") + 1);
        if (parameter.name) {
          buffer.writeBVarchar("@" + parameter.name);
        } else {
          buffer.writeBVarchar("");
        }
        let statusFlags = 0;
        if (parameter.output) {
          statusFlags |= STATUS.BY_REF_VALUE;
        }
        buffer.writeUInt8(statusFlags);
        yield buffer.data;
        const param = {
          value: parameter.value
        };
        const type2 = parameter.type;
        if ((type2.id & 48) === 32) {
          if (parameter.length) {
            param.length = parameter.length;
          } else if (type2.resolveLength) {
            param.length = type2.resolveLength(parameter);
          }
        }
        if (parameter.precision) {
          param.precision = parameter.precision;
        } else if (type2.resolvePrecision) {
          param.precision = type2.resolvePrecision(parameter);
        }
        if (parameter.scale) {
          param.scale = parameter.scale;
        } else if (type2.resolveScale) {
          param.scale = type2.resolveScale(parameter);
        }
        if (this.collation) {
          param.collation = this.collation;
        }
        yield type2.generateTypeInfo(param, this.options);
        yield type2.generateParameterLength(param, this.options);
        yield* type2.generateParameterData(param, this.options);
      }
    };
    var _default = RpcRequestPayload;
    exports.default = _default;
    module2.exports = RpcRequestPayload;
  }
});
var require_sqlbatch_payload = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/sqlbatch-payload.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SqlBatchPayload = class {
      constructor(sqlText, txnDescriptor, options) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "sqlText");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "txnDescriptor");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "options");
        this.sqlText = sqlText;
        this.txnDescriptor = txnDescriptor;
        this.options = options;
      }
      *[Symbol.iterator]() {
        if (this.options.tdsVersion >= "7_2") {
          const buffer = new _writableTrackingBuffer.default(18, "ucs2");
          const outstandingRequestCount = 1;
          (0, _allHeaders.writeToTrackingBuffer)(buffer, this.txnDescriptor, outstandingRequestCount);
          yield buffer.data;
        }
        yield Buffer.from(this.sqlText, "ucs2");
      }
      toString(indent = "") {
        return indent + ("SQL Batch - " + this.sqlText);
      }
    };
    var _default = SqlBatchPayload;
    exports.default = _default;
    module2.exports = SqlBatchPayload;
  }
});
var require_native_duplexpair = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/native-duplexpair@1.0.0/node_modules/native-duplexpair/index.js"(exports, module2) {
    "use strict";
    var Duplex = (0, import_chunk_FVJ3R4NJ.__require)("stream").Duplex;
    var kCallback = Symbol("Callback");
    var kOtherSide = Symbol("Other");
    var DuplexSocket = class extends Duplex {
      constructor(options) {
        super(options);
        this[kCallback] = null;
        this[kOtherSide] = null;
      }
      _read() {
        const callback = this[kCallback];
        if (callback) {
          this[kCallback] = null;
          callback();
        }
      }
      _write(chunk, encoding, callback) {
        this[kOtherSide][kCallback] = callback;
        this[kOtherSide].push(chunk);
      }
      _final(callback) {
        this[kOtherSide].on("end", callback);
        this[kOtherSide].push(null);
      }
    };
    var DuplexPair = class {
      constructor(options) {
        this.socket1 = new DuplexSocket(options);
        this.socket2 = new DuplexSocket(options);
        this.socket1[kOtherSide] = this.socket2;
        this.socket2[kOtherSide] = this.socket1;
      }
    };
    module2.exports = DuplexPair;
  }
});
var require_message = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/message.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _stream = (0, import_chunk_FVJ3R4NJ.__require)("stream");
    var Message = class extends _stream.PassThrough {
      constructor({
        type: type2,
        resetConnection = false
      }) {
        super();
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "type");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "resetConnection");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "ignore");
        this.type = type2;
        this.resetConnection = resetConnection;
        this.ignore = false;
      }
    };
    var _default = Message;
    exports.default = _default;
    module2.exports = Message;
  }
});
var require_primordials = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/ours/primordials.js"(exports, module2) {
    "use strict";
    module2.exports = {
      ArrayIsArray(self) {
        return Array.isArray(self);
      },
      ArrayPrototypeIncludes(self, el) {
        return self.includes(el);
      },
      ArrayPrototypeIndexOf(self, el) {
        return self.indexOf(el);
      },
      ArrayPrototypeJoin(self, sep) {
        return self.join(sep);
      },
      ArrayPrototypeMap(self, fn) {
        return self.map(fn);
      },
      ArrayPrototypePop(self, el) {
        return self.pop(el);
      },
      ArrayPrototypePush(self, el) {
        return self.push(el);
      },
      ArrayPrototypeSlice(self, start, end) {
        return self.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self, instance) {
        return Function.prototype[Symbol.hasInstance].call(self, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self, props) {
        return Object.defineProperties(self, props);
      },
      ObjectDefineProperty(self, name3, prop) {
        return Object.defineProperty(self, name3, prop);
      },
      ObjectGetOwnPropertyDescriptor(self, name3) {
        return Object.getOwnPropertyDescriptor(self, name3);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self, fn) {
        return self.catch(fn);
      },
      PromisePrototypeThen(self, thenFn, catchFn) {
        return self.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self, value) {
        return self.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self, start, end) {
        return self.slice(start, end);
      },
      StringPrototypeToLowerCase(self) {
        return self.toLowerCase();
      },
      StringPrototypeToUpperCase(self) {
        return self.toUpperCase();
      },
      StringPrototypeTrim(self) {
        return self.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      TypedArrayPrototypeSet(self, buf, len) {
        return self.set(buf, len);
      },
      Uint8Array
    };
  }
});
var require_util = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/ours/util.js"(exports, module2) {
    "use strict";
    var bufferModule = (0, import_chunk_FVJ3R4NJ.__require)("buffer");
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AggregateError2 = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module2.exports = {
      AggregateError: AggregateError2,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type2]) {
          const replacement = args.shift();
          if (type2 === "f") {
            return replacement.toFixed(6);
          } else if (type2 === "j") {
            return JSON.stringify(replacement);
          } else if (type2 === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob
    };
    module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});
var require_event_target_shim = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap2 = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject2(x) {
      return x !== null && typeof x === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap2.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject2(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap2.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
          types[i] = arguments[i];
        }
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject2(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject2(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject2(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports.defineEventAttribute = defineEventAttribute;
    exports.EventTarget = EventTarget;
    exports.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});
var require_abort_controller = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal2 = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal2.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal2.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal2(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal2.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController2 = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal2(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports.AbortController = AbortController2;
    exports.AbortSignal = AbortSignal2;
    exports.default = AbortController2;
    module2.exports = AbortController2;
    module2.exports.AbortController = module2.exports["default"] = AbortController2;
    module2.exports.AbortSignal = AbortSignal2;
  }
});
var require_errors2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/ours/errors.js"(exports, module2) {
    "use strict";
    var { format, inspect: inspect2, AggregateError: CustomAggregateError } = require_util();
    var AggregateError2 = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert2(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert2(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert2(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError2([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError2 = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name3, expected, actual) => {
        assert2(typeof name3 === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name3.endsWith(" argument")) {
          msg += `${name3} `;
        } else {
          msg += `"${name3}" ${name3.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert2(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert2(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(types, pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              const last = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect2(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect2(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name3, value, reason = "is invalid") => {
        let inspected = inspect2(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type2 = name3.includes(".") ? "property" : "argument";
        return `The ${type2} '${name3}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name3, value) => {
        var _value$constructor;
        const type2 = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name3}" function but got ${type2}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert2(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert2(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > 2n ** 32n || input < -(2n ** 32n)) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect2(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module2.exports = {
      AbortError: AbortError2,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});
var require_validators = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/validators.js"(exports, module2) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors2();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name3, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name3, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name3);
      return value;
    }
    var validateInteger = hideStackFrames((value, name3, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name3, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE(name3, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE(name3, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name3, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name3, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name3, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name3, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name3, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name3, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name3, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name3, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name3) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE(name3, "string", value);
    }
    function validateNumber(value, name3, min = void 0, max) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name3, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name3,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name3, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name3, value, reason);
      }
    });
    function validateBoolean(value, name3) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE(name3, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name3, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name3, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name3) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name3, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name3, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name3, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name3, value, reason);
      }
    });
    function validateStringArray(value, name3) {
      validateArray(value, name3);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name3}[${i}]`);
      }
    }
    function validateBooleanArray(value, name3) {
      validateArray(value, name3);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name3}[${i}]`);
      }
    }
    function validateSignalName(signal, name3 = "signal") {
      validateString(signal, name3);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name3 = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name3, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name3 = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name3, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name3) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name3, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name3) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE(name3, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name3) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE(name3, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name3) => {
      if (value !== void 0)
        throw new ERR_INVALID_ARG_TYPE(name3, "undefined", value);
    });
    function validateUnion(value, name3, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE(name3, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name3) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name3,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module2.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});
var require_process = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/process@0.11.10/node_modules/process/index.js"(exports, module2) {
    "use strict";
    module2.exports = global.process;
  }
});
var require_utils3 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module2) {
    "use strict";
    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kDestroyed = Symbol2("kDestroyed");
    var kIsErrored = Symbol2("kIsErrored");
    var kIsReadable = Symbol2("kIsReadable");
    var kIsDisturbed = Symbol2("kIsDisturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream2(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream2(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      const rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module2.exports = {
      kDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      isClosed,
      isDestroyed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream: isReadableStream2,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});
var require_end_of_stream = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module2) {
    "use strict";
    var process2 = require_process();
    var { AbortError: AbortError2, codes } = require_errors2();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream: isReadableStream2,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils3();
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream2(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process2.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process2.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process2.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError2(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          const originalCallback = callback;
          callback = once((...args) => {
            options.signal.removeEventListener("abort", abort);
            originalCallback.apply(stream, args);
          });
          options.signal.addEventListener("abort", abort);
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError2(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          const originalCallback = callback;
          callback = once((...args) => {
            options.signal.removeEventListener("abort", abort);
            originalCallback.apply(stream, args);
          });
          options.signal.addEventListener("abort", abort);
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process2.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module2.exports = eos;
    module2.exports.finished = finished;
  }
});
var require_destroy = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    var process2 = require_process();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError: AbortError2
    } = require_errors2();
    var { Symbol: Symbol2 } = require_primordials();
    var { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils3();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy2(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self._readableState;
        const w = self._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process2.nextTick(emitErrorCloseNT, self, err2);
        } else {
          process2.nextTick(emitCloseNT, self);
        }
      }
      try {
        self._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self, err) {
      emitErrorNT(self, err);
      emitCloseNT(self);
    }
    function emitCloseNT(self) {
      const r = self._readableState;
      const w = self._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self.emit("close");
      }
    }
    function emitErrorNT(self, err) {
      const r = self._readableState;
      const w = self._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process2.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process2.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError2();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process2.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kDestroyed] = true;
      }
    }
    module2.exports = {
      construct,
      destroyer,
      destroy: destroy2,
      undestroy,
      errorOrDestroy
    };
  }
});
var require_legacy = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module2) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = (0, import_chunk_FVJ3R4NJ.__require)("events");
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module2.exports = {
      Stream,
      prependListener
    };
  }
});
var require_add_abort_signal = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module2) {
    "use strict";
    var { AbortError: AbortError2, codes } = require_errors2();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils3();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var validateAbortSignal = (signal, name3) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name3, "AbortSignal", signal);
      }
    };
    module2.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module2.exports.addAbortSignalNoValidate(signal, stream);
    };
    module2.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError2(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError2(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, () => signal.removeEventListener("abort", onAbort));
      }
      return stream;
    };
  }
});
var require_buffer_list = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module2) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer2 } = (0, import_chunk_FVJ3R4NJ.__require)("buffer");
    var { inspect: inspect2 } = require_util();
    module2.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0)
          return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null)
          ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer2.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_2, options) {
        return inspect2(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});
var require_state2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module2) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { ERR_INVALID_ARG_VALUE } = require_errors2().codes;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? 16 : 16 * 1024;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name3 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name3, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module2.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark
    };
  }
});
var require_from = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/from.js"(exports, module2) {
    "use strict";
    var process2 = require_process();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer2 } = (0, import_chunk_FVJ3R4NJ.__require)("buffer");
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors2().codes;
    function from(Readable, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer2) {
        return new Readable({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process2.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process2.nextTick(cb, e || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module2.exports = from;
  }
});
var require_readable = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module2) {
    "use strict";
    var process2 = require_process();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module2.exports = Readable;
    Readable.ReadableState = ReadableState;
    var { EventEmitter: EE } = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer2 } = (0, import_chunk_FVJ3R4NJ.__require)("buffer");
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state2();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      }
    } = require_errors2();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = (0, import_chunk_FVJ3R4NJ.__require)("string_decoder");
    var from = require_from();
    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.constructed = true;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this[kPaused] = null;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.destroyed = false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.multiAwaitDrain = false;
      this.readingMore = false;
      this.dataEmitted = false;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "")
        buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length)
        return n;
      return state.ended ? state.length : 0;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process2.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process2.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process2.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        if (state.flowing) {
          pause();
        }
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0)
        this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process2.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.off = Readable.prototype.removeListener;
    Readable.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self) {
      const state = self._readableState;
      state.readableListening = self.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self.listenerCount("data") > 0) {
        self.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self) {
      debug("readable nexttick read 0");
      self.read(0);
    }
    Readable.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process2.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process2.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process2.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable.from = function(iterable, opts) {
      return from(Readable, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});
var require_writable = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module2) {
    "use strict";
    var process2 = require_process();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module2.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer2 } = (0, import_chunk_FVJ3R4NJ.__require)("buffer");
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state2();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors2().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process2.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process2.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process2.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process2.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process2.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState)
            return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy2 = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process2.nextTick(errorBuffer, state);
      }
      destroy2.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});
var require_duplexify = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module2) {
    "use strict";
    var process2 = require_process();
    var bufferModule = (0, import_chunk_FVJ3R4NJ.__require)("buffer");
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream
    } = require_utils3();
    var eos = require_end_of_stream();
    var {
      AbortError: AbortError2,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors2();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable = require_readable();
    var { createDeferredPromise } = require_util();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module2.exports = function duplexify(body, name3) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy: destroy2 } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy: destroy2
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process2.nextTick(cb, null);
                } catch (err) {
                  process2.nextTick(cb, err);
                }
              });
            },
            destroy: destroy2
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name3, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name3,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController2();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process2.nextTick(cb);
            if (done)
              return;
            if (signal.aborted)
              throw new AbortError2(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError2();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});
var require_duplex = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module2) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module2.exports = Duplex;
    var Readable = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
    ObjectSetPrototypeOf(Duplex, Readable);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});
var require_transform = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module2) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module2.exports = Transform2;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors2().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state2();
    ObjectSetPrototypeOf(Transform2.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform2, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform2.prototype._final = final;
    Transform2.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform2.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform2.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});
var require_passthrough = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module2) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module2.exports = PassThrough;
    var Transform2 = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform2.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform2);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform2.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});
var require_pipeline = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module2) {
    "use strict";
    var process2 = require_process();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError: AbortError2
    } = require_errors2();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream: isReadableStream2,
      isReadableEnded
    } = require_utils3();
    var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
    var PassThrough;
    var Readable;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished)
            return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable) {
        Readable = require_readable();
      }
      yield* Readable.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
        }
        await wait();
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError2());
      }
      outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.addEventListener("abort", abort);
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.removeEventListener("abort", abort);
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy: destroy2, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy2);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process2.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process2.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream2(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy: destroy2, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy2);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream2(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream2(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process2.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableEnded(src)) {
          process2.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module2.exports = {
      pipelineImpl,
      pipeline
    };
  }
});
var require_compose = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module2) {
    "use strict";
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream: isReadableStream2
    } = require_utils3();
    var {
      AbortError: AbortError2,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors2();
    var eos = require_end_of_stream();
    module2.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream2(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream2(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError2();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});
var require_operators = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module2) {
    "use strict";
    var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError: AbortError2
    } = require_errors2();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils3();
    var {
      ArrayPrototypePush,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      validateInteger(concurrency, "concurrency", 1);
      return async function* map2() {
        var _options$signal, _options$signal2;
        const ac = new AbortController2();
        const stream = this;
        const queue = [];
        const signal = ac.signal;
        const signalOpt = {
          signal
        };
        const abort = () => ac.abort();
        if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
          abort();
        }
        options === null || options === void 0 ? void 0 : (_options$signal2 = options.signal) === null || _options$signal2 === void 0 ? void 0 : _options$signal2.addEventListener("abort", abort);
        let next;
        let resume;
        let done = false;
        function onDone() {
          done = true;
        }
        async function pump() {
          try {
            for await (let val of stream) {
              var _val;
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError2();
              }
              try {
                val = fn(val, signalOpt);
              } catch (err) {
                val = PromiseReject(err);
              }
              if (val === kEmpty) {
                continue;
              }
              if (typeof ((_val = val) === null || _val === void 0 ? void 0 : _val.catch) === "function") {
                val.catch(onDone);
              }
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && queue.length && queue.length >= concurrency) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, void 0, onDone);
            queue.push(val);
          } finally {
            var _options$signal3;
            done = true;
            if (next) {
              next();
              next = null;
            }
            options === null || options === void 0 ? void 0 : (_options$signal3 = options.signal) === null || _options$signal3 === void 0 ? void 0 : _options$signal3.removeEventListener("abort", abort);
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError2();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              if (resume) {
                resume();
                resume = null;
              }
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          ac.abort();
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal4;
          if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
            throw new AbortError2({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options))
        ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal5;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
        const err = new AbortError2(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal6;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError2();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError2(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* drop2() {
        var _options$signal8;
        if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
          throw new AbortError2();
        }
        for await (const val of this) {
          var _options$signal9;
          if (options !== null && options !== void 0 && (_options$signal9 = options.signal) !== null && _options$signal9 !== void 0 && _options$signal9.aborted) {
            throw new AbortError2();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* take2() {
        var _options$signal10;
        if (options !== null && options !== void 0 && (_options$signal10 = options.signal) !== null && _options$signal10 !== void 0 && _options$signal10.aborted) {
          throw new AbortError2();
        }
        for await (const val of this) {
          var _options$signal11;
          if (options !== null && options !== void 0 && (_options$signal11 = options.signal) !== null && _options$signal11 !== void 0 && _options$signal11.aborted) {
            throw new AbortError2();
          }
          if (number-- > 0) {
            yield val;
          } else {
            return;
          }
        }
      }.call(this);
    }
    module2.exports.streamReturningOperators = {
      asIndexedPairs,
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module2.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});
var require_promises = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/stream/promises.js"(exports, module2) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils3();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module2.exports = {
      finished,
      pipeline
    };
  }
});
var require_stream = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/stream.js"(exports, module2) {
    "use strict";
    var { Buffer: Buffer2 } = (0, import_chunk_FVJ3R4NJ.__require)("buffer");
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors2();
    var compose = require_compose();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils3();
    var Stream = module2.exports = require_legacy().Stream;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      fn = fn2;
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      fn = fn2;
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});
var require_ours = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/readable-stream@4.4.2/node_modules/readable-stream/lib/ours/index.js"(exports, module2) {
    "use strict";
    var Stream = (0, import_chunk_FVJ3R4NJ.__require)("stream");
    if (Stream && process.env.READABLE_STREAM === "disable") {
      const promises = Stream.promises;
      module2.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = Stream._isUint8Array;
      module2.exports.isDisturbed = Stream.isDisturbed;
      module2.exports.isErrored = Stream.isErrored;
      module2.exports.isReadable = Stream.isReadable;
      module2.exports.Readable = Stream.Readable;
      module2.exports.Writable = Stream.Writable;
      module2.exports.Duplex = Stream.Duplex;
      module2.exports.Transform = Stream.Transform;
      module2.exports.PassThrough = Stream.PassThrough;
      module2.exports.addAbortSignal = Stream.addAbortSignal;
      module2.exports.finished = Stream.finished;
      module2.exports.destroy = Stream.destroy;
      module2.exports.pipeline = Stream.pipeline;
      module2.exports.compose = Stream.compose;
      Object.defineProperty(Stream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = Stream.Stream;
    } else {
      const CustomStream = require_stream();
      const promises = require_promises();
      const originalDestroy = CustomStream.Readable.destroy;
      module2.exports = CustomStream.Readable;
      module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = CustomStream._isUint8Array;
      module2.exports.isDisturbed = CustomStream.isDisturbed;
      module2.exports.isErrored = CustomStream.isErrored;
      module2.exports.isReadable = CustomStream.isReadable;
      module2.exports.Readable = CustomStream.Readable;
      module2.exports.Writable = CustomStream.Writable;
      module2.exports.Duplex = CustomStream.Duplex;
      module2.exports.Transform = CustomStream.Transform;
      module2.exports.PassThrough = CustomStream.PassThrough;
      module2.exports.addAbortSignal = CustomStream.addAbortSignal;
      module2.exports.finished = CustomStream.finished;
      module2.exports.destroy = CustomStream.destroy;
      module2.exports.destroy = originalDestroy;
      module2.exports.pipeline = CustomStream.pipeline;
      module2.exports.compose = CustomStream.compose;
      Object.defineProperty(CustomStream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = CustomStream.Stream;
    }
    module2.exports.default = module2.exports;
  }
});
var require_BufferList = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/bl@6.0.7/node_modules/bl/BufferList.js"(exports, module2) {
    "use strict";
    var { Buffer: Buffer2 } = (0, import_chunk_FVJ3R4NJ.__require)("buffer");
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init2(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readBigInt64BE: 8,
        readBigInt64LE: 8,
        readBigUInt64BE: 8,
        readBigUInt64LE: 8,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList;
  }
});
var require_bl = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/bl@6.0.7/node_modules/bl/bl.js"(exports, module2) {
    "use strict";
    var DuplexStream = require_ours().Duplex;
    var inherits = (0, import_chunk_QEHB4OUG.require_inherits)();
    var BufferList = require_BufferList();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = function _new(callback) {
      return new BufferListStream(callback);
    };
    BufferListStream.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
    };
    BufferListStream.isBufferList = BufferList.isBufferList;
    module2.exports = BufferListStream;
    module2.exports.BufferListStream = BufferListStream;
    module2.exports.BufferList = BufferList;
  }
});
var require_incoming_message_stream = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/incoming-message-stream.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _bl = _interopRequireDefault(require_bl());
    var _stream = (0, import_chunk_FVJ3R4NJ.__require)("stream");
    var _message = _interopRequireDefault(require_message());
    var _packet = require_packet();
    var _errors = require_errors();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IncomingMessageStream = class extends _stream.Transform {
      constructor(debug) {
        super({
          readableObjectMode: true
        });
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "debug");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "bl");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "currentMessage");
        this.debug = debug;
        this.currentMessage = void 0;
        this.bl = new _bl.default();
      }
      pause() {
        super.pause();
        if (this.currentMessage) {
          this.currentMessage.pause();
        }
        return this;
      }
      resume() {
        super.resume();
        if (this.currentMessage) {
          this.currentMessage.resume();
        }
        return this;
      }
      processBufferedData(callback) {
        while (this.bl.length >= _packet.HEADER_LENGTH) {
          const length = this.bl.readUInt16BE(2);
          if (length < _packet.HEADER_LENGTH) {
            return callback(new _errors.ConnectionError("Unable to process incoming packet"));
          }
          if (this.bl.length >= length) {
            const data = this.bl.slice(0, length);
            this.bl.consume(length);
            const packet = new _packet.Packet(data);
            this.debug.packet("Received", packet);
            this.debug.data(packet);
            let message = this.currentMessage;
            if (message === void 0) {
              this.currentMessage = message = new _message.default({
                type: packet.type(),
                resetConnection: false
              });
              this.push(message);
            }
            if (packet.isLast()) {
              message.once("end", () => {
                this.currentMessage = void 0;
                this.processBufferedData(callback);
              });
              message.end(packet.data());
              return;
            } else if (!message.write(packet.data())) {
              message.once("drain", () => {
                this.processBufferedData(callback);
              });
              return;
            }
          } else {
            break;
          }
        }
        callback();
      }
      _transform(chunk, _encoding, callback) {
        this.bl.append(chunk);
        this.processBufferedData(callback);
      }
    };
    var _default = IncomingMessageStream;
    exports.default = _default;
    module2.exports = IncomingMessageStream;
  }
});
var require_outgoing_message_stream = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/outgoing-message-stream.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _bl = _interopRequireDefault(require_bl());
    var _stream = (0, import_chunk_FVJ3R4NJ.__require)("stream");
    var _packet = require_packet();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var OutgoingMessageStream = class extends _stream.Duplex {
      constructor(debug, {
        packetSize
      }) {
        super({
          writableObjectMode: true
        });
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "packetSize");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "debug");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "bl");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "currentMessage");
        this.packetSize = packetSize;
        this.debug = debug;
        this.bl = new _bl.default();
        this.on("finish", () => {
          this.push(null);
        });
      }
      _write(message, _encoding, callback) {
        const length = this.packetSize - _packet.HEADER_LENGTH;
        let packetNumber = 0;
        this.currentMessage = message;
        this.currentMessage.on("data", (data) => {
          if (message.ignore) {
            return;
          }
          this.bl.append(data);
          while (this.bl.length > length) {
            const data2 = this.bl.slice(0, length);
            this.bl.consume(length);
            const packet = new _packet.Packet(message.type);
            packet.packetId(packetNumber += 1);
            packet.resetConnection(message.resetConnection);
            packet.addData(data2);
            this.debug.packet("Sent", packet);
            this.debug.data(packet);
            if (this.push(packet.buffer) === false) {
              message.pause();
            }
          }
        });
        this.currentMessage.on("end", () => {
          const data = this.bl.slice();
          this.bl.consume(data.length);
          const packet = new _packet.Packet(message.type);
          packet.packetId(packetNumber += 1);
          packet.resetConnection(message.resetConnection);
          packet.last(true);
          packet.ignore(message.ignore);
          packet.addData(data);
          this.debug.packet("Sent", packet);
          this.debug.data(packet);
          this.push(packet.buffer);
          this.currentMessage = void 0;
          callback();
        });
      }
      _read(_size) {
        if (this.currentMessage) {
          this.currentMessage.resume();
        }
      }
    };
    var _default = OutgoingMessageStream;
    exports.default = _default;
    module2.exports = OutgoingMessageStream;
  }
});
var require_message_io = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/message-io.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nativeDuplexpair = _interopRequireDefault(require_native_duplexpair());
    var tls = _interopRequireWildcard((0, import_chunk_FVJ3R4NJ.__require)("tls"));
    var _events = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var _message = _interopRequireDefault(require_message());
    var _packet = require_packet();
    var _incomingMessageStream = _interopRequireDefault(require_incoming_message_stream());
    var _outgoingMessageStream = _interopRequireDefault(require_outgoing_message_stream());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MessageIO = class extends _events.EventEmitter {
      constructor(socket, packetSize, debug) {
        super();
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "socket");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "debug");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "tlsNegotiationComplete");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "incomingMessageStream");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "outgoingMessageStream");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "securePair");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "incomingMessageIterator");
        this.socket = socket;
        this.debug = debug;
        this.tlsNegotiationComplete = false;
        this.incomingMessageStream = new _incomingMessageStream.default(this.debug);
        this.incomingMessageIterator = this.incomingMessageStream[Symbol.asyncIterator]();
        this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {
          packetSize
        });
        this.socket.pipe(this.incomingMessageStream);
        this.outgoingMessageStream.pipe(this.socket);
      }
      packetSize(...args) {
        if (args.length > 0) {
          const packetSize = args[0];
          this.debug.log("Packet size changed from " + this.outgoingMessageStream.packetSize + " to " + packetSize);
          this.outgoingMessageStream.packetSize = packetSize;
        }
        if (this.securePair) {
          this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
        }
        return this.outgoingMessageStream.packetSize;
      }
      // Negotiate TLS encryption.
      startTls(credentialsDetails, hostname, trustServerCertificate) {
        if (!credentialsDetails.maxVersion || !["TLSv1.2", "TLSv1.1", "TLSv1"].includes(credentialsDetails.maxVersion)) {
          credentialsDetails.maxVersion = "TLSv1.2";
        }
        const secureContext = tls.createSecureContext(credentialsDetails);
        return new Promise((resolve, reject) => {
          const duplexpair = new _nativeDuplexpair.default();
          const securePair = this.securePair = {
            cleartext: tls.connect({
              socket: duplexpair.socket1,
              servername: hostname,
              secureContext,
              rejectUnauthorized: !trustServerCertificate
            }),
            encrypted: duplexpair.socket2
          };
          const onSecureConnect = () => {
            securePair.encrypted.removeListener("readable", onReadable);
            securePair.cleartext.removeListener("error", onError);
            securePair.cleartext.removeListener("secureConnect", onSecureConnect);
            securePair.cleartext.once("error", (err) => {
              this.socket.destroy(err);
            });
            const cipher = securePair.cleartext.getCipher();
            if (cipher) {
              this.debug.log("TLS negotiated (" + cipher.name + ", " + cipher.version + ")");
            }
            this.emit("secure", securePair.cleartext);
            securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
            this.outgoingMessageStream.unpipe(this.socket);
            this.socket.unpipe(this.incomingMessageStream);
            this.socket.pipe(securePair.encrypted);
            securePair.encrypted.pipe(this.socket);
            securePair.cleartext.pipe(this.incomingMessageStream);
            this.outgoingMessageStream.pipe(securePair.cleartext);
            this.tlsNegotiationComplete = true;
            resolve();
          };
          const onError = (err) => {
            securePair.encrypted.removeListener("readable", onReadable);
            securePair.cleartext.removeListener("error", onError);
            securePair.cleartext.removeListener("secureConnect", onSecureConnect);
            securePair.cleartext.destroy();
            securePair.encrypted.destroy();
            reject(err);
          };
          const onReadable = () => {
            const message = new _message.default({
              type: _packet.TYPE.PRELOGIN,
              resetConnection: false
            });
            let chunk;
            while (chunk = securePair.encrypted.read()) {
              message.write(chunk);
            }
            this.outgoingMessageStream.write(message);
            message.end();
            this.readMessage().then(async (response) => {
              securePair.encrypted.once("readable", onReadable);
              for await (const data of response) {
                securePair.encrypted.write(data);
              }
            }).catch(onError);
          };
          securePair.cleartext.once("error", onError);
          securePair.cleartext.once("secureConnect", onSecureConnect);
          securePair.encrypted.once("readable", onReadable);
        });
      }
      // TODO listen for 'drain' event when socket.write returns false.
      // TODO implement incomplete request cancelation (2.2.1.6)
      sendMessage(packetType, data, resetConnection) {
        const message = new _message.default({
          type: packetType,
          resetConnection
        });
        message.end(data);
        this.outgoingMessageStream.write(message);
        return message;
      }
      /**
       * Read the next incoming message from the socket.
       */
      async readMessage() {
        const result = await this.incomingMessageIterator.next();
        if (result.done) {
          throw new Error("unexpected end of message stream");
        }
        return result.value;
      }
    };
    var _default = MessageIO;
    exports.default = _default;
    module2.exports = MessageIO;
  }
});
var require_collation = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/collation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codepageBySortId = exports.codepageByLanguageId = exports.Flags = exports.Collation = void 0;
    var codepageByLanguageId = {
      // Arabic_*
      [1025]: "CP1256",
      // Chinese_Taiwan_Stroke_*
      // Chinese_Traditional_Stroke_Count_*
      // Chinese_Taiwan_Bopomofo_*
      // Chinese_Traditional_Bopomofo_*
      [1028]: "CP950",
      // Czech_*
      [1029]: "CP1250",
      // Danish_Greenlandic_*
      // Danish_Norwegian_*
      [1030]: "CP1252",
      // Greek_*
      [1032]: "CP1253",
      // Latin1_General_*
      [1033]: "CP1252",
      // Traditional_Spanish_*
      [1034]: "CP1252",
      // Finnish_Swedish_*
      [1035]: "CP1252",
      // French_*
      [1036]: "CP1252",
      // Hebrew_*
      [1037]: "CP1255",
      // Hungarian_*
      // Hungarian_Technical_*
      [1038]: "CP1250",
      // Icelandic_*
      [1039]: "CP1252",
      // Japanese_*
      // Japanese_XJIS_*
      // Japanese_Unicode_*
      // Japanese_Bushu_Kakusu_*
      [1041]: "CP932",
      // Korean_*
      // Korean_Wansung_*
      [1042]: "CP949",
      // Norwegian_*
      [1044]: "CP1252",
      // Polish_*
      [1045]: "CP1250",
      // Romansh_*
      [1047]: "CP1252",
      // Romanian_*
      [1048]: "CP1250",
      // Cyrillic_*
      [1049]: "CP1251",
      // Croatian_*
      [1050]: "CP1250",
      // Slovak_*
      [1051]: "CP1250",
      // Albanian_*
      [1052]: "CP1250",
      // Thai_*
      [1054]: "CP874",
      // Turkish_*
      [1055]: "CP1254",
      // Urdu_*
      [1056]: "CP1256",
      // Ukrainian_*
      [1058]: "CP1251",
      // Slovenian_*
      [1060]: "CP1250",
      // Estonian_*
      [1061]: "CP1257",
      // Latvian_*
      [1062]: "CP1257",
      // Lithuanian_*
      [1063]: "CP1257",
      // Persian_*
      [1065]: "CP1256",
      // Vietnamese_*
      [1066]: "CP1258",
      // Azeri_Latin_*
      [1068]: "CP1254",
      // Upper_Sorbian_*
      [1070]: "CP1252",
      // Macedonian_FYROM_*
      [1071]: "CP1251",
      // Sami_Norway_*
      [1083]: "CP1252",
      // Kazakh_*
      [1087]: "CP1251",
      // Turkmen_*
      [1090]: "CP1250",
      // Uzbek_Latin_*
      [1091]: "CP1254",
      // Tatar_*
      [1092]: "CP1251",
      // Welsh_*
      [1106]: "CP1252",
      // Frisian_*
      [1122]: "CP1252",
      // Bashkir_*
      [1133]: "CP1251",
      // Mapudungan_*
      [1146]: "CP1252",
      // Mohawk_*
      [1148]: "CP1252",
      // Breton_*
      [1150]: "CP1252",
      // Uighur_*
      [1152]: "CP1256",
      // Corsican_*
      [1155]: "CP1252",
      // Yakut_*
      [1157]: "CP1251",
      // Dari_*
      [1164]: "CP1256",
      // Chinese_PRC_*
      // Chinese_Simplified_Pinyin_*
      // Chinese_PRC_Stroke_*
      // Chinese_Simplified_Stroke_Order_*
      [2052]: "CP936",
      // Serbian_Latin_*
      [2074]: "CP1250",
      // Azeri_Cyrillic_*
      [2092]: "CP1251",
      // Sami_Sweden_Finland_*
      [2107]: "CP1252",
      // Tamazight_*
      [2143]: "CP1252",
      // Chinese_Hong_Kong_Stroke_*
      [3076]: "CP950",
      // Modern_Spanish_*
      [3082]: "CP1252",
      // Serbian_Cyrillic_*
      [3098]: "CP1251",
      // Chinese_Traditional_Pinyin_*
      // Chinese_Traditional_Stroke_Order_*
      [5124]: "CP950",
      // Bosnian_Latin_*
      [5146]: "CP1250",
      // Bosnian_Cyrillic_*
      [8218]: "CP1251",
      // German
      // German_PhoneBook_*
      [1031]: "CP1252",
      // Georgian_Modern_Sort_*
      [1079]: "CP1252"
    };
    exports.codepageByLanguageId = codepageByLanguageId;
    var codepageBySortId = {
      [30]: "CP437",
      // SQL_Latin1_General_CP437_BIN
      [31]: "CP437",
      // SQL_Latin1_General_CP437_CS_AS
      [32]: "CP437",
      // SQL_Latin1_General_CP437_CI_AS
      [33]: "CP437",
      // SQL_Latin1_General_Pref_CP437_CI_AS
      [34]: "CP437",
      // SQL_Latin1_General_CP437_CI_AI
      [40]: "CP850",
      // SQL_Latin1_General_CP850_BIN
      [41]: "CP850",
      // SQL_Latin1_General_CP850_CS_AS
      [42]: "CP850",
      // SQL_Latin1_General_CP850_CI_AS
      [43]: "CP850",
      // SQL_Latin1_General_Pref_CP850_CI_AS
      [44]: "CP850",
      // SQL_Latin1_General_CP850_CI_AI
      [49]: "CP850",
      // SQL_1xCompat_CP850_CI_AS
      [51]: "CP1252",
      // SQL_Latin1_General_Cp1_CS_AS_KI_WI
      [52]: "CP1252",
      // SQL_Latin1_General_Cp1_CI_AS_KI_WI
      [53]: "CP1252",
      // SQL_Latin1_General_Pref_Cp1_CI_AS_KI_WI
      [54]: "CP1252",
      // SQL_Latin1_General_Cp1_CI_AI_KI_WI
      [55]: "CP850",
      // SQL_AltDiction_CP850_CS_AS
      [56]: "CP850",
      // SQL_AltDiction_Pref_CP850_CI_AS
      [57]: "CP850",
      // SQL_AltDiction_CP850_CI_AI
      [58]: "CP850",
      // SQL_Scandinavian_Pref_CP850_CI_AS
      [59]: "CP850",
      // SQL_Scandinavian_CP850_CS_AS
      [60]: "CP850",
      // SQL_Scandinavian_CP850_CI_AS
      [61]: "CP850",
      // SQL_AltDiction_CP850_CI_AS
      [80]: "CP1250",
      // SQL_Latin1_General_1250_BIN
      [81]: "CP1250",
      // SQL_Latin1_General_CP1250_CS_AS
      [82]: "CP1250",
      // SQL_Latin1_General_Cp1250_CI_AS_KI_WI
      [83]: "CP1250",
      // SQL_Czech_Cp1250_CS_AS_KI_WI
      [84]: "CP1250",
      // SQL_Czech_Cp1250_CI_AS_KI_WI
      [85]: "CP1250",
      // SQL_Hungarian_Cp1250_CS_AS_KI_WI
      [86]: "CP1250",
      // SQL_Hungarian_Cp1250_CI_AS_KI_WI
      [87]: "CP1250",
      // SQL_Polish_Cp1250_CS_AS_KI_WI
      [88]: "CP1250",
      // SQL_Polish_Cp1250_CI_AS_KI_WI
      [89]: "CP1250",
      // SQL_Romanian_Cp1250_CS_AS_KI_WI
      [90]: "CP1250",
      // SQL_Romanian_Cp1250_CI_AS_KI_WI
      [91]: "CP1250",
      // SQL_Croatian_Cp1250_CS_AS_KI_WI
      [92]: "CP1250",
      // SQL_Croatian_Cp1250_CI_AS_KI_WI
      [93]: "CP1250",
      // SQL_Slovak_Cp1250_CS_AS_KI_WI
      [94]: "CP1250",
      // SQL_Slovak_Cp1250_CI_AS_KI_WI
      [95]: "CP1250",
      // SQL_Slovenian_Cp1250_CS_AS_KI_WI
      [96]: "CP1250",
      // SQL_Slovenian_Cp1250_CI_AS_KI_WI
      [104]: "CP1251",
      // SQL_Latin1_General_1251_BIN
      [105]: "CP1251",
      // SQL_Latin1_General_CP1251_CS_AS
      [106]: "CP1251",
      // SQL_Latin1_General_CP1251_CI_AS
      [107]: "CP1251",
      // SQL_Ukrainian_Cp1251_CS_AS_KI_WI
      [108]: "CP1251",
      // SQL_Ukrainian_Cp1251_CI_AS_KI_WI
      [112]: "CP1253",
      // SQL_Latin1_General_1253_BIN
      [113]: "CP1253",
      // SQL_Latin1_General_CP1253_CS_AS
      [114]: "CP1253",
      // SQL_Latin1_General_CP1253_CI_AS
      [120]: "CP1253",
      // SQL_MixDiction_CP1253_CS_AS
      [121]: "CP1253",
      // SQL_AltDiction_CP1253_CS_AS
      [122]: "CP1253",
      // SQL_AltDiction2_CP1253_CS_AS
      [124]: "CP1253",
      // SQL_Latin1_General_CP1253_CI_AI
      [128]: "CP1254",
      // SQL_Latin1_General_1254_BIN
      [129]: "CP1254",
      // SQL_Latin1_General_Cp1254_CS_AS_KI_WI
      [130]: "CP1254",
      // SQL_Latin1_General_Cp1254_CI_AS_KI_WI
      [136]: "CP1255",
      // SQL_Latin1_General_1255_BIN
      [137]: "CP1255",
      // SQL_Latin1_General_CP1255_CS_AS
      [138]: "CP1255",
      // SQL_Latin1_General_CP1255_CI_AS
      [144]: "CP1256",
      // SQL_Latin1_General_1256_BIN
      [145]: "CP1256",
      // SQL_Latin1_General_CP1256_CS_AS
      [146]: "CP1256",
      // SQL_Latin1_General_CP1256_CI_AS
      [152]: "CP1257",
      // SQL_Latin1_General_1257_BIN
      [153]: "CP1257",
      // SQL_Latin1_General_CP1257_CS_AS
      [154]: "CP1257",
      // SQL_Latin1_General_CP1257_CI_AS
      [155]: "CP1257",
      // SQL_Estonian_Cp1257_CS_AS_KI_WI
      [156]: "CP1257",
      // SQL_Estonian_Cp1257_CI_AS_KI_WI
      [157]: "CP1257",
      // SQL_Latvian_Cp1257_CS_AS_KI_WI
      [158]: "CP1257",
      // SQL_Latvian_Cp1257_CI_AS_KI_WI
      [159]: "CP1257",
      // SQL_Lithuanian_Cp1257_CS_AS_KI_WI
      [160]: "CP1257",
      // SQL_Lithuanian_Cp1257_CI_AS_KI_WI
      [183]: "CP1252",
      // SQL_Danish_Pref_Cp1_CI_AS_KI_WI
      [184]: "CP1252",
      // SQL_SwedishPhone_Pref_Cp1_CI_AS_KI_WI
      [185]: "CP1252",
      // SQL_SwedishStd_Pref_Cp1_CI_AS_KI_WI
      [186]: "CP1252"
      // SQL_Icelandic_Pref_Cp1_CI_AS_KI_WI
    };
    exports.codepageBySortId = codepageBySortId;
    var Flags = {
      IGNORE_CASE: 1 << 0,
      IGNORE_ACCENT: 1 << 1,
      IGNORE_KANA: 1 << 2,
      IGNORE_WIDTH: 1 << 3,
      BINARY: 1 << 4,
      BINARY2: 1 << 5,
      UTF8: 1 << 6
    };
    exports.Flags = Flags;
    var Collation = class {
      constructor(lcid, flags, version3, sortId) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "lcid");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "flags");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "version");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "sortId");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "codepage");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "buffer");
        this.buffer = void 0;
        this.lcid = lcid;
        this.flags = flags;
        this.version = version3;
        this.sortId = sortId;
        if (this.flags & Flags.UTF8) {
          this.codepage = "utf-8";
        } else if (this.sortId) {
          this.codepage = codepageBySortId[this.sortId];
        } else {
          const languageId = this.lcid & 65535;
          this.codepage = codepageByLanguageId[languageId];
        }
      }
      static fromBuffer(buffer, offset = 0) {
        let lcid = (buffer[offset + 2] & 15) << 16;
        lcid |= buffer[offset + 1] << 8;
        lcid |= buffer[offset + 0];
        let flags = (buffer[offset + 3] & 15) << 4;
        flags |= (buffer[offset + 2] & 240) >>> 4;
        const version3 = (buffer[offset + 3] & 240) >>> 4;
        const sortId = buffer[offset + 4];
        return new this(lcid, flags, version3, sortId);
      }
      toBuffer() {
        if (this.buffer) {
          return this.buffer;
        }
        this.buffer = Buffer.alloc(5);
        this.buffer[0] = this.lcid & 255;
        this.buffer[1] = this.lcid >>> 8 & 255;
        this.buffer[2] = this.lcid >>> 16 & 15 | (this.flags & 15) << 4;
        this.buffer[3] = (this.flags & 240) >>> 4 | (this.version & 15) << 4;
        this.buffer[4] = this.sortId & 255;
        return this.buffer;
      }
    };
    exports.Collation = Collation;
  }
});
var require_null = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/null.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Null = {
      id: 31,
      type: "NULL",
      name: "Null",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = Null;
    exports.default = _default;
    module2.exports = Null;
  }
});
var require_intn = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/intn.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IntN = {
      id: 38,
      type: "INTN",
      name: "IntN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = IntN;
    exports.default = _default;
    module2.exports = IntN;
  }
});
var require_tinyint = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/tinyint.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([1]);
    var NULL_LENGTH = Buffer.from([0]);
    var TinyInt = {
      id: 48,
      type: "INT1",
      name: "TinyInt",
      declaration: function() {
        return "tinyint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 1]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(1);
        buffer.writeUInt8(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < 0 || value > 255) {
          throw new TypeError("Value must be between 0 and 255, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = TinyInt;
    exports.default = _default;
    module2.exports = TinyInt;
  }
});
var require_bitn = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/bitn.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BitN = {
      id: 104,
      type: "BITN",
      name: "BitN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      *generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = BitN;
    exports.default = _default;
    module2.exports = BitN;
  }
});
var require_bit = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/bit.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _bitn = _interopRequireDefault(require_bitn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([1]);
    var NULL_LENGTH = Buffer.from([0]);
    var Bit = {
      id: 50,
      type: "BIT",
      name: "Bit",
      declaration: function() {
        return "bit";
      },
      generateTypeInfo() {
        return Buffer.from([_bitn.default.id, 1]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value ? Buffer.from([1]) : Buffer.from([0]);
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (value) {
          return true;
        } else {
          return false;
        }
      }
    };
    var _default = Bit;
    exports.default = _default;
    module2.exports = Bit;
  }
});
var require_smallint = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/smallint.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([2]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallInt = {
      id: 52,
      type: "INT2",
      name: "SmallInt",
      declaration: function() {
        return "smallint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 2]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeInt16LE(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -32768 || value > 32767) {
          throw new TypeError("Value must be between -32768 and 32767, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = SmallInt;
    exports.default = _default;
    module2.exports = SmallInt;
  }
});
var require_int = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/int.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([4]);
    var Int = {
      id: 56,
      type: "INT4",
      name: "Int",
      declaration: function() {
        return "int";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -2147483648 || value > 2147483647) {
          throw new TypeError("Value must be between -2147483648 and 2147483647, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = Int;
    exports.default = _default;
    module2.exports = Int;
  }
});
var require_datetimen = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/datetimen.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateTimeN = {
      id: 111,
      type: "DATETIMN",
      name: "DateTimeN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = DateTimeN;
    exports.default = _default;
    module2.exports = DateTimeN;
  }
});
var require_smalldatetime = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/smalldatetime.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _datetimen = _interopRequireDefault(require_datetimen());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = new Date(1900, 0, 1);
    var UTC_EPOCH_DATE = new Date(Date.UTC(1900, 0, 1));
    var DATA_LENGTH = Buffer.from([4]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallDateTime = {
      id: 58,
      type: "DATETIM4",
      name: "SmallDateTime",
      declaration: function() {
        return "smalldatetime";
      },
      generateTypeInfo() {
        return Buffer.from([_datetimen.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        let days, dstDiff, minutes;
        if (options.useUTC) {
          days = Math.floor((parameter.value.getTime() - UTC_EPOCH_DATE.getTime()) / (1e3 * 60 * 60 * 24));
          minutes = parameter.value.getUTCHours() * 60 + parameter.value.getUTCMinutes();
        } else {
          dstDiff = -(parameter.value.getTimezoneOffset() - EPOCH_DATE.getTimezoneOffset()) * 60 * 1e3;
          days = Math.floor((parameter.value.getTime() - EPOCH_DATE.getTime() + dstDiff) / (1e3 * 60 * 60 * 24));
          minutes = parameter.value.getHours() * 60 + parameter.value.getMinutes();
        }
        buffer.writeUInt16LE(days, 0);
        buffer.writeUInt16LE(minutes, 2);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = SmallDateTime;
    exports.default = _default;
    module2.exports = SmallDateTime;
  }
});
var require_floatn = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/floatn.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FloatN = {
      id: 109,
      type: "FLTN",
      name: "FloatN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = FloatN;
    exports.default = _default;
    module2.exports = FloatN;
  }
});
var require_real = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/real.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _floatn = _interopRequireDefault(require_floatn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([4]);
    var Real = {
      id: 59,
      type: "FLT4",
      name: "Real",
      declaration: function() {
        return "real";
      },
      generateTypeInfo() {
        return Buffer.from([_floatn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeFloatLE(parseFloat(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = Real;
    exports.default = _default;
    module2.exports = Real;
  }
});
var require_moneyn = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/moneyn.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MoneyN = {
      id: 110,
      type: "MONEYN",
      name: "MoneyN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = MoneyN;
    exports.default = _default;
    module2.exports = MoneyN;
  }
});
var require_money = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/money.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _moneyn = _interopRequireDefault(require_moneyn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([8]);
    var Money = {
      id: 60,
      type: "MONEY",
      name: "Money",
      declaration: function() {
        return "money";
      },
      generateTypeInfo: function() {
        return Buffer.from([_moneyn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value * 1e4;
        const buffer = Buffer.alloc(8);
        buffer.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32), 0);
        buffer.writeInt32LE(value & -1, 4);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = Money;
    exports.default = _default;
    module2.exports = Money;
  }
});
var js_joda_esm_exports = {};
(0, import_chunk_FVJ3R4NJ.__export)(js_joda_esm_exports, {
  ArithmeticException: () => ArithmeticException,
  ChronoField: () => ChronoField,
  ChronoLocalDate: () => ChronoLocalDate,
  ChronoLocalDateTime: () => ChronoLocalDateTime,
  ChronoUnit: () => ChronoUnit,
  ChronoZonedDateTime: () => ChronoZonedDateTime,
  Clock: () => Clock,
  DateTimeException: () => DateTimeException,
  DateTimeFormatter: () => DateTimeFormatter,
  DateTimeFormatterBuilder: () => DateTimeFormatterBuilder,
  DateTimeParseException: () => DateTimeParseException,
  DayOfWeek: () => DayOfWeek,
  DecimalStyle: () => DecimalStyle,
  Duration: () => Duration,
  IllegalArgumentException: () => IllegalArgumentException,
  IllegalStateException: () => IllegalStateException,
  Instant: () => Instant,
  IsoChronology: () => IsoChronology,
  IsoFields: () => IsoFields,
  LocalDate: () => LocalDate,
  LocalDateTime: () => LocalDateTime,
  LocalTime: () => LocalTime,
  Month: () => Month,
  MonthDay: () => MonthDay,
  NullPointerException: () => NullPointerException,
  OffsetDateTime: () => OffsetDateTime,
  OffsetTime: () => OffsetTime,
  ParsePosition: () => ParsePosition,
  Period: () => Period,
  ResolverStyle: () => ResolverStyle,
  SignStyle: () => SignStyle,
  Temporal: () => Temporal,
  TemporalAccessor: () => TemporalAccessor,
  TemporalAdjuster: () => TemporalAdjuster,
  TemporalAdjusters: () => TemporalAdjusters,
  TemporalAmount: () => TemporalAmount,
  TemporalField: () => TemporalField,
  TemporalQueries: () => TemporalQueries,
  TemporalQuery: () => TemporalQuery,
  TemporalUnit: () => TemporalUnit,
  TextStyle: () => TextStyle,
  UnsupportedTemporalTypeException: () => UnsupportedTemporalTypeException,
  ValueRange: () => ValueRange,
  Year: () => Year,
  YearConstants: () => YearConstants,
  YearMonth: () => YearMonth,
  ZoneId: () => ZoneId,
  ZoneOffset: () => ZoneOffset,
  ZoneOffsetTransition: () => ZoneOffsetTransition,
  ZoneRegion: () => ZoneRegion,
  ZoneRules: () => ZoneRules,
  ZoneRulesProvider: () => ZoneRulesProvider,
  ZonedDateTime: () => ZonedDateTime,
  _: () => _,
  convert: () => convert,
  nativeJs: () => nativeJs,
  use: () => use
});
function createErrorType(name3, init2, superErrorClass) {
  if (superErrorClass === void 0) {
    superErrorClass = Error;
  }
  function JsJodaException(message) {
    if (!Error.captureStackTrace) {
      this.stack = new Error().stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
    this.message = message;
    init2 && init2.apply(this, arguments);
    this.toString = function() {
      return this.name + ": " + this.message;
    };
  }
  JsJodaException.prototype = Object.create(superErrorClass.prototype);
  JsJodaException.prototype.name = name3;
  JsJodaException.prototype.constructor = JsJodaException;
  return JsJodaException;
}
function messageWithCause(message, cause) {
  if (cause === void 0) {
    cause = null;
  }
  var msg = message || this.name;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
}
function messageForDateTimeParseException(message, text, index, cause) {
  if (text === void 0) {
    text = "";
  }
  if (index === void 0) {
    index = 0;
  }
  if (cause === void 0) {
    cause = null;
  }
  var msg = message || this.name;
  msg += ": " + text + ", at index: " + index;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
  this.parsedString = function() {
    return text;
  };
  this.errorIndex = function() {
    return index;
  };
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function assert(assertion, msg, error) {
  if (!assertion) {
    if (error) {
      throw new error(msg);
    } else {
      throw new Error(msg);
    }
  }
}
function requireNonNull(value, parameterName) {
  if (value == null) {
    throw new NullPointerException(parameterName + " must not be null");
  }
  return value;
}
function requireInstance(value, _class, parameterName) {
  if (!(value instanceof _class)) {
    throw new IllegalArgumentException(parameterName + " must be an instance of " + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ", but is " + value.constructor.name : ""));
  }
  return value;
}
function abstractMethodFail(methodName) {
  throw new TypeError('abstract method "' + methodName + '" is not implemented');
}
function _init$n() {
  Duration.ZERO = new Duration(0, 0);
}
function _init$m() {
  YearConstants.MIN_VALUE = -999999;
  YearConstants.MAX_VALUE = 999999;
}
function _init$l() {
  ChronoUnit.NANOS = new ChronoUnit("Nanos", Duration.ofNanos(1));
  ChronoUnit.MICROS = new ChronoUnit("Micros", Duration.ofNanos(1e3));
  ChronoUnit.MILLIS = new ChronoUnit("Millis", Duration.ofNanos(1e6));
  ChronoUnit.SECONDS = new ChronoUnit("Seconds", Duration.ofSeconds(1));
  ChronoUnit.MINUTES = new ChronoUnit("Minutes", Duration.ofSeconds(60));
  ChronoUnit.HOURS = new ChronoUnit("Hours", Duration.ofSeconds(3600));
  ChronoUnit.HALF_DAYS = new ChronoUnit("HalfDays", Duration.ofSeconds(43200));
  ChronoUnit.DAYS = new ChronoUnit("Days", Duration.ofSeconds(86400));
  ChronoUnit.WEEKS = new ChronoUnit("Weeks", Duration.ofSeconds(7 * 86400));
  ChronoUnit.MONTHS = new ChronoUnit("Months", Duration.ofSeconds(31556952 / 12));
  ChronoUnit.YEARS = new ChronoUnit("Years", Duration.ofSeconds(31556952));
  ChronoUnit.DECADES = new ChronoUnit("Decades", Duration.ofSeconds(31556952 * 10));
  ChronoUnit.CENTURIES = new ChronoUnit("Centuries", Duration.ofSeconds(31556952 * 100));
  ChronoUnit.MILLENNIA = new ChronoUnit("Millennia", Duration.ofSeconds(31556952 * 1e3));
  ChronoUnit.ERAS = new ChronoUnit("Eras", Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));
  ChronoUnit.FOREVER = new ChronoUnit("Forever", Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));
}
function _init$k() {
  ChronoField.NANO_OF_SECOND = new ChronoField("NanoOfSecond", ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));
  ChronoField.NANO_OF_DAY = new ChronoField("NanoOfDay", ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e9 - 1));
  ChronoField.MICRO_OF_SECOND = new ChronoField("MicroOfSecond", ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));
  ChronoField.MICRO_OF_DAY = new ChronoField("MicroOfDay", ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e6 - 1));
  ChronoField.MILLI_OF_SECOND = new ChronoField("MilliOfSecond", ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));
  ChronoField.MILLI_OF_DAY = new ChronoField("MilliOfDay", ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e3 - 1));
  ChronoField.SECOND_OF_MINUTE = new ChronoField("SecondOfMinute", ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));
  ChronoField.SECOND_OF_DAY = new ChronoField("SecondOfDay", ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));
  ChronoField.MINUTE_OF_HOUR = new ChronoField("MinuteOfHour", ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));
  ChronoField.MINUTE_OF_DAY = new ChronoField("MinuteOfDay", ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));
  ChronoField.HOUR_OF_AMPM = new ChronoField("HourOfAmPm", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));
  ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField("ClockHourOfAmPm", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));
  ChronoField.HOUR_OF_DAY = new ChronoField("HourOfDay", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));
  ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField("ClockHourOfDay", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));
  ChronoField.AMPM_OF_DAY = new ChronoField("AmPmOfDay", ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));
  ChronoField.DAY_OF_WEEK = new ChronoField("DayOfWeek", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField("AlignedDayOfWeekInMonth", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField("AlignedDayOfWeekInYear", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.DAY_OF_MONTH = new ChronoField("DayOfMonth", ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), "day");
  ChronoField.DAY_OF_YEAR = new ChronoField("DayOfYear", ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));
  ChronoField.EPOCH_DAY = new ChronoField("EpochDay", ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(-365961662, 364522971));
  ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField("AlignedWeekOfMonth", ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));
  ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField("AlignedWeekOfYear", ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));
  ChronoField.MONTH_OF_YEAR = new ChronoField("MonthOfYear", ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), "month");
  ChronoField.PROLEPTIC_MONTH = new ChronoField("ProlepticMonth", ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));
  ChronoField.YEAR_OF_ERA = new ChronoField("YearOfEra", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));
  ChronoField.YEAR = new ChronoField("Year", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), "year");
  ChronoField.ERA = new ChronoField("Era", ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));
  ChronoField.INSTANT_SECONDS = new ChronoField("InstantSeconds", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));
  ChronoField.OFFSET_SECONDS = new ChronoField("OffsetSeconds", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));
}
function createTemporalQuery(name3, queryFromFunction) {
  var ExtendedTemporalQuery = function(_TemporalQuery) {
    _inheritsLoose(ExtendedTemporalQuery2, _TemporalQuery);
    function ExtendedTemporalQuery2() {
      return _TemporalQuery.apply(this, arguments) || this;
    }
    return ExtendedTemporalQuery2;
  }(TemporalQuery);
  ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;
  return new ExtendedTemporalQuery(name3);
}
function _init$j() {
  DayOfWeek.MONDAY = new DayOfWeek(0, "MONDAY");
  DayOfWeek.TUESDAY = new DayOfWeek(1, "TUESDAY");
  DayOfWeek.WEDNESDAY = new DayOfWeek(2, "WEDNESDAY");
  DayOfWeek.THURSDAY = new DayOfWeek(3, "THURSDAY");
  DayOfWeek.FRIDAY = new DayOfWeek(4, "FRIDAY");
  DayOfWeek.SATURDAY = new DayOfWeek(5, "SATURDAY");
  DayOfWeek.SUNDAY = new DayOfWeek(6, "SUNDAY");
  DayOfWeek.FROM = createTemporalQuery("DayOfWeek.FROM", function(temporal) {
    return DayOfWeek.from(temporal);
  });
  ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];
}
function _init$i() {
  Month.JANUARY = new Month(1, "JANUARY");
  Month.FEBRUARY = new Month(2, "FEBRUARY");
  Month.MARCH = new Month(3, "MARCH");
  Month.APRIL = new Month(4, "APRIL");
  Month.MAY = new Month(5, "MAY");
  Month.JUNE = new Month(6, "JUNE");
  Month.JULY = new Month(7, "JULY");
  Month.AUGUST = new Month(8, "AUGUST");
  Month.SEPTEMBER = new Month(9, "SEPTEMBER");
  Month.OCTOBER = new Month(10, "OCTOBER");
  Month.NOVEMBER = new Month(11, "NOVEMBER");
  Month.DECEMBER = new Month(12, "DECEMBER");
  MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];
}
function _init$h() {
  Period.ofDays(0);
}
function _init$g() {
  ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;
  ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);
  ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);
  ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);
}
function _init$f() {
  DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();
  QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();
  WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEARS = new Unit("WeekBasedYears", Duration.ofSeconds(31556952));
  QUARTER_YEARS = new Unit("QuarterYears", Duration.ofSeconds(31556952 / 4));
  IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;
  IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;
  IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;
  IsoFields.QUARTER_YEARS = QUARTER_YEARS;
  LocalDate.prototype.isoWeekOfWeekyear = function() {
    return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);
  };
  LocalDate.prototype.isoWeekyear = function() {
    return this.get(IsoFields.WEEK_BASED_YEAR);
  };
}
function _init$e() {
  ReducedPrinterParser.BASE_DATE = LocalDate.of(2e3, 1, 1);
  DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;
  DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;
  DateTimeFormatterBuilder.SettingsParser = SettingsParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;
  DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;
  DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;
  DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;
  DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;
  DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;
}
function _init$d() {
  DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral("-").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(":").appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(":").appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral("T").append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral("[").parseCaseSensitive().appendZoneId().appendLiteral("]").toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendValue(ChronoField.MONTH_OF_YEAR, 2).appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.DAY_OF_YEAR).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-W").appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR).appendLiteral("-").appendValue(ChronoField.DAY_OF_WEEK).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery("PARSED_EXCESS_DAYS", function(temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.excessDays;
    } else {
      return Period.ZERO;
    }
  });
  DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery("PARSED_LEAP_SECOND", function(temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.leapSecond;
    } else {
      return false;
    }
  });
}
function _init$c() {
  PARSER$2 = new DateTimeFormatterBuilder().appendLiteral("--").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral("-").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();
  MonthDay.FROM = createTemporalQuery("MonthDay.FROM", function(temporal) {
    return MonthDay.from(temporal);
  });
}
function _init$b() {
  PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();
  YearMonth.FROM = createTemporalQuery("YearMonth.FROM", function(temporal) {
    return YearMonth.from(temporal);
  });
}
function _init$a() {
  Year.MIN_VALUE = YearConstants.MIN_VALUE;
  Year.MAX_VALUE = YearConstants.MAX_VALUE;
  PARSER = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();
  Year.FROM = createTemporalQuery("Year.FROM", function(temporal) {
    return Year.from(temporal);
  });
}
function _init$9() {
  IsoChronology.INSTANCE = new IsoChronology("IsoChronology");
}
function _init$8() {
  OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0, 0, ZoneOffset.MAX);
  OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59, 999999999, ZoneOffset.MIN);
  OffsetTime.FROM = createTemporalQuery("OffsetTime.FROM", function(temporal) {
    return OffsetTime.from(temporal);
  });
}
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
function _init$7() {
  ZonedDateTime.FROM = createTemporalQuery("ZonedDateTime.FROM", function(temporal) {
    return ZonedDateTime.from(temporal);
  });
}
function _init$6() {
  OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);
  OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);
  OffsetDateTime.FROM = createTemporalQuery("OffsetDateTime.FROM", function(temporal) {
    return OffsetDateTime.from(temporal);
  });
}
function _init$5() {
  LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);
  LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);
  LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);
  LocalDate.FROM = createTemporalQuery("LocalDate.FROM", function(temporal) {
    return LocalDate.from(temporal);
  });
}
function _init$4() {
  LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);
  LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);
  LocalDateTime.FROM = createTemporalQuery("LocalDateTime.FROM", function(temporal) {
    return LocalDateTime.from(temporal);
  });
}
function _init$3() {
  LocalTime.HOURS = [];
  for (var hour = 0; hour < 24; hour++) {
    LocalTime.of(hour, 0, 0, 0);
  }
  LocalTime.MIN = LocalTime.HOURS[0];
  LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);
  LocalTime.MIDNIGHT = LocalTime.HOURS[0];
  LocalTime.NOON = LocalTime.HOURS[12];
  LocalTime.FROM = createTemporalQuery("LocalTime.FROM", function(temporal) {
    return LocalTime.from(temporal);
  });
}
function _init$2() {
  Instant.MIN_SECONDS = -31619119219200;
  Instant.MAX_SECONDS = 31494816403199;
  Instant.EPOCH = new Instant(0, 0);
  Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);
  Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);
  Instant.FROM = createTemporalQuery("Instant.FROM", function(temporal) {
    return Instant.from(temporal);
  });
}
function _init$1() {
  TemporalQueries.ZONE_ID = createTemporalQuery("ZONE_ID", function(temporal) {
    return temporal.query(TemporalQueries.ZONE_ID);
  });
  TemporalQueries.CHRONO = createTemporalQuery("CHRONO", function(temporal) {
    return temporal.query(TemporalQueries.CHRONO);
  });
  TemporalQueries.PRECISION = createTemporalQuery("PRECISION", function(temporal) {
    return temporal.query(TemporalQueries.PRECISION);
  });
  TemporalQueries.OFFSET = createTemporalQuery("OFFSET", function(temporal) {
    if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {
      return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));
    }
    return null;
  });
  TemporalQueries.ZONE = createTemporalQuery("ZONE", function(temporal) {
    var zone = temporal.query(TemporalQueries.ZONE_ID);
    return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);
  });
  TemporalQueries.LOCAL_DATE = createTemporalQuery("LOCAL_DATE", function(temporal) {
    if (temporal.isSupported(ChronoField.EPOCH_DAY)) {
      return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));
    }
    return null;
  });
  TemporalQueries.LOCAL_TIME = createTemporalQuery("LOCAL_TIME", function(temporal) {
    if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {
      return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));
    }
    return null;
  });
}
function _init() {
  SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();
  ZoneId.systemDefault = ZoneIdFactory.systemDefault;
  ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;
  ZoneId.of = ZoneIdFactory.of;
  ZoneId.ofOffset = ZoneIdFactory.ofOffset;
  ZoneId.from = ZoneIdFactory.from;
  ZoneOffset.from = ZoneIdFactory.from;
  ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
  ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);
}
function init() {
  if (isInit) {
    return;
  }
  isInit = true;
  _init$m();
  _init$n();
  _init$l();
  _init$k();
  _init$3();
  _init$f();
  _init$1();
  _init$j();
  _init$2();
  _init$5();
  _init$4();
  _init$a();
  _init$i();
  _init$b();
  _init$c();
  _init$h();
  _init$g();
  _init$7();
  _init();
  _init$9();
  _init$d();
  _init$e();
  _init$6();
  _init$8();
}
function convert(temporal, zone) {
  return new ToNativeJsConverter(temporal, zone);
}
function nativeJs(date, zone) {
  if (zone === void 0) {
    zone = ZoneId.systemDefault();
  }
  requireNonNull(date, "date");
  requireNonNull(zone, "zone");
  if (date instanceof Date) {
    return Instant.ofEpochMilli(date.getTime()).atZone(zone);
  } else if (typeof date.toDate === "function" && date.toDate() instanceof Date) {
    return Instant.ofEpochMilli(date.toDate().getTime()).atZone(zone);
  }
  throw new IllegalArgumentException("date must be a javascript Date or a moment instance");
}
function bindUse(jsJoda) {
  var used = [];
  return function use2(fn) {
    if (!~used.indexOf(fn)) {
      fn(jsJoda);
      used.push(fn);
    }
    return jsJoda;
  };
}
var DateTimeException, DateTimeParseException, UnsupportedTemporalTypeException, ArithmeticException, IllegalArgumentException, IllegalStateException, NullPointerException, assert$1, MAX_SAFE_INTEGER, MIN_SAFE_INTEGER, MathUtil, Enum, TemporalAmount, TemporalUnit, Duration, YearConstants, ChronoUnit, TemporalField, ValueRange, ChronoField, TemporalQueries, TemporalAccessor, TemporalQuery, DayOfWeek, ENUMS, Month, MONTHS, PATTERN, Period, ParsePosition, EnumMap, ResolverStyle, Temporal, ChronoLocalDate, StringUtil, ZoneId, ZoneRules, Fixed, SECONDS_CACHE, ID_CACHE, ZoneOffset, DateTimeBuilder, DateTimeParseContext, Parsed, DateTimePrintContext, IsoFields, QUARTER_DAYS, Field, DAY_OF_QUARTER_FIELD, QUARTER_OF_YEAR_FIELD, WEEK_OF_WEEK_BASED_YEAR_FIELD, WEEK_BASED_YEAR_FIELD, Unit, DAY_OF_QUARTER, QUARTER_OF_YEAR, WEEK_OF_WEEK_BASED_YEAR, WEEK_BASED_YEAR, WEEK_BASED_YEARS, QUARTER_YEARS, DecimalStyle, SignStyle, TextStyle, CharLiteralPrinterParser, CompositePrinterParser, FractionPrinterParser, MAX_WIDTH$1, EXCEED_POINTS, NumberPrinterParser, ReducedPrinterParser, PATTERNS, OffsetIdPrinterParser, PadPrinterParserDecorator, SettingsParser, StringLiteralPrinterParser, ZoneRulesProvider, ZoneRegion, ZoneIdPrinterParser, ZoneIdTree, ZoneIdTreeMap, zoneIdTree, MAX_WIDTH, DateTimeFormatterBuilder, SECONDS_PER_10000_YEARS, SECONDS_0000_TO_1970, InstantPrinterParser, StringBuilder, DateTimeFormatter, MonthDay, PARSER$2, YearMonth, PARSER$1, Year, PARSER, TemporalAdjuster, TemporalAdjusters, Impl, DayOfWeekInMonth, RelativeDayOfWeek, IsoChronology, OffsetTime, ChronoZonedDateTime, ZonedDateTime, OffsetDateTime, DAYS_PER_CYCLE, DAYS_0000_TO_1970, LocalDate, ChronoLocalDateTime, LocalDateTime, LocalTime, NANOS_PER_MILLI, Instant, Clock, SystemClock, FixedClock, OffsetClock, ZoneOffsetTransition, SystemDefaultZoneRules, SystemDefaultZoneId, ZoneIdFactory, SYSTEM_DEFAULT_ZONE_ID_INSTANCE, isInit, ToNativeJsConverter, _, jsJodaExports, use;
var init_js_joda_esm = (0, import_chunk_FVJ3R4NJ.__esm)({
  "../../node_modules/.pnpm/@js-joda+core@5.5.3/node_modules/@js-joda/core/dist/js-joda.esm.js"() {
    "use strict";
    DateTimeException = createErrorType("DateTimeException", messageWithCause);
    DateTimeParseException = createErrorType("DateTimeParseException", messageForDateTimeParseException);
    UnsupportedTemporalTypeException = createErrorType("UnsupportedTemporalTypeException", null, DateTimeException);
    ArithmeticException = createErrorType("ArithmeticException");
    IllegalArgumentException = createErrorType("IllegalArgumentException");
    IllegalStateException = createErrorType("IllegalStateException");
    NullPointerException = createErrorType("NullPointerException");
    assert$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      assert,
      requireNonNull,
      requireInstance,
      abstractMethodFail
    });
    MAX_SAFE_INTEGER = 9007199254740991;
    MIN_SAFE_INTEGER = -9007199254740991;
    MathUtil = function() {
      function MathUtil2() {
      }
      MathUtil2.intDiv = function intDiv(x, y) {
        var r = x / y;
        r = MathUtil2.roundDown(r);
        return MathUtil2.safeZero(r);
      };
      MathUtil2.intMod = function intMod(x, y) {
        var r = x - MathUtil2.intDiv(x, y) * y;
        r = MathUtil2.roundDown(r);
        return MathUtil2.safeZero(r);
      };
      MathUtil2.roundDown = function roundDown(r) {
        if (r < 0) {
          return Math.ceil(r);
        } else {
          return Math.floor(r);
        }
      };
      MathUtil2.floorDiv = function floorDiv(x, y) {
        var r = Math.floor(x / y);
        return MathUtil2.safeZero(r);
      };
      MathUtil2.floorMod = function floorMod(x, y) {
        var r = x - MathUtil2.floorDiv(x, y) * y;
        return MathUtil2.safeZero(r);
      };
      MathUtil2.safeAdd = function safeAdd(x, y) {
        MathUtil2.verifyInt(x);
        MathUtil2.verifyInt(y);
        if (x === 0) {
          return MathUtil2.safeZero(y);
        }
        if (y === 0) {
          return MathUtil2.safeZero(x);
        }
        var r = MathUtil2.safeToInt(x + y);
        if (r === x || r === y) {
          throw new ArithmeticException("Invalid addition beyond MAX_SAFE_INTEGER!");
        }
        return r;
      };
      MathUtil2.safeSubtract = function safeSubtract(x, y) {
        MathUtil2.verifyInt(x);
        MathUtil2.verifyInt(y);
        if (x === 0 && y === 0) {
          return 0;
        } else if (x === 0) {
          return MathUtil2.safeZero(-1 * y);
        } else if (y === 0) {
          return MathUtil2.safeZero(x);
        }
        return MathUtil2.safeToInt(x - y);
      };
      MathUtil2.safeMultiply = function safeMultiply(x, y) {
        MathUtil2.verifyInt(x);
        MathUtil2.verifyInt(y);
        if (x === 1) {
          return MathUtil2.safeZero(y);
        }
        if (y === 1) {
          return MathUtil2.safeZero(x);
        }
        if (x === 0 || y === 0) {
          return 0;
        }
        var r = MathUtil2.safeToInt(x * y);
        if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {
          throw new ArithmeticException("Multiplication overflows: " + x + " * " + y);
        }
        return r;
      };
      MathUtil2.parseInt = function(_parseInt) {
        function parseInt2(_x) {
          return _parseInt.apply(this, arguments);
        }
        parseInt2.toString = function() {
          return _parseInt.toString();
        };
        return parseInt2;
      }(function(value) {
        var r = parseInt(value);
        return MathUtil2.safeToInt(r);
      });
      MathUtil2.safeToInt = function safeToInt(value) {
        MathUtil2.verifyInt(value);
        return MathUtil2.safeZero(value);
      };
      MathUtil2.verifyInt = function verifyInt(value) {
        if (value == null) {
          throw new ArithmeticException("Invalid value: '" + value + "', using null or undefined as argument");
        }
        if (isNaN(value)) {
          throw new ArithmeticException("Invalid int value, using NaN as argument");
        }
        if (value % 1 !== 0) {
          throw new ArithmeticException("Invalid value: '" + value + "' is a float");
        }
        if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {
          throw new ArithmeticException("Calculation overflows an int: " + value);
        }
      };
      MathUtil2.safeZero = function safeZero(value) {
        return value === 0 ? 0 : +value;
      };
      MathUtil2.compareNumbers = function compareNumbers(a, b) {
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      };
      MathUtil2.smi = function smi(int) {
        return int >>> 1 & 1073741824 | int & 3221225471;
      };
      MathUtil2.hash = function hash(number) {
        if (number !== number || number === Infinity) {
          return 0;
        }
        var result = number;
        while (number > 4294967295) {
          number /= 4294967295;
          result ^= number;
        }
        return MathUtil2.smi(result);
      };
      MathUtil2.hashCode = function hashCode() {
        var result = 17;
        for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
          numbers[_key] = arguments[_key];
        }
        for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {
          var n = _numbers[_i];
          result = (result << 5) - result + MathUtil2.hash(n);
        }
        return MathUtil2.hash(result);
      };
      return MathUtil2;
    }();
    MathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
    MathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;
    Enum = function() {
      function Enum2(name3) {
        this._name = name3;
      }
      var _proto = Enum2.prototype;
      _proto.equals = function equals(other) {
        return this === other;
      };
      _proto.toString = function toString() {
        return this._name;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Enum2;
    }();
    TemporalAmount = function() {
      function TemporalAmount2() {
      }
      var _proto = TemporalAmount2.prototype;
      _proto.get = function get(unit) {
        abstractMethodFail("get");
      };
      _proto.units = function units() {
        abstractMethodFail("units");
      };
      _proto.addTo = function addTo(temporal) {
        abstractMethodFail("addTo");
      };
      _proto.subtractFrom = function subtractFrom(temporal) {
        abstractMethodFail("subtractFrom");
      };
      return TemporalAmount2;
    }();
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
      TemporalAmount.prototype[Symbol.toPrimitive] = function(hint) {
        if (hint !== "number") {
          return this.toString();
        }
        throw new TypeError("A conversion from TemporalAmount to a number is not allowed. To compare use the methods .equals(), .compareTo(), .isBefore() or one that is more suitable to your use case.");
      };
    }
    TemporalUnit = function() {
      function TemporalUnit2() {
      }
      var _proto = TemporalUnit2.prototype;
      _proto.duration = function duration() {
        abstractMethodFail("duration");
      };
      _proto.isDurationEstimated = function isDurationEstimated() {
        abstractMethodFail("isDurationEstimated");
      };
      _proto.isDateBased = function isDateBased() {
        abstractMethodFail("isDateBased");
      };
      _proto.isTimeBased = function isTimeBased() {
        abstractMethodFail("isTimeBased");
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        abstractMethodFail("isSupportedBy");
      };
      _proto.addTo = function addTo(dateTime, periodToAdd) {
        abstractMethodFail("addTo");
      };
      _proto.between = function between(temporal1, temporal2) {
        abstractMethodFail("between");
      };
      return TemporalUnit2;
    }();
    Duration = function(_TemporalAmount) {
      _inheritsLoose(Duration2, _TemporalAmount);
      function Duration2(seconds, nanos) {
        var _this;
        _this = _TemporalAmount.call(this) || this;
        _this._seconds = MathUtil.safeToInt(seconds);
        _this._nanos = MathUtil.safeToInt(nanos);
        return _this;
      }
      Duration2.ofDays = function ofDays(days) {
        return Duration2._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);
      };
      Duration2.ofHours = function ofHours(hours) {
        return Duration2._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);
      };
      Duration2.ofMinutes = function ofMinutes(minutes) {
        return Duration2._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);
      };
      Duration2.ofSeconds = function ofSeconds(seconds, nanoAdjustment) {
        if (nanoAdjustment === void 0) {
          nanoAdjustment = 0;
        }
        var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));
        var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
        return Duration2._create(secs, nos);
      };
      Duration2.ofMillis = function ofMillis(millis) {
        var secs = MathUtil.intDiv(millis, 1e3);
        var mos = MathUtil.intMod(millis, 1e3);
        if (mos < 0) {
          mos += 1e3;
          secs--;
        }
        return Duration2._create(secs, mos * 1e6);
      };
      Duration2.ofNanos = function ofNanos(nanos) {
        var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);
        var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);
        if (nos < 0) {
          nos += LocalTime.NANOS_PER_SECOND;
          secs--;
        }
        return this._create(secs, nos);
      };
      Duration2.of = function of(amount, unit) {
        return Duration2.ZERO.plus(amount, unit);
      };
      Duration2.from = function from(amount) {
        requireNonNull(amount, "amount");
        requireInstance(amount, TemporalAmount);
        var duration = Duration2.ZERO;
        amount.units().forEach(function(unit) {
          duration = duration.plus(amount.get(unit), unit);
        });
        return duration;
      };
      Duration2.between = function between(startInclusive, endExclusive) {
        requireNonNull(startInclusive, "startInclusive");
        requireNonNull(endExclusive, "endExclusive");
        var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);
        var nanos = 0;
        if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {
          try {
            var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);
            nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;
            if (secs > 0 && nanos < 0) {
              nanos += LocalTime.NANOS_PER_SECOND;
            } else if (secs < 0 && nanos > 0) {
              nanos -= LocalTime.NANOS_PER_SECOND;
            } else if (secs === 0 && nanos !== 0) {
              var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);
              secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);
            }
          } catch (e) {
          }
        }
        return this.ofSeconds(secs, nanos);
      };
      Duration2.parse = function parse2(text) {
        requireNonNull(text, "text");
        var PATTERN2 = new RegExp("([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?", "i");
        var matches = PATTERN2.exec(text);
        if (matches !== null) {
          if ("T" === matches[3] === false) {
            var negate = "-" === matches[1];
            var dayMatch = matches[2];
            var hourMatch = matches[4];
            var minuteMatch = matches[5];
            var secondMatch = matches[6];
            var fractionMatch = matches[7];
            if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {
              var daysAsSecs = Duration2._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, "days");
              var hoursAsSecs = Duration2._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, "hours");
              var minsAsSecs = Duration2._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, "minutes");
              var seconds = Duration2._parseNumber(text, secondMatch, 1, "seconds");
              var negativeSecs = secondMatch != null && secondMatch.charAt(0) === "-";
              var nanos = Duration2._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);
              try {
                return Duration2._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
              } catch (ex) {
                throw new DateTimeParseException("Text cannot be parsed to a Duration: overflow", text, 0, ex);
              }
            }
          }
        }
        throw new DateTimeParseException("Text cannot be parsed to a Duration", text, 0);
      };
      Duration2._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {
        if (parsed == null) {
          return 0;
        }
        try {
          if (parsed[0] === "+") {
            parsed = parsed.substring(1);
          }
          return MathUtil.safeMultiply(parseFloat(parsed), multiplier);
        } catch (ex) {
          throw new DateTimeParseException("Text cannot be parsed to a Duration: " + errorText, text, 0, ex);
        }
      };
      Duration2._parseFraction = function _parseFraction(text, parsed, negate) {
        if (parsed == null || parsed.length === 0) {
          return 0;
        }
        parsed = (parsed + "000000000").substring(0, 9);
        return parseFloat(parsed) * negate;
      };
      Duration2._create = function _create() {
        if (arguments.length <= 2) {
          return Duration2._createSecondsNanos(arguments[0], arguments[1]);
        } else {
          return Duration2._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        }
      };
      Duration2._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {
        var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));
        if (negate) {
          return Duration2.ofSeconds(seconds, nanos).negated();
        }
        return Duration2.ofSeconds(seconds, nanos);
      };
      Duration2._createSecondsNanos = function _createSecondsNanos(seconds, nanoAdjustment) {
        if (seconds === void 0) {
          seconds = 0;
        }
        if (nanoAdjustment === void 0) {
          nanoAdjustment = 0;
        }
        if (seconds === 0 && nanoAdjustment === 0) {
          return Duration2.ZERO;
        }
        return new Duration2(seconds, nanoAdjustment);
      };
      var _proto = Duration2.prototype;
      _proto.get = function get(unit) {
        if (unit === ChronoUnit.SECONDS) {
          return this._seconds;
        } else if (unit === ChronoUnit.NANOS) {
          return this._nanos;
        } else {
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
      };
      _proto.units = function units() {
        return [ChronoUnit.SECONDS, ChronoUnit.NANOS];
      };
      _proto.isZero = function isZero() {
        return this._seconds === 0 && this._nanos === 0;
      };
      _proto.isNegative = function isNegative() {
        return this._seconds < 0;
      };
      _proto.seconds = function seconds() {
        return this._seconds;
      };
      _proto.nano = function nano() {
        return this._nanos;
      };
      _proto.withSeconds = function withSeconds(seconds) {
        return Duration2._create(seconds, this._nanos);
      };
      _proto.withNanos = function withNanos(nanoOfSecond) {
        ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
        return Duration2._create(this._seconds, nanoOfSecond);
      };
      _proto.plusDuration = function plusDuration(duration) {
        requireNonNull(duration, "duration");
        return this.plus(duration.seconds(), duration.nano());
      };
      _proto.plus = function plus(durationOrNumber, unitOrNumber) {
        if (arguments.length === 1) {
          return this.plusDuration(durationOrNumber);
        } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {
          return this.plusAmountUnit(durationOrNumber, unitOrNumber);
        } else {
          return this.plusSecondsNanos(durationOrNumber, unitOrNumber);
        }
      };
      _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        if (unit === ChronoUnit.DAYS) {
          return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);
        }
        if (unit.isDurationEstimated()) {
          throw new UnsupportedTemporalTypeException("Unit must not have an estimated duration");
        }
        if (amountToAdd === 0) {
          return this;
        }
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1e6 * 1e3) * 1e3, MathUtil.intMod(amountToAdd, 1e6 * 1e3) * 1e3);
            case ChronoUnit.MILLIS:
              return this.plusMillis(amountToAdd);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
          }
          return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);
        }
        var duration = unit.duration().multipliedBy(amountToAdd);
        return this.plusSecondsNanos(duration.seconds(), duration.nano());
      };
      _proto.plusDays = function plusDays(daysToAdd) {
        return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);
      };
      _proto.plusHours = function plusHours(hoursToAdd) {
        return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);
      };
      _proto.plusMinutes = function plusMinutes(minutesToAdd) {
        return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);
      };
      _proto.plusSeconds = function plusSeconds(secondsToAdd) {
        return this.plusSecondsNanos(secondsToAdd, 0);
      };
      _proto.plusMillis = function plusMillis(millisToAdd) {
        return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1e3), MathUtil.intMod(millisToAdd, 1e3) * 1e6);
      };
      _proto.plusNanos = function plusNanos(nanosToAdd) {
        return this.plusSecondsNanos(0, nanosToAdd);
      };
      _proto.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {
        requireNonNull(secondsToAdd, "secondsToAdd");
        requireNonNull(nanosToAdd, "nanosToAdd");
        if (secondsToAdd === 0 && nanosToAdd === 0) {
          return this;
        }
        var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);
        epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));
        nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);
        var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);
        return Duration2.ofSeconds(epochSec, nanoAdjustment);
      };
      _proto.minus = function minus(durationOrNumber, unit) {
        if (arguments.length === 1) {
          return this.minusDuration(durationOrNumber);
        } else {
          return this.minusAmountUnit(durationOrNumber, unit);
        }
      };
      _proto.minusDuration = function minusDuration(duration) {
        requireNonNull(duration, "duration");
        var secsToSubtract = duration.seconds();
        var nanosToSubtract = duration.nano();
        if (secsToSubtract === MIN_SAFE_INTEGER) {
          return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);
        }
        return this.plus(-secsToSubtract, -nanosToSubtract);
      };
      _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {
        requireNonNull(amountToSubtract, "amountToSubtract");
        requireNonNull(unit, "unit");
        return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);
      };
      _proto.minusDays = function minusDays(daysToSubtract) {
        return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);
      };
      _proto.minusHours = function minusHours(hoursToSubtract) {
        return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);
      };
      _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
        return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);
      };
      _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
        return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);
      };
      _proto.minusMillis = function minusMillis(millisToSubtract) {
        return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);
      };
      _proto.minusNanos = function minusNanos(nanosToSubtract) {
        return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);
      };
      _proto.multipliedBy = function multipliedBy(multiplicand) {
        if (multiplicand === 0) {
          return Duration2.ZERO;
        }
        if (multiplicand === 1) {
          return this;
        }
        var secs = MathUtil.safeMultiply(this._seconds, multiplicand);
        var nos = MathUtil.safeMultiply(this._nanos, multiplicand);
        secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);
        nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);
        return Duration2.ofSeconds(secs, nos);
      };
      _proto.dividedBy = function dividedBy(divisor) {
        if (divisor === 0) {
          throw new ArithmeticException("Cannot divide by zero");
        }
        if (divisor === 1) {
          return this;
        }
        var secs = MathUtil.intDiv(this._seconds, divisor);
        var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);
        var nos = MathUtil.intDiv(this._nanos, divisor);
        nos = secsMod + nos;
        return Duration2.ofSeconds(secs, nos);
      };
      _proto.negated = function negated() {
        return this.multipliedBy(-1);
      };
      _proto.abs = function abs() {
        return this.isNegative() ? this.negated() : this;
      };
      _proto.addTo = function addTo(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._seconds !== 0) {
          temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);
        }
        if (this._nanos !== 0) {
          temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);
        }
        return temporal;
      };
      _proto.subtractFrom = function subtractFrom(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._seconds !== 0) {
          temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);
        }
        if (this._nanos !== 0) {
          temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);
        }
        return temporal;
      };
      _proto.toDays = function toDays() {
        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);
      };
      _proto.toHours = function toHours() {
        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
      };
      _proto.toMinutes = function toMinutes() {
        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);
      };
      _proto.toMillis = function toMillis() {
        var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1e3));
        millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1e6));
        return millis;
      };
      _proto.toNanos = function toNanos() {
        var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);
        totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);
        return totalNanos;
      };
      _proto.compareTo = function compareTo(otherDuration) {
        requireNonNull(otherDuration, "otherDuration");
        requireInstance(otherDuration, Duration2, "otherDuration");
        var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());
        if (cmp !== 0) {
          return cmp;
        }
        return this._nanos - otherDuration.nano();
      };
      _proto.equals = function equals(otherDuration) {
        if (this === otherDuration) {
          return true;
        }
        if (otherDuration instanceof Duration2) {
          return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();
        }
        return false;
      };
      _proto.toString = function toString() {
        if (this === Duration2.ZERO) {
          return "PT0S";
        }
        var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
        var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);
        var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);
        var rval = "PT";
        if (hours !== 0) {
          rval += hours + "H";
        }
        if (minutes !== 0) {
          rval += minutes + "M";
        }
        if (secs === 0 && this._nanos === 0 && rval.length > 2) {
          return rval;
        }
        if (secs < 0 && this._nanos > 0) {
          if (secs === -1) {
            rval += "-0";
          } else {
            rval += secs + 1;
          }
        } else {
          rval += secs;
        }
        if (this._nanos > 0) {
          rval += ".";
          var nanoString;
          if (secs < 0) {
            nanoString = "" + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);
          } else {
            nanoString = "" + (LocalTime.NANOS_PER_SECOND + this._nanos);
          }
          nanoString = nanoString.slice(1, nanoString.length);
          rval += nanoString;
          while (rval.charAt(rval.length - 1) === "0") {
            rval = rval.slice(0, rval.length - 1);
          }
        }
        rval += "S";
        return rval;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Duration2;
    }(TemporalAmount);
    YearConstants = function YearConstants2() {
    };
    ChronoUnit = function(_TemporalUnit) {
      _inheritsLoose(ChronoUnit2, _TemporalUnit);
      function ChronoUnit2(name3, estimatedDuration) {
        var _this;
        _this = _TemporalUnit.call(this) || this;
        _this._name = name3;
        _this._duration = estimatedDuration;
        return _this;
      }
      var _proto = ChronoUnit2.prototype;
      _proto.duration = function duration() {
        return this._duration;
      };
      _proto.isDurationEstimated = function isDurationEstimated() {
        return this.isDateBased() || this === ChronoUnit2.FOREVER;
      };
      _proto.isDateBased = function isDateBased() {
        return this.compareTo(ChronoUnit2.DAYS) >= 0 && this !== ChronoUnit2.FOREVER;
      };
      _proto.isTimeBased = function isTimeBased() {
        return this.compareTo(ChronoUnit2.DAYS) < 0;
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        if (this === ChronoUnit2.FOREVER) {
          return false;
        }
        try {
          temporal.plus(1, this);
          return true;
        } catch (e) {
          try {
            temporal.plus(-1, this);
            return true;
          } catch (e2) {
            return false;
          }
        }
      };
      _proto.addTo = function addTo(temporal, amount) {
        return temporal.plus(amount, this);
      };
      _proto.between = function between(temporal1, temporal2) {
        return temporal1.until(temporal2, this);
      };
      _proto.toString = function toString() {
        return this._name;
      };
      _proto.compareTo = function compareTo(other) {
        return this.duration().compareTo(other.duration());
      };
      return ChronoUnit2;
    }(TemporalUnit);
    TemporalField = function() {
      function TemporalField2() {
      }
      var _proto = TemporalField2.prototype;
      _proto.isDateBased = function isDateBased() {
        abstractMethodFail("isDateBased");
      };
      _proto.isTimeBased = function isTimeBased() {
        abstractMethodFail("isTimeBased");
      };
      _proto.baseUnit = function baseUnit() {
        abstractMethodFail("baseUnit");
      };
      _proto.rangeUnit = function rangeUnit() {
        abstractMethodFail("rangeUnit");
      };
      _proto.range = function range() {
        abstractMethodFail("range");
      };
      _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
        abstractMethodFail("rangeRefinedBy");
      };
      _proto.getFrom = function getFrom(temporal) {
        abstractMethodFail("getFrom");
      };
      _proto.adjustInto = function adjustInto(temporal, newValue) {
        abstractMethodFail("adjustInto");
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        abstractMethodFail("isSupportedBy");
      };
      _proto.displayName = function displayName() {
        abstractMethodFail("displayName");
      };
      _proto.equals = function equals(other) {
        abstractMethodFail("equals");
      };
      _proto.name = function name3() {
        abstractMethodFail("name");
      };
      return TemporalField2;
    }();
    ValueRange = function() {
      function ValueRange2(minSmallest, minLargest, maxSmallest, maxLargest) {
        assert(!(minSmallest > minLargest), "Smallest minimum value '" + minSmallest + "' must be less than largest minimum value '" + minLargest + "'", IllegalArgumentException);
        assert(!(maxSmallest > maxLargest), "Smallest maximum value '" + maxSmallest + "' must be less than largest maximum value '" + maxLargest + "'", IllegalArgumentException);
        assert(!(minLargest > maxLargest), "Minimum value '" + minLargest + "' must be less than maximum value '" + maxLargest + "'", IllegalArgumentException);
        this._minSmallest = minSmallest;
        this._minLargest = minLargest;
        this._maxLargest = maxLargest;
        this._maxSmallest = maxSmallest;
      }
      var _proto = ValueRange2.prototype;
      _proto.isFixed = function isFixed() {
        return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;
      };
      _proto.minimum = function minimum() {
        return this._minSmallest;
      };
      _proto.largestMinimum = function largestMinimum() {
        return this._minLargest;
      };
      _proto.maximum = function maximum() {
        return this._maxLargest;
      };
      _proto.smallestMaximum = function smallestMaximum() {
        return this._maxSmallest;
      };
      _proto.isValidValue = function isValidValue(value) {
        return this.minimum() <= value && value <= this.maximum();
      };
      _proto.checkValidValue = function checkValidValue(value, field) {
        var msg;
        if (!this.isValidValue(value)) {
          if (field != null) {
            msg = "Invalid value for " + field + " (valid values " + this.toString() + "): " + value;
          } else {
            msg = "Invalid value (valid values " + this.toString() + "): " + value;
          }
          return assert(false, msg, DateTimeException);
        }
        return value;
      };
      _proto.checkValidIntValue = function checkValidIntValue(value, field) {
        if (this.isValidIntValue(value) === false) {
          throw new DateTimeException("Invalid int value for " + field + ": " + value);
        }
        return value;
      };
      _proto.isValidIntValue = function isValidIntValue(value) {
        return this.isIntValue() && this.isValidValue(value);
      };
      _proto.isIntValue = function isIntValue() {
        return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;
      };
      _proto.equals = function equals(other) {
        if (other === this) {
          return true;
        }
        if (other instanceof ValueRange2) {
          return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);
      };
      _proto.toString = function toString() {
        var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? "/" + this.largestMinimum() : "");
        str += " - ";
        str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? "/" + this.maximum() : "");
        return str;
      };
      ValueRange2.of = function of() {
        if (arguments.length === 2) {
          return new ValueRange2(arguments[0], arguments[0], arguments[1], arguments[1]);
        } else if (arguments.length === 3) {
          return new ValueRange2(arguments[0], arguments[0], arguments[1], arguments[2]);
        } else if (arguments.length === 4) {
          return new ValueRange2(arguments[0], arguments[1], arguments[2], arguments[3]);
        } else {
          return assert(false, "Invalid number of arguments " + arguments.length, IllegalArgumentException);
        }
      };
      return ValueRange2;
    }();
    ChronoField = function(_TemporalField) {
      _inheritsLoose(ChronoField2, _TemporalField);
      ChronoField2.byName = function byName(fieldName) {
        for (var prop in ChronoField2) {
          if (ChronoField2[prop]) {
            if (ChronoField2[prop] instanceof ChronoField2 && ChronoField2[prop].name() === fieldName) {
              return ChronoField2[prop];
            }
          }
        }
      };
      function ChronoField2(name3, baseUnit, rangeUnit, range) {
        var _this;
        _this = _TemporalField.call(this) || this;
        _this._name = name3;
        _this._baseUnit = baseUnit;
        _this._rangeUnit = rangeUnit;
        _this._range = range;
        return _this;
      }
      var _proto = ChronoField2.prototype;
      _proto.name = function name3() {
        return this._name;
      };
      _proto.baseUnit = function baseUnit() {
        return this._baseUnit;
      };
      _proto.rangeUnit = function rangeUnit() {
        return this._rangeUnit;
      };
      _proto.range = function range() {
        return this._range;
      };
      _proto.displayName = function displayName() {
        return this.toString();
      };
      _proto.checkValidValue = function checkValidValue(value) {
        return this.range().checkValidValue(value, this);
      };
      _proto.checkValidIntValue = function checkValidIntValue(value) {
        return this.range().checkValidIntValue(value, this);
      };
      _proto.isDateBased = function isDateBased() {
        var dateBased = this === ChronoField2.DAY_OF_WEEK || this === ChronoField2.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField2.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField2.DAY_OF_MONTH || this === ChronoField2.DAY_OF_YEAR || this === ChronoField2.EPOCH_DAY || this === ChronoField2.ALIGNED_WEEK_OF_MONTH || this === ChronoField2.ALIGNED_WEEK_OF_YEAR || this === ChronoField2.MONTH_OF_YEAR || this === ChronoField2.PROLEPTIC_MONTH || this === ChronoField2.YEAR_OF_ERA || this === ChronoField2.YEAR || this === ChronoField2.ERA;
        return dateBased;
      };
      _proto.isTimeBased = function isTimeBased() {
        var timeBased = this === ChronoField2.NANO_OF_SECOND || this === ChronoField2.NANO_OF_DAY || this === ChronoField2.MICRO_OF_SECOND || this === ChronoField2.MICRO_OF_DAY || this === ChronoField2.MILLI_OF_SECOND || this === ChronoField2.MILLI_OF_DAY || this === ChronoField2.SECOND_OF_MINUTE || this === ChronoField2.SECOND_OF_DAY || this === ChronoField2.MINUTE_OF_HOUR || this === ChronoField2.MINUTE_OF_DAY || this === ChronoField2.HOUR_OF_AMPM || this === ChronoField2.CLOCK_HOUR_OF_AMPM || this === ChronoField2.HOUR_OF_DAY || this === ChronoField2.CLOCK_HOUR_OF_DAY || this === ChronoField2.AMPM_OF_DAY;
        return timeBased;
      };
      _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
        return temporal.range(this);
      };
      _proto.getFrom = function getFrom(temporal) {
        return temporal.getLong(this);
      };
      _proto.toString = function toString() {
        return this.name();
      };
      _proto.equals = function equals(other) {
        return this === other;
      };
      _proto.adjustInto = function adjustInto(temporal, newValue) {
        return temporal.with(this, newValue);
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(this);
      };
      return ChronoField2;
    }(TemporalField);
    TemporalQueries = function() {
      function TemporalQueries2() {
      }
      TemporalQueries2.zoneId = function zoneId() {
        return TemporalQueries2.ZONE_ID;
      };
      TemporalQueries2.chronology = function chronology() {
        return TemporalQueries2.CHRONO;
      };
      TemporalQueries2.precision = function precision() {
        return TemporalQueries2.PRECISION;
      };
      TemporalQueries2.zone = function zone() {
        return TemporalQueries2.ZONE;
      };
      TemporalQueries2.offset = function offset() {
        return TemporalQueries2.OFFSET;
      };
      TemporalQueries2.localDate = function localDate() {
        return TemporalQueries2.LOCAL_DATE;
      };
      TemporalQueries2.localTime = function localTime() {
        return TemporalQueries2.LOCAL_TIME;
      };
      return TemporalQueries2;
    }();
    TemporalAccessor = function() {
      function TemporalAccessor2() {
      }
      var _proto = TemporalAccessor2.prototype;
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.get = function get(field) {
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        abstractMethodFail("getLong");
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (this.isSupported(field)) {
            return field.range();
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.isSupported = function isSupported(field) {
        abstractMethodFail("isSupported");
      };
      return TemporalAccessor2;
    }();
    TemporalQuery = function(_Enum) {
      _inheritsLoose(TemporalQuery2, _Enum);
      function TemporalQuery2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = TemporalQuery2.prototype;
      _proto.queryFrom = function queryFrom(temporal) {
        abstractMethodFail("queryFrom");
      };
      return TemporalQuery2;
    }(Enum);
    DayOfWeek = function(_TemporalAccessor) {
      _inheritsLoose(DayOfWeek2, _TemporalAccessor);
      function DayOfWeek2(ordinal, name3) {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this._ordinal = ordinal;
        _this._name = name3;
        return _this;
      }
      var _proto = DayOfWeek2.prototype;
      _proto.ordinal = function ordinal() {
        return this._ordinal;
      };
      _proto.name = function name3() {
        return this._name;
      };
      DayOfWeek2.values = function values() {
        return ENUMS.slice();
      };
      DayOfWeek2.valueOf = function valueOf(name3) {
        var ordinal = 0;
        for (ordinal; ordinal < ENUMS.length; ordinal++) {
          if (ENUMS[ordinal].name() === name3) {
            break;
          }
        }
        return DayOfWeek2.of(ordinal + 1);
      };
      DayOfWeek2.of = function of(dayOfWeek) {
        if (dayOfWeek < 1 || dayOfWeek > 7) {
          throw new DateTimeException("Invalid value for DayOfWeek: " + dayOfWeek);
        }
        return ENUMS[dayOfWeek - 1];
      };
      DayOfWeek2.from = function from(temporal) {
        assert(temporal != null, "temporal", NullPointerException);
        if (temporal instanceof DayOfWeek2) {
          return temporal;
        }
        try {
          return DayOfWeek2.of(temporal.get(ChronoField.DAY_OF_WEEK));
        } catch (ex) {
          if (ex instanceof DateTimeException) {
            throw new DateTimeException("Unable to obtain DayOfWeek from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""), ex);
          } else {
            throw ex;
          }
        }
      };
      _proto.value = function value() {
        return this._ordinal + 1;
      };
      _proto.displayName = function displayName(style, locale) {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented yet!");
      };
      _proto.isSupported = function isSupported(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.DAY_OF_WEEK;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field === ChronoField.DAY_OF_WEEK) {
          return field.range();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        if (field === ChronoField.DAY_OF_WEEK) {
          return this.value();
        }
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        if (field === ChronoField.DAY_OF_WEEK) {
          return this.value();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.plus = function plus(days) {
        var amount = MathUtil.floorMod(days, 7);
        return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];
      };
      _proto.minus = function minus(days) {
        return this.plus(-1 * MathUtil.floorMod(days, 7));
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.DAYS;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        assert(_query != null, "query", NullPointerException);
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        return temporal.with(ChronoField.DAY_OF_WEEK, this.value());
      };
      _proto.equals = function equals(other) {
        return this === other;
      };
      _proto.toString = function toString() {
        return this._name;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, DayOfWeek2, "other");
        return this._ordinal - other._ordinal;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return DayOfWeek2;
    }(TemporalAccessor);
    Month = function(_TemporalAccessor) {
      _inheritsLoose(Month2, _TemporalAccessor);
      function Month2(value, name3) {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this._value = MathUtil.safeToInt(value);
        _this._name = name3;
        return _this;
      }
      var _proto = Month2.prototype;
      _proto.value = function value() {
        return this._value;
      };
      _proto.ordinal = function ordinal() {
        return this._value - 1;
      };
      _proto.name = function name3() {
        return this._name;
      };
      _proto.displayName = function displayName(style, locale) {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented yet!");
      };
      _proto.isSupported = function isSupported(field) {
        if (null === field) {
          return false;
        }
        if (field instanceof ChronoField) {
          return field === ChronoField.MONTH_OF_YEAR;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.get = function get(field) {
        if (field === ChronoField.MONTH_OF_YEAR) {
          return this.value();
        }
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        if (field === ChronoField.MONTH_OF_YEAR) {
          return this.value();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.plus = function plus(months) {
        var amount = MathUtil.intMod(months, 12) + 12;
        var newMonthVal = MathUtil.intMod(this.value() + amount, 12);
        newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;
        return Month2.of(newMonthVal);
      };
      _proto.minus = function minus(months) {
        return this.plus(-1 * MathUtil.intMod(months, 12));
      };
      _proto.length = function length(leapYear) {
        switch (this) {
          case Month2.FEBRUARY:
            return leapYear ? 29 : 28;
          case Month2.APRIL:
          case Month2.JUNE:
          case Month2.SEPTEMBER:
          case Month2.NOVEMBER:
            return 30;
          default:
            return 31;
        }
      };
      _proto.minLength = function minLength() {
        switch (this) {
          case Month2.FEBRUARY:
            return 28;
          case Month2.APRIL:
          case Month2.JUNE:
          case Month2.SEPTEMBER:
          case Month2.NOVEMBER:
            return 30;
          default:
            return 31;
        }
      };
      _proto.maxLength = function maxLength() {
        switch (this) {
          case Month2.FEBRUARY:
            return 29;
          case Month2.APRIL:
          case Month2.JUNE:
          case Month2.SEPTEMBER:
          case Month2.NOVEMBER:
            return 30;
          default:
            return 31;
        }
      };
      _proto.firstDayOfYear = function firstDayOfYear(leapYear) {
        var leap = leapYear ? 1 : 0;
        switch (this) {
          case Month2.JANUARY:
            return 1;
          case Month2.FEBRUARY:
            return 32;
          case Month2.MARCH:
            return 60 + leap;
          case Month2.APRIL:
            return 91 + leap;
          case Month2.MAY:
            return 121 + leap;
          case Month2.JUNE:
            return 152 + leap;
          case Month2.JULY:
            return 182 + leap;
          case Month2.AUGUST:
            return 213 + leap;
          case Month2.SEPTEMBER:
            return 244 + leap;
          case Month2.OCTOBER:
            return 274 + leap;
          case Month2.NOVEMBER:
            return 305 + leap;
          case Month2.DECEMBER:
          default:
            return 335 + leap;
        }
      };
      _proto.firstMonthOfQuarter = function firstMonthOfQuarter() {
        switch (this) {
          case Month2.JANUARY:
          case Month2.FEBRUARY:
          case Month2.MARCH:
            return Month2.JANUARY;
          case Month2.APRIL:
          case Month2.MAY:
          case Month2.JUNE:
            return Month2.APRIL;
          case Month2.JULY:
          case Month2.AUGUST:
          case Month2.SEPTEMBER:
            return Month2.JULY;
          case Month2.OCTOBER:
          case Month2.NOVEMBER:
          case Month2.DECEMBER:
          default:
            return Month2.OCTOBER;
        }
      };
      _proto.query = function query(_query) {
        assert(_query != null, "query() parameter must not be null", DateTimeException);
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.MONTHS;
        }
        return _TemporalAccessor.prototype.query.call(this, _query);
      };
      _proto.toString = function toString() {
        switch (this) {
          case Month2.JANUARY:
            return "JANUARY";
          case Month2.FEBRUARY:
            return "FEBRUARY";
          case Month2.MARCH:
            return "MARCH";
          case Month2.APRIL:
            return "APRIL";
          case Month2.MAY:
            return "MAY";
          case Month2.JUNE:
            return "JUNE";
          case Month2.JULY:
            return "JULY";
          case Month2.AUGUST:
            return "AUGUST";
          case Month2.SEPTEMBER:
            return "SEPTEMBER";
          case Month2.OCTOBER:
            return "OCTOBER";
          case Month2.NOVEMBER:
            return "NOVEMBER";
          case Month2.DECEMBER:
            return "DECEMBER";
          default:
            return "unknown Month, value: " + this.value();
        }
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, Month2, "other");
        return this._value - other._value;
      };
      _proto.equals = function equals(other) {
        return this === other;
      };
      Month2.valueOf = function valueOf(name3) {
        var ordinal = 0;
        for (ordinal; ordinal < MONTHS.length; ordinal++) {
          if (MONTHS[ordinal].name() === name3) {
            break;
          }
        }
        return Month2.of(ordinal + 1);
      };
      Month2.values = function values() {
        return MONTHS.slice();
      };
      Month2.of = function of(month) {
        if (month < 1 || month > 12) {
          assert(false, "Invalid value for MonthOfYear: " + month, DateTimeException);
        }
        return MONTHS[month - 1];
      };
      Month2.from = function from(temporal) {
        if (temporal instanceof Month2) {
          return temporal;
        }
        try {
          return Month2.of(temporal.get(ChronoField.MONTH_OF_YEAR));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain Month from TemporalAccessor: " + temporal + " of type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""), ex);
        }
      };
      return Month2;
    }(TemporalAccessor);
    PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;
    Period = function(_TemporalAmount) {
      _inheritsLoose(Period2, _TemporalAmount);
      function Period2(years, months, days) {
        var _this;
        _this = _TemporalAmount.call(this) || this;
        var _years = MathUtil.safeToInt(years);
        var _months = MathUtil.safeToInt(months);
        var _days = MathUtil.safeToInt(days);
        if (_years === 0 && _months === 0 && _days === 0) {
          if (!Period2.ZERO) {
            _this._years = _years;
            _this._months = _months;
            _this._days = _days;
            Period2.ZERO = _assertThisInitialized(_this);
          }
          return Period2.ZERO || _assertThisInitialized(_this);
        }
        _this._years = _years;
        _this._months = _months;
        _this._days = _days;
        return _this;
      }
      Period2.ofYears = function ofYears(years) {
        return Period2.create(years, 0, 0);
      };
      Period2.ofMonths = function ofMonths(months) {
        return Period2.create(0, months, 0);
      };
      Period2.ofWeeks = function ofWeeks(weeks) {
        return Period2.create(0, 0, MathUtil.safeMultiply(weeks, 7));
      };
      Period2.ofDays = function ofDays(days) {
        return Period2.create(0, 0, days);
      };
      Period2.of = function of(years, months, days) {
        return Period2.create(years, months, days);
      };
      Period2.from = function from(amount) {
        if (amount instanceof Period2) {
          return amount;
        }
        requireNonNull(amount, "amount");
        var years = 0;
        var months = 0;
        var days = 0;
        var units = amount.units();
        for (var i = 0; i < units.length; i++) {
          var unit = units[i];
          var unitAmount = amount.get(unit);
          if (unit === ChronoUnit.YEARS) {
            years = MathUtil.safeToInt(unitAmount);
          } else if (unit === ChronoUnit.MONTHS) {
            months = MathUtil.safeToInt(unitAmount);
          } else if (unit === ChronoUnit.DAYS) {
            days = MathUtil.safeToInt(unitAmount);
          } else {
            throw new DateTimeException("Unit must be Years, Months or Days, but was " + unit);
          }
        }
        return Period2.create(years, months, days);
      };
      Period2.between = function between(startDate, endDate) {
        requireNonNull(startDate, "startDate");
        requireNonNull(endDate, "endDate");
        requireInstance(startDate, LocalDate, "startDate");
        requireInstance(endDate, LocalDate, "endDate");
        return startDate.until(endDate);
      };
      Period2.parse = function parse2(text) {
        requireNonNull(text, "text");
        try {
          return Period2._parse(text);
        } catch (ex) {
          if (ex instanceof ArithmeticException) {
            throw new DateTimeParseException("Text cannot be parsed to a Period", text, 0, ex);
          } else {
            throw ex;
          }
        }
      };
      Period2._parse = function _parse(text) {
        var matches = PATTERN.exec(text);
        if (matches != null) {
          var negate = "-" === matches[1] ? -1 : 1;
          var yearMatch = matches[2];
          var monthMatch = matches[3];
          var weekMatch = matches[4];
          var dayMatch = matches[5];
          if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {
            var years = Period2._parseNumber(text, yearMatch, negate);
            var months = Period2._parseNumber(text, monthMatch, negate);
            var weeks = Period2._parseNumber(text, weekMatch, negate);
            var days = Period2._parseNumber(text, dayMatch, negate);
            days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));
            return Period2.create(years, months, days);
          }
        }
        throw new DateTimeParseException("Text cannot be parsed to a Period", text, 0);
      };
      Period2._parseNumber = function _parseNumber(text, str, negate) {
        if (str == null) {
          return 0;
        }
        var val = MathUtil.parseInt(str);
        return MathUtil.safeMultiply(val, negate);
      };
      Period2.create = function create(years, months, days) {
        return new Period2(years, months, days);
      };
      var _proto = Period2.prototype;
      _proto.units = function units() {
        return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];
      };
      _proto.chronology = function chronology() {
        return IsoChronology.INSTANCE;
      };
      _proto.get = function get(unit) {
        if (unit === ChronoUnit.YEARS) {
          return this._years;
        }
        if (unit === ChronoUnit.MONTHS) {
          return this._months;
        }
        if (unit === ChronoUnit.DAYS) {
          return this._days;
        }
        throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
      };
      _proto.isZero = function isZero() {
        return this === Period2.ZERO;
      };
      _proto.isNegative = function isNegative() {
        return this._years < 0 || this._months < 0 || this._days < 0;
      };
      _proto.years = function years() {
        return this._years;
      };
      _proto.months = function months() {
        return this._months;
      };
      _proto.days = function days() {
        return this._days;
      };
      _proto.withYears = function withYears(years) {
        if (years === this._years) {
          return this;
        }
        return Period2.create(years, this._months, this._days);
      };
      _proto.withMonths = function withMonths(months) {
        if (months === this._months) {
          return this;
        }
        return Period2.create(this._years, months, this._days);
      };
      _proto.withDays = function withDays(days) {
        if (days === this._days) {
          return this;
        }
        return Period2.create(this._years, this._months, days);
      };
      _proto.plus = function plus(amountToAdd) {
        var amount = Period2.from(amountToAdd);
        return Period2.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        return Period2.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);
      };
      _proto.plusMonths = function plusMonths(monthsToAdd) {
        if (monthsToAdd === 0) {
          return this;
        }
        return Period2.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);
      };
      _proto.plusDays = function plusDays(daysToAdd) {
        if (daysToAdd === 0) {
          return this;
        }
        return Period2.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));
      };
      _proto.minus = function minus(amountToSubtract) {
        var amount = Period2.from(amountToSubtract);
        return Period2.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return this.plusYears(-1 * yearsToSubtract);
      };
      _proto.minusMonths = function minusMonths(monthsToSubtract) {
        return this.plusMonths(-1 * monthsToSubtract);
      };
      _proto.minusDays = function minusDays(daysToSubtract) {
        return this.plusDays(-1 * daysToSubtract);
      };
      _proto.multipliedBy = function multipliedBy(scalar) {
        if (this === Period2.ZERO || scalar === 1) {
          return this;
        }
        return Period2.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));
      };
      _proto.negated = function negated() {
        return this.multipliedBy(-1);
      };
      _proto.normalized = function normalized() {
        var totalMonths = this.toTotalMonths();
        var splitYears = MathUtil.intDiv(totalMonths, 12);
        var splitMonths = MathUtil.intMod(totalMonths, 12);
        if (splitYears === this._years && splitMonths === this._months) {
          return this;
        }
        return Period2.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);
      };
      _proto.toTotalMonths = function toTotalMonths() {
        return this._years * 12 + this._months;
      };
      _proto.addTo = function addTo(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._years !== 0) {
          if (this._months !== 0) {
            temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);
          } else {
            temporal = temporal.plus(this._years, ChronoUnit.YEARS);
          }
        } else if (this._months !== 0) {
          temporal = temporal.plus(this._months, ChronoUnit.MONTHS);
        }
        if (this._days !== 0) {
          temporal = temporal.plus(this._days, ChronoUnit.DAYS);
        }
        return temporal;
      };
      _proto.subtractFrom = function subtractFrom(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._years !== 0) {
          if (this._months !== 0) {
            temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);
          } else {
            temporal = temporal.minus(this._years, ChronoUnit.YEARS);
          }
        } else if (this._months !== 0) {
          temporal = temporal.minus(this._months, ChronoUnit.MONTHS);
        }
        if (this._days !== 0) {
          temporal = temporal.minus(this._days, ChronoUnit.DAYS);
        }
        return temporal;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof Period2) {
          var other = obj;
          return this._years === other._years && this._months === other._months && this._days === other._days;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._years, this._months, this._days);
      };
      _proto.toString = function toString() {
        if (this === Period2.ZERO) {
          return "P0D";
        } else {
          var buf = "P";
          if (this._years !== 0) {
            buf += this._years + "Y";
          }
          if (this._months !== 0) {
            buf += this._months + "M";
          }
          if (this._days !== 0) {
            buf += this._days + "D";
          }
          return buf;
        }
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Period2;
    }(TemporalAmount);
    ParsePosition = function() {
      function ParsePosition2(index) {
        this._index = index;
        this._errorIndex = -1;
      }
      var _proto = ParsePosition2.prototype;
      _proto.getIndex = function getIndex() {
        return this._index;
      };
      _proto.setIndex = function setIndex(index) {
        this._index = index;
      };
      _proto.getErrorIndex = function getErrorIndex() {
        return this._errorIndex;
      };
      _proto.setErrorIndex = function setErrorIndex(errorIndex) {
        this._errorIndex = errorIndex;
      };
      return ParsePosition2;
    }();
    EnumMap = function() {
      function EnumMap2() {
        this._map = {};
      }
      var _proto = EnumMap2.prototype;
      _proto.putAll = function putAll(otherMap) {
        for (var key in otherMap._map) {
          this._map[key] = otherMap._map[key];
        }
        return this;
      };
      _proto.containsKey = function containsKey(key) {
        return this._map.hasOwnProperty(key.name()) && this.get(key) !== void 0;
      };
      _proto.get = function get(key) {
        return this._map[key.name()];
      };
      _proto.put = function put(key, val) {
        return this.set(key, val);
      };
      _proto.set = function set(key, val) {
        this._map[key.name()] = val;
        return this;
      };
      _proto.retainAll = function retainAll(keyList) {
        var map = {};
        for (var i = 0; i < keyList.length; i++) {
          var key = keyList[i].name();
          map[key] = this._map[key];
        }
        this._map = map;
        return this;
      };
      _proto.remove = function remove(key) {
        var keyName = key.name();
        var val = this._map[keyName];
        this._map[keyName] = void 0;
        return val;
      };
      _proto.keySet = function keySet() {
        return this._map;
      };
      _proto.clear = function clear() {
        this._map = {};
      };
      return EnumMap2;
    }();
    ResolverStyle = function(_Enum) {
      _inheritsLoose(ResolverStyle2, _Enum);
      function ResolverStyle2() {
        return _Enum.apply(this, arguments) || this;
      }
      return ResolverStyle2;
    }(Enum);
    ResolverStyle.STRICT = new ResolverStyle("STRICT");
    ResolverStyle.SMART = new ResolverStyle("SMART");
    ResolverStyle.LENIENT = new ResolverStyle("LENIENT");
    Temporal = function(_TemporalAccessor) {
      _inheritsLoose(Temporal2, _TemporalAccessor);
      function Temporal2() {
        return _TemporalAccessor.apply(this, arguments) || this;
      }
      var _proto = Temporal2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        abstractMethodFail("isSupported");
      };
      _proto.minus = function minus(amount, unit) {
        if (arguments.length < 2) {
          return this._minusAmount(amount);
        } else {
          return this._minusUnit(amount, unit);
        }
      };
      _proto._minusAmount = function _minusAmount(amount) {
        requireNonNull(amount, "amount");
        requireInstance(amount, TemporalAmount, "amount");
        return amount.subtractFrom(this);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(amountToSubtract, "amountToSubtract");
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit, "unit");
        return this._plusUnit(-amountToSubtract, unit);
      };
      _proto.plus = function plus(amount, unit) {
        if (arguments.length < 2) {
          return this._plusAmount(amount);
        } else {
          return this._plusUnit(amount, unit);
        }
      };
      _proto._plusAmount = function _plusAmount(amount) {
        requireNonNull(amount, "amount");
        requireInstance(amount, TemporalAmount, "amount");
        return amount.addTo(this);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        abstractMethodFail("_plusUnit");
      };
      _proto.until = function until(endTemporal, unit) {
        abstractMethodFail("until");
      };
      _proto.with = function _with(adjusterOrField, newValue) {
        if (arguments.length < 2) {
          return this._withAdjuster(adjusterOrField);
        } else {
          return this._withField(adjusterOrField, newValue);
        }
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        assert(typeof adjuster.adjustInto === "function", "adjuster must be a TemporalAdjuster", IllegalArgumentException);
        return adjuster.adjustInto(this);
      };
      _proto._withField = function _withField(field, newValue) {
        abstractMethodFail("_withField");
      };
      return Temporal2;
    }(TemporalAccessor);
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
      Temporal.prototype[Symbol.toPrimitive] = function(hint) {
        if (hint !== "number") {
          return this.toString();
        }
        throw new TypeError("A conversion from Temporal to a number is not allowed. To compare use the methods .equals(), .compareTo(), .isBefore() or one that is more suitable to your use case.");
      };
    }
    ChronoLocalDate = function(_Temporal) {
      _inheritsLoose(ChronoLocalDate2, _Temporal);
      function ChronoLocalDate2() {
        return _Temporal.apply(this, arguments) || this;
      }
      var _proto = ChronoLocalDate2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isDateBased();
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.chronology()) {
          return this.chronology();
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.DAYS;
        } else if (_query === TemporalQueries.localDate()) {
          return LocalDate.ofEpochDay(this.toEpochDay());
        } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.format(this);
      };
      return ChronoLocalDate2;
    }(Temporal);
    StringUtil = function() {
      function StringUtil2() {
      }
      StringUtil2.startsWith = function startsWith(text, pattern) {
        return text.indexOf(pattern) === 0;
      };
      StringUtil2.hashCode = function hashCode(text) {
        var len = text.length;
        if (len === 0) {
          return 0;
        }
        var hash = 0;
        for (var i = 0; i < len; i++) {
          var chr = text.charCodeAt(i);
          hash = (hash << 5) - hash + chr;
          hash |= 0;
        }
        return MathUtil.smi(hash);
      };
      return StringUtil2;
    }();
    ZoneId = function() {
      function ZoneId2() {
      }
      ZoneId2.systemDefault = function systemDefault() {
        throw new DateTimeException("not supported operation");
      };
      ZoneId2.getAvailableZoneIds = function getAvailableZoneIds() {
        throw new DateTimeException("not supported operation");
      };
      ZoneId2.of = function of(zoneId) {
        throw new DateTimeException("not supported operation" + zoneId);
      };
      ZoneId2.ofOffset = function ofOffset(prefix, offset) {
        throw new DateTimeException("not supported operation" + prefix + offset);
      };
      ZoneId2.from = function from(temporal) {
        throw new DateTimeException("not supported operation" + temporal);
      };
      var _proto = ZoneId2.prototype;
      _proto.id = function id() {
        abstractMethodFail("ZoneId.id");
      };
      _proto.rules = function rules() {
        abstractMethodFail("ZoneId.rules");
      };
      _proto.normalized = function normalized() {
        var rules = this.rules();
        if (rules.isFixedOffset()) {
          return rules.offset(Instant.EPOCH);
        }
        return this;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ZoneId2) {
          return this.id() === other.id();
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return StringUtil.hashCode(this.id());
      };
      _proto.toString = function toString() {
        return this.id();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return ZoneId2;
    }();
    ZoneRules = function() {
      function ZoneRules2() {
      }
      ZoneRules2.of = function of(offset) {
        requireNonNull(offset, "offset");
        return new Fixed(offset);
      };
      var _proto = ZoneRules2.prototype;
      _proto.isFixedOffset = function isFixedOffset() {
        abstractMethodFail("ZoneRules.isFixedOffset");
      };
      _proto.offset = function offset(instantOrLocalDateTime) {
        if (instantOrLocalDateTime instanceof Instant) {
          return this.offsetOfInstant(instantOrLocalDateTime);
        } else {
          return this.offsetOfLocalDateTime(instantOrLocalDateTime);
        }
      };
      _proto.offsetOfInstant = function offsetOfInstant(instant) {
        abstractMethodFail("ZoneRules.offsetInstant");
      };
      _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
        abstractMethodFail("ZoneRules.offsetOfEpochMilli");
      };
      _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
        abstractMethodFail("ZoneRules.offsetLocalDateTime");
      };
      _proto.validOffsets = function validOffsets(localDateTime) {
        abstractMethodFail("ZoneRules.validOffsets");
      };
      _proto.transition = function transition(localDateTime) {
        abstractMethodFail("ZoneRules.transition");
      };
      _proto.standardOffset = function standardOffset(instant) {
        abstractMethodFail("ZoneRules.standardOffset");
      };
      _proto.daylightSavings = function daylightSavings(instant) {
        abstractMethodFail("ZoneRules.daylightSavings");
      };
      _proto.isDaylightSavings = function isDaylightSavings(instant) {
        abstractMethodFail("ZoneRules.isDaylightSavings");
      };
      _proto.isValidOffset = function isValidOffset(localDateTime, offset) {
        abstractMethodFail("ZoneRules.isValidOffset");
      };
      _proto.nextTransition = function nextTransition(instant) {
        abstractMethodFail("ZoneRules.nextTransition");
      };
      _proto.previousTransition = function previousTransition(instant) {
        abstractMethodFail("ZoneRules.previousTransition");
      };
      _proto.transitions = function transitions() {
        abstractMethodFail("ZoneRules.transitions");
      };
      _proto.transitionRules = function transitionRules() {
        abstractMethodFail("ZoneRules.transitionRules");
      };
      _proto.toString = function toString() {
        abstractMethodFail("ZoneRules.toString");
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return ZoneRules2;
    }();
    Fixed = function(_ZoneRules) {
      _inheritsLoose(Fixed2, _ZoneRules);
      function Fixed2(offset) {
        var _this;
        _this = _ZoneRules.call(this) || this;
        _this._offset = offset;
        return _this;
      }
      var _proto2 = Fixed2.prototype;
      _proto2.isFixedOffset = function isFixedOffset() {
        return true;
      };
      _proto2.offsetOfInstant = function offsetOfInstant() {
        return this._offset;
      };
      _proto2.offsetOfEpochMilli = function offsetOfEpochMilli() {
        return this._offset;
      };
      _proto2.offsetOfLocalDateTime = function offsetOfLocalDateTime() {
        return this._offset;
      };
      _proto2.validOffsets = function validOffsets() {
        return [this._offset];
      };
      _proto2.transition = function transition() {
        return null;
      };
      _proto2.standardOffset = function standardOffset() {
        return this._offset;
      };
      _proto2.daylightSavings = function daylightSavings() {
        return Duration.ZERO;
      };
      _proto2.isDaylightSavings = function isDaylightSavings() {
        return false;
      };
      _proto2.isValidOffset = function isValidOffset(localDateTime, offset) {
        return this._offset.equals(offset);
      };
      _proto2.nextTransition = function nextTransition() {
        return null;
      };
      _proto2.previousTransition = function previousTransition() {
        return null;
      };
      _proto2.transitions = function transitions() {
        return [];
      };
      _proto2.transitionRules = function transitionRules() {
        return [];
      };
      _proto2.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof Fixed2) {
          return this._offset.equals(other._offset);
        }
        return false;
      };
      _proto2.toString = function toString() {
        return "FixedRules:" + this._offset.toString();
      };
      return Fixed2;
    }(ZoneRules);
    SECONDS_CACHE = {};
    ID_CACHE = {};
    ZoneOffset = function(_ZoneId) {
      _inheritsLoose(ZoneOffset2, _ZoneId);
      function ZoneOffset2(totalSeconds) {
        var _this;
        _this = _ZoneId.call(this) || this;
        ZoneOffset2._validateTotalSeconds(totalSeconds);
        _this._totalSeconds = MathUtil.safeToInt(totalSeconds);
        _this._rules = ZoneRules.of(_assertThisInitialized(_this));
        _this._id = ZoneOffset2._buildId(totalSeconds);
        return _this;
      }
      var _proto = ZoneOffset2.prototype;
      _proto.totalSeconds = function totalSeconds() {
        return this._totalSeconds;
      };
      _proto.id = function id() {
        return this._id;
      };
      ZoneOffset2._buildId = function _buildId(totalSeconds) {
        if (totalSeconds === 0) {
          return "Z";
        } else {
          var absTotalSeconds = Math.abs(totalSeconds);
          var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);
          var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
          var buf = (totalSeconds < 0 ? "-" : "+") + (absHours < 10 ? "0" : "") + absHours + (absMinutes < 10 ? ":0" : ":") + absMinutes;
          var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);
          if (absSeconds !== 0) {
            buf += (absSeconds < 10 ? ":0" : ":") + absSeconds;
          }
          return buf;
        }
      };
      ZoneOffset2._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {
        if (Math.abs(totalSeconds) > ZoneOffset2.MAX_SECONDS) {
          throw new DateTimeException("Zone offset not in valid range: -18:00 to +18:00");
        }
      };
      ZoneOffset2._validate = function _validate(hours, minutes, seconds) {
        if (hours < -18 || hours > 18) {
          throw new DateTimeException("Zone offset hours not in valid range: value " + hours + " is not in the range -18 to 18");
        }
        if (hours > 0) {
          if (minutes < 0 || seconds < 0) {
            throw new DateTimeException("Zone offset minutes and seconds must be positive because hours is positive");
          }
        } else if (hours < 0) {
          if (minutes > 0 || seconds > 0) {
            throw new DateTimeException("Zone offset minutes and seconds must be negative because hours is negative");
          }
        } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {
          throw new DateTimeException("Zone offset minutes and seconds must have the same sign");
        }
        if (Math.abs(minutes) > 59) {
          throw new DateTimeException("Zone offset minutes not in valid range: abs(value) " + Math.abs(minutes) + " is not in the range 0 to 59");
        }
        if (Math.abs(seconds) > 59) {
          throw new DateTimeException("Zone offset seconds not in valid range: abs(value) " + Math.abs(seconds) + " is not in the range 0 to 59");
        }
        if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {
          throw new DateTimeException("Zone offset not in valid range: -18:00 to +18:00");
        }
      };
      ZoneOffset2.of = function of(offsetId) {
        requireNonNull(offsetId, "offsetId");
        var offset = ID_CACHE[offsetId];
        if (offset != null) {
          return offset;
        }
        var hours, minutes, seconds;
        switch (offsetId.length) {
          case 2:
            offsetId = offsetId[0] + "0" + offsetId[1];
          case 3:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = 0;
            seconds = 0;
            break;
          case 5:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 3, false);
            seconds = 0;
            break;
          case 6:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 4, true);
            seconds = 0;
            break;
          case 7:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 3, false);
            seconds = ZoneOffset2._parseNumber(offsetId, 5, false);
            break;
          case 9:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 4, true);
            seconds = ZoneOffset2._parseNumber(offsetId, 7, true);
            break;
          default:
            throw new DateTimeException("Invalid ID for ZoneOffset, invalid format: " + offsetId);
        }
        var first = offsetId[0];
        if (first !== "+" && first !== "-") {
          throw new DateTimeException("Invalid ID for ZoneOffset, plus/minus not found when expected: " + offsetId);
        }
        if (first === "-") {
          return ZoneOffset2.ofHoursMinutesSeconds(-hours, -minutes, -seconds);
        } else {
          return ZoneOffset2.ofHoursMinutesSeconds(hours, minutes, seconds);
        }
      };
      ZoneOffset2._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {
        if (precededByColon && offsetId[pos - 1] !== ":") {
          throw new DateTimeException("Invalid ID for ZoneOffset, colon not found when expected: " + offsetId);
        }
        var ch1 = offsetId[pos];
        var ch2 = offsetId[pos + 1];
        if (ch1 < "0" || ch1 > "9" || ch2 < "0" || ch2 > "9") {
          throw new DateTimeException("Invalid ID for ZoneOffset, non numeric characters found: " + offsetId);
        }
        return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
      };
      ZoneOffset2.ofHours = function ofHours(hours) {
        return ZoneOffset2.ofHoursMinutesSeconds(hours, 0, 0);
      };
      ZoneOffset2.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {
        return ZoneOffset2.ofHoursMinutesSeconds(hours, minutes, 0);
      };
      ZoneOffset2.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {
        ZoneOffset2._validate(hours, minutes, seconds);
        var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;
        return ZoneOffset2.ofTotalSeconds(totalSeconds);
      };
      ZoneOffset2.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {
        var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;
        return ZoneOffset2.ofTotalSeconds(totalSeconds);
      };
      ZoneOffset2.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {
        if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {
          var totalSecs = totalSeconds;
          var result = SECONDS_CACHE[totalSecs];
          if (result == null) {
            result = new ZoneOffset2(totalSeconds);
            SECONDS_CACHE[totalSecs] = result;
            ID_CACHE[result.id()] = result;
          }
          return result;
        } else {
          return new ZoneOffset2(totalSeconds);
        }
      };
      _proto.rules = function rules() {
        return this._rules;
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        if (field === ChronoField.OFFSET_SECONDS) {
          return this._totalSeconds;
        } else if (field instanceof ChronoField) {
          throw new DateTimeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
          return this;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        return other._totalSeconds - this._totalSeconds;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof ZoneOffset2) {
          return this._totalSeconds === obj._totalSeconds;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._totalSeconds;
      };
      _proto.toString = function toString() {
        return this._id;
      };
      return ZoneOffset2;
    }(ZoneId);
    DateTimeBuilder = function(_TemporalAccessor) {
      _inheritsLoose(DateTimeBuilder2, _TemporalAccessor);
      DateTimeBuilder2.create = function create(field, value) {
        var dtb = new DateTimeBuilder2();
        dtb._addFieldValue(field, value);
        return dtb;
      };
      function DateTimeBuilder2() {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this.fieldValues = new EnumMap();
        _this.chrono = null;
        _this.zone = null;
        _this.date = null;
        _this.time = null;
        _this.leapSecond = false;
        _this.excessDays = null;
        return _this;
      }
      var _proto = DateTimeBuilder2.prototype;
      _proto.getFieldValue0 = function getFieldValue0(field) {
        return this.fieldValues.get(field);
      };
      _proto._addFieldValue = function _addFieldValue(field, value) {
        requireNonNull(field, "field");
        var old = this.getFieldValue0(field);
        if (old != null && old !== value) {
          throw new DateTimeException("Conflict found: " + field + " " + old + " differs from " + field + " " + value + ": " + this);
        }
        return this._putFieldValue0(field, value);
      };
      _proto._putFieldValue0 = function _putFieldValue0(field, value) {
        this.fieldValues.put(field, value);
        return this;
      };
      _proto.resolve = function resolve(resolverStyle, resolverFields) {
        if (resolverFields != null) {
          this.fieldValues.retainAll(resolverFields);
        }
        this._mergeDate(resolverStyle);
        this._mergeTime(resolverStyle);
        this._resolveTimeInferZeroes(resolverStyle);
        if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {
          this.date = this.date.plus(this.excessDays);
          this.excessDays = Period.ZERO;
        }
        this._resolveInstant();
        return this;
      };
      _proto._mergeDate = function _mergeDate(resolverStyle) {
        this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));
      };
      _proto._checkDate = function _checkDate(date) {
        if (date != null) {
          this._addObject(date);
          for (var fieldName in this.fieldValues.keySet()) {
            var field = ChronoField.byName(fieldName);
            if (field) {
              if (this.fieldValues.get(field) !== void 0) {
                if (field.isDateBased()) {
                  var val1 = void 0;
                  try {
                    val1 = date.getLong(field);
                  } catch (ex) {
                    if (ex instanceof DateTimeException) {
                      continue;
                    } else {
                      throw ex;
                    }
                  }
                  var val2 = this.fieldValues.get(field);
                  if (val1 !== val2) {
                    throw new DateTimeException("Conflict found: Field " + field + " " + val1 + " differs from " + field + " " + val2 + " derived from " + date);
                  }
                }
              }
            }
          }
        }
      };
      _proto._mergeTime = function _mergeTime(resolverStyle) {
        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {
          var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            if (resolverStyle === ResolverStyle.SMART && ch === 0)
              ;
            else {
              ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);
            }
          }
          this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);
        }
        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {
          var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            if (resolverStyle === ResolverStyle.SMART && _ch === 0)
              ;
            else {
              ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);
            }
          }
          this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);
        }
        if (resolverStyle !== ResolverStyle.LENIENT) {
          if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {
            ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));
          }
          if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
            ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));
          }
        }
        if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
          var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);
          var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);
          this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);
        }
        if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {
          var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.NANO_OF_DAY.checkValidValue(nod);
          }
          this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1e9));
          this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1e9));
        }
        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {
          var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.MICRO_OF_DAY.checkValidValue(cod);
          }
          this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1e6));
          this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1e6));
        }
        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {
          var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.MILLI_OF_DAY.checkValidValue(lod);
          }
          this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1e3));
          this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1e3));
        }
        if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {
          var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.SECOND_OF_DAY.checkValidValue(sod);
          }
          this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));
          this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));
          this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));
        }
        if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {
          var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.MINUTE_OF_DAY.checkValidValue(mod);
          }
          this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));
          this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));
        }
        if (resolverStyle !== ResolverStyle.LENIENT) {
          if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
            ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));
          }
          if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
            ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));
          }
        }
        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
          var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
          var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);
          this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1e3 + MathUtil.intMod(cos, 1e3));
        }
        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
          var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
          this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1e3));
          this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
        }
        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
          var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
          this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1e6));
          this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
        }
        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
          var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
          this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1e3);
        } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
          var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
          this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1e6);
        }
      };
      _proto._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {
        var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);
        var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);
        var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);
        var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
        if (hod == null) {
          return;
        }
        if (moh == null && (som != null || nos != null)) {
          return;
        }
        if (moh != null && som == null && nos != null) {
          return;
        }
        if (resolverStyle !== ResolverStyle.LENIENT) {
          if (hod != null) {
            if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {
              hod = 0;
              this.excessDays = Period.ofDays(1);
            }
            var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);
            if (moh != null) {
              var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);
              if (som != null) {
                var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);
                if (nos != null) {
                  var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);
                  this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));
                } else {
                  this._addObject(LocalTime.of(hodVal, mohVal, somVal));
                }
              } else {
                if (nos == null) {
                  this._addObject(LocalTime.of(hodVal, mohVal));
                }
              }
            } else {
              if (som == null && nos == null) {
                this._addObject(LocalTime.of(hodVal, 0));
              }
            }
          }
        } else {
          if (hod != null) {
            var _hodVal = hod;
            if (moh != null) {
              if (som != null) {
                if (nos == null) {
                  nos = 0;
                }
                var totalNanos = MathUtil.safeMultiply(_hodVal, 36e11);
                totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 6e10));
                totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1e9));
                totalNanos = MathUtil.safeAdd(totalNanos, nos);
                var excessDays = MathUtil.floorDiv(totalNanos, 864e11);
                var nod = MathUtil.floorMod(totalNanos, 864e11);
                this._addObject(LocalTime.ofNanoOfDay(nod));
                this.excessDays = Period.ofDays(excessDays);
              } else {
                var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);
                totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));
                var _excessDays = MathUtil.floorDiv(totalSecs, 86400);
                var sod = MathUtil.floorMod(totalSecs, 86400);
                this._addObject(LocalTime.ofSecondOfDay(sod));
                this.excessDays = Period.ofDays(_excessDays);
              }
            } else {
              var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));
              _hodVal = MathUtil.floorMod(_hodVal, 24);
              this._addObject(LocalTime.of(_hodVal, 0));
              this.excessDays = Period.ofDays(_excessDays2);
            }
          }
        }
        this.fieldValues.remove(ChronoField.HOUR_OF_DAY);
        this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);
        this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);
        this.fieldValues.remove(ChronoField.NANO_OF_SECOND);
      };
      _proto._addObject = function _addObject(dateOrTime) {
        if (dateOrTime instanceof ChronoLocalDate) {
          this.date = dateOrTime;
        } else if (dateOrTime instanceof LocalTime) {
          this.time = dateOrTime;
        }
      };
      _proto._resolveInstant = function _resolveInstant() {
        if (this.date != null && this.time != null) {
          var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);
          if (offsetSecs != null) {
            var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
            var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);
            this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);
          } else if (this.zone != null) {
            var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);
            this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);
          }
        }
      };
      _proto.build = function build(type2) {
        return type2.queryFrom(this);
      };
      _proto.isSupported = function isSupported(field) {
        if (field == null) {
          return false;
        }
        return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== void 0 || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        var value = this.getFieldValue0(field);
        if (value == null) {
          if (this.date != null && this.date.isSupported(field)) {
            return this.date.getLong(field);
          }
          if (this.time != null && this.time.isSupported(field)) {
            return this.time.getLong(field);
          }
          throw new DateTimeException("Field not found: " + field);
        }
        return value;
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.zoneId()) {
          return this.zone;
        } else if (_query === TemporalQueries.chronology()) {
          return this.chrono;
        } else if (_query === TemporalQueries.localDate()) {
          return this.date != null ? LocalDate.from(this.date) : null;
        } else if (_query === TemporalQueries.localTime()) {
          return this.time;
        } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
          return _query.queryFrom(this);
        } else if (_query === TemporalQueries.precision()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      return DateTimeBuilder2;
    }(TemporalAccessor);
    DateTimeParseContext = function() {
      function DateTimeParseContext2() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof DateTimeParseContext2) {
            this._constructorSelf.apply(this, arguments);
            return;
          } else {
            this._constructorFormatter.apply(this, arguments);
          }
        } else {
          this._constructorParam.apply(this, arguments);
        }
        this._caseSensitive = true;
        this._strict = true;
        this._parsed = [new Parsed(this)];
      }
      var _proto = DateTimeParseContext2.prototype;
      _proto._constructorParam = function _constructorParam(locale, symbols, chronology) {
        this._locale = locale;
        this._symbols = symbols;
        this._overrideChronology = chronology;
      };
      _proto._constructorFormatter = function _constructorFormatter(formatter) {
        this._locale = formatter.locale();
        this._symbols = formatter.decimalStyle();
        this._overrideChronology = formatter.chronology();
      };
      _proto._constructorSelf = function _constructorSelf(other) {
        this._locale = other._locale;
        this._symbols = other._symbols;
        this._overrideChronology = other._overrideChronology;
        this._overrideZone = other._overrideZone;
        this._caseSensitive = other._caseSensitive;
        this._strict = other._strict;
        this._parsed = [new Parsed(this)];
      };
      _proto.copy = function copy() {
        return new DateTimeParseContext2(this);
      };
      _proto.symbols = function symbols() {
        return this._symbols;
      };
      _proto.isStrict = function isStrict() {
        return this._strict;
      };
      _proto.setStrict = function setStrict(strict) {
        this._strict = strict;
      };
      _proto.locale = function locale() {
        return this._locale;
      };
      _proto.setLocale = function setLocale(locale) {
        this._locale = locale;
      };
      _proto.startOptional = function startOptional() {
        this._parsed.push(this.currentParsed().copy());
      };
      _proto.endOptional = function endOptional(successful) {
        if (successful) {
          this._parsed.splice(this._parsed.length - 2, 1);
        } else {
          this._parsed.splice(this._parsed.length - 1, 1);
        }
      };
      _proto.isCaseSensitive = function isCaseSensitive() {
        return this._caseSensitive;
      };
      _proto.setCaseSensitive = function setCaseSensitive(caseSensitive) {
        this._caseSensitive = caseSensitive;
      };
      _proto.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {
        if (offset1 + length > cs1.length || offset2 + length > cs2.length) {
          return false;
        }
        if (!this.isCaseSensitive()) {
          cs1 = cs1.toLowerCase();
          cs2 = cs2.toLowerCase();
        }
        for (var i = 0; i < length; i++) {
          var ch1 = cs1[offset1 + i];
          var ch2 = cs2[offset2 + i];
          if (ch1 !== ch2) {
            return false;
          }
        }
        return true;
      };
      _proto.charEquals = function charEquals(ch1, ch2) {
        if (this.isCaseSensitive()) {
          return ch1 === ch2;
        }
        return this.charEqualsIgnoreCase(ch1, ch2);
      };
      _proto.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {
        return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();
      };
      _proto.setParsedField = function setParsedField(field, value, errorPos, successPos) {
        var currentParsedFieldValues = this.currentParsed().fieldValues;
        var old = currentParsedFieldValues.get(field);
        currentParsedFieldValues.set(field, value);
        return old != null && old !== value ? ~errorPos : successPos;
      };
      _proto.setParsedZone = function setParsedZone(zone) {
        requireNonNull(zone, "zone");
        this.currentParsed().zone = zone;
      };
      _proto.getParsed = function getParsed(field) {
        return this.currentParsed().fieldValues.get(field);
      };
      _proto.toParsed = function toParsed() {
        return this.currentParsed();
      };
      _proto.currentParsed = function currentParsed() {
        return this._parsed[this._parsed.length - 1];
      };
      _proto.setParsedLeapSecond = function setParsedLeapSecond() {
        this.currentParsed().leapSecond = true;
      };
      _proto.getEffectiveChronology = function getEffectiveChronology() {
        var chrono = this.currentParsed().chrono;
        if (chrono == null) {
          chrono = this._overrideChronology;
          if (chrono == null) {
            chrono = IsoChronology.INSTANCE;
          }
        }
        return chrono;
      };
      return DateTimeParseContext2;
    }();
    Parsed = function(_Temporal) {
      _inheritsLoose(Parsed2, _Temporal);
      function Parsed2(dateTimeParseContext) {
        var _this;
        _this = _Temporal.call(this) || this;
        _this.chrono = null;
        _this.zone = null;
        _this.fieldValues = new EnumMap();
        _this.leapSecond = false;
        _this.dateTimeParseContext = dateTimeParseContext;
        return _this;
      }
      var _proto2 = Parsed2.prototype;
      _proto2.copy = function copy() {
        var cloned = new Parsed2();
        cloned.chrono = this.chrono;
        cloned.zone = this.zone;
        cloned.fieldValues.putAll(this.fieldValues);
        cloned.leapSecond = this.leapSecond;
        cloned.dateTimeParseContext = this.dateTimeParseContext;
        return cloned;
      };
      _proto2.toString = function toString() {
        return this.fieldValues + ", " + this.chrono + ", " + this.zone;
      };
      _proto2.isSupported = function isSupported(field) {
        return this.fieldValues.containsKey(field);
      };
      _proto2.get = function get(field) {
        var val = this.fieldValues.get(field);
        assert(val != null);
        return val;
      };
      _proto2.query = function query(_query) {
        if (_query === TemporalQueries.chronology()) {
          return this.chrono;
        }
        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
          return this.zone;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto2.toBuilder = function toBuilder() {
        var builder = new DateTimeBuilder();
        builder.fieldValues.putAll(this.fieldValues);
        builder.chrono = this.dateTimeParseContext.getEffectiveChronology();
        if (this.zone != null) {
          builder.zone = this.zone;
        } else {
          builder.zone = this.overrideZone;
        }
        builder.leapSecond = this.leapSecond;
        builder.excessDays = this.excessDays;
        return builder;
      };
      return Parsed2;
    }(Temporal);
    DateTimePrintContext = function() {
      function DateTimePrintContext2(temporal, localeOrFormatter, symbols) {
        if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {
          this._temporal = DateTimePrintContext2.adjust(temporal, localeOrFormatter);
          this._locale = localeOrFormatter.locale();
          this._symbols = localeOrFormatter.decimalStyle();
        } else {
          this._temporal = temporal;
          this._locale = localeOrFormatter;
          this._symbols = symbols;
        }
        this._optional = 0;
      }
      DateTimePrintContext2.adjust = function adjust(temporal, formatter) {
        return temporal;
      };
      var _proto = DateTimePrintContext2.prototype;
      _proto.symbols = function symbols() {
        return this._symbols;
      };
      _proto.startOptional = function startOptional() {
        this._optional++;
      };
      _proto.endOptional = function endOptional() {
        this._optional--;
      };
      _proto.getValueQuery = function getValueQuery(query) {
        var result = this._temporal.query(query);
        if (result == null && this._optional === 0) {
          throw new DateTimeException("Unable to extract value: " + this._temporal);
        }
        return result;
      };
      _proto.getValue = function getValue(field) {
        try {
          return this._temporal.getLong(field);
        } catch (ex) {
          if (ex instanceof DateTimeException && this._optional > 0) {
            return null;
          }
          throw ex;
        }
      };
      _proto.temporal = function temporal() {
        return this._temporal;
      };
      _proto.locale = function locale() {
        return this._locale;
      };
      _proto.setDateTime = function setDateTime(temporal) {
        this._temporal = temporal;
      };
      _proto.setLocale = function setLocale(locale) {
        this._locale = locale;
      };
      return DateTimePrintContext2;
    }();
    IsoFields = {};
    QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];
    Field = function(_TemporalField) {
      _inheritsLoose(Field2, _TemporalField);
      function Field2() {
        return _TemporalField.apply(this, arguments) || this;
      }
      var _proto = Field2.prototype;
      _proto.isDateBased = function isDateBased() {
        return true;
      };
      _proto.isTimeBased = function isTimeBased() {
        return false;
      };
      _proto._isIso = function _isIso() {
        return true;
      };
      Field2._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {
        var wby = Field2._getWeekBasedYear(date);
        return ValueRange.of(1, Field2._getWeekRangeByYear(wby));
      };
      Field2._getWeekRangeByYear = function _getWeekRangeByYear(wby) {
        var date = LocalDate.of(wby, 1, 1);
        if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {
          return 53;
        }
        return 52;
      };
      Field2._getWeek = function _getWeek(date) {
        var dow0 = date.dayOfWeek().ordinal();
        var doy0 = date.dayOfYear() - 1;
        var doyThu0 = doy0 + (3 - dow0);
        var alignedWeek = MathUtil.intDiv(doyThu0, 7);
        var firstThuDoy0 = doyThu0 - alignedWeek * 7;
        var firstMonDoy0 = firstThuDoy0 - 3;
        if (firstMonDoy0 < -3) {
          firstMonDoy0 += 7;
        }
        if (doy0 < firstMonDoy0) {
          return Field2._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();
        }
        var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;
        if (week === 53) {
          if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {
            week = 1;
          }
        }
        return week;
      };
      Field2._getWeekBasedYear = function _getWeekBasedYear(date) {
        var year = date.year();
        var doy = date.dayOfYear();
        if (doy <= 3) {
          var dow = date.dayOfWeek().ordinal();
          if (doy - dow < -2) {
            year--;
          }
        } else if (doy >= 363) {
          var _dow = date.dayOfWeek().ordinal();
          doy = doy - 363 - (date.isLeapYear() ? 1 : 0);
          if (doy - _dow >= 0) {
            year++;
          }
        }
        return year;
      };
      _proto.displayName = function displayName() {
        return this.toString();
      };
      _proto.resolve = function resolve() {
        return null;
      };
      _proto.name = function name3() {
        return this.toString();
      };
      return Field2;
    }(TemporalField);
    DAY_OF_QUARTER_FIELD = function(_Field) {
      _inheritsLoose(DAY_OF_QUARTER_FIELD2, _Field);
      function DAY_OF_QUARTER_FIELD2() {
        return _Field.apply(this, arguments) || this;
      }
      var _proto2 = DAY_OF_QUARTER_FIELD2.prototype;
      _proto2.toString = function toString() {
        return "DayOfQuarter";
      };
      _proto2.baseUnit = function baseUnit() {
        return ChronoUnit.DAYS;
      };
      _proto2.rangeUnit = function rangeUnit() {
        return QUARTER_YEARS;
      };
      _proto2.range = function range() {
        return ValueRange.of(1, 90, 92);
      };
      _proto2.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);
      };
      _proto2.rangeRefinedBy = function rangeRefinedBy(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: DayOfQuarter");
        }
        var qoy = temporal.getLong(QUARTER_OF_YEAR);
        if (qoy === 1) {
          var year = temporal.getLong(ChronoField.YEAR);
          return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);
        } else if (qoy === 2) {
          return ValueRange.of(1, 91);
        } else if (qoy === 3 || qoy === 4) {
          return ValueRange.of(1, 92);
        }
        return this.range();
      };
      _proto2.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: DayOfQuarter");
        }
        var doy = temporal.get(ChronoField.DAY_OF_YEAR);
        var moy = temporal.get(ChronoField.MONTH_OF_YEAR);
        var year = temporal.getLong(ChronoField.YEAR);
        return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];
      };
      _proto2.adjustInto = function adjustInto(temporal, newValue) {
        var curValue = this.getFrom(temporal);
        this.range().checkValidValue(newValue, this);
        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));
      };
      _proto2.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
        var yearLong = fieldValues.get(ChronoField.YEAR);
        var qoyLong = fieldValues.get(QUARTER_OF_YEAR);
        if (yearLong == null || qoyLong == null) {
          return null;
        }
        var y = ChronoField.YEAR.checkValidIntValue(yearLong);
        var doq = fieldValues.get(DAY_OF_QUARTER);
        var date;
        if (resolverStyle === ResolverStyle.LENIENT) {
          var qoy = qoyLong;
          date = LocalDate.of(y, 1, 1);
          date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));
          date = date.plusDays(MathUtil.safeSubtract(doq, 1));
        } else {
          var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);
          if (resolverStyle === ResolverStyle.STRICT) {
            var max = 92;
            if (_qoy === 1) {
              max = IsoChronology.isLeapYear(y) ? 91 : 90;
            } else if (_qoy === 2) {
              max = 91;
            }
            ValueRange.of(1, max).checkValidValue(doq, this);
          } else {
            this.range().checkValidValue(doq, this);
          }
          date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);
        }
        fieldValues.remove(this);
        fieldValues.remove(ChronoField.YEAR);
        fieldValues.remove(QUARTER_OF_YEAR);
        return date;
      };
      return DAY_OF_QUARTER_FIELD2;
    }(Field);
    QUARTER_OF_YEAR_FIELD = function(_Field2) {
      _inheritsLoose(QUARTER_OF_YEAR_FIELD2, _Field2);
      function QUARTER_OF_YEAR_FIELD2() {
        return _Field2.apply(this, arguments) || this;
      }
      var _proto3 = QUARTER_OF_YEAR_FIELD2.prototype;
      _proto3.toString = function toString() {
        return "QuarterOfYear";
      };
      _proto3.baseUnit = function baseUnit() {
        return QUARTER_YEARS;
      };
      _proto3.rangeUnit = function rangeUnit() {
        return ChronoUnit.YEARS;
      };
      _proto3.range = function range() {
        return ValueRange.of(1, 4);
      };
      _proto3.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);
      };
      _proto3.rangeRefinedBy = function rangeRefinedBy(temporal) {
        return this.range();
      };
      _proto3.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: QuarterOfYear");
        }
        var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);
        return MathUtil.intDiv(moy + 2, 3);
      };
      _proto3.adjustInto = function adjustInto(temporal, newValue) {
        var curValue = this.getFrom(temporal);
        this.range().checkValidValue(newValue, this);
        return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);
      };
      return QUARTER_OF_YEAR_FIELD2;
    }(Field);
    WEEK_OF_WEEK_BASED_YEAR_FIELD = function(_Field3) {
      _inheritsLoose(WEEK_OF_WEEK_BASED_YEAR_FIELD2, _Field3);
      function WEEK_OF_WEEK_BASED_YEAR_FIELD2() {
        return _Field3.apply(this, arguments) || this;
      }
      var _proto4 = WEEK_OF_WEEK_BASED_YEAR_FIELD2.prototype;
      _proto4.toString = function toString() {
        return "WeekOfWeekBasedYear";
      };
      _proto4.baseUnit = function baseUnit() {
        return ChronoUnit.WEEKS;
      };
      _proto4.rangeUnit = function rangeUnit() {
        return WEEK_BASED_YEARS;
      };
      _proto4.range = function range() {
        return ValueRange.of(1, 52, 53);
      };
      _proto4.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
      };
      _proto4.rangeRefinedBy = function rangeRefinedBy(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekOfWeekBasedYear");
        }
        return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));
      };
      _proto4.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekOfWeekBasedYear");
        }
        return Field._getWeek(LocalDate.from(temporal));
      };
      _proto4.adjustInto = function adjustInto(temporal, newValue) {
        this.range().checkValidValue(newValue, this);
        return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);
      };
      _proto4.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
        var wbyLong = fieldValues.get(WEEK_BASED_YEAR);
        var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);
        if (wbyLong == null || dowLong == null) {
          return null;
        }
        var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);
        var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);
        var date;
        if (resolverStyle === ResolverStyle.LENIENT) {
          var dow = dowLong;
          var weeks = 0;
          if (dow > 7) {
            weeks = MathUtil.intDiv(dow - 1, 7);
            dow = MathUtil.intMod(dow - 1, 7) + 1;
          } else if (dow < 1) {
            weeks = MathUtil.intDiv(dow, 7) - 1;
            dow = MathUtil.intMod(dow, 7) + 7;
          }
          date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);
        } else {
          var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);
          if (resolverStyle === ResolverStyle.STRICT) {
            var temp = LocalDate.of(wby, 1, 4);
            var range = Field._getWeekRangeByLocalDate(temp);
            range.checkValidValue(wowby, this);
          } else {
            this.range().checkValidValue(wowby, this);
          }
          date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);
        }
        fieldValues.remove(this);
        fieldValues.remove(WEEK_BASED_YEAR);
        fieldValues.remove(ChronoField.DAY_OF_WEEK);
        return date;
      };
      _proto4.displayName = function displayName() {
        return "Week";
      };
      return WEEK_OF_WEEK_BASED_YEAR_FIELD2;
    }(Field);
    WEEK_BASED_YEAR_FIELD = function(_Field4) {
      _inheritsLoose(WEEK_BASED_YEAR_FIELD2, _Field4);
      function WEEK_BASED_YEAR_FIELD2() {
        return _Field4.apply(this, arguments) || this;
      }
      var _proto5 = WEEK_BASED_YEAR_FIELD2.prototype;
      _proto5.toString = function toString() {
        return "WeekBasedYear";
      };
      _proto5.baseUnit = function baseUnit() {
        return WEEK_BASED_YEARS;
      };
      _proto5.rangeUnit = function rangeUnit() {
        return ChronoUnit.FOREVER;
      };
      _proto5.range = function range() {
        return ChronoField.YEAR.range();
      };
      _proto5.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
      };
      _proto5.rangeRefinedBy = function rangeRefinedBy(temporal) {
        return ChronoField.YEAR.range();
      };
      _proto5.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekBasedYear");
        }
        return Field._getWeekBasedYear(LocalDate.from(temporal));
      };
      _proto5.adjustInto = function adjustInto(temporal, newValue) {
        if (this.isSupportedBy(temporal) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekBasedYear");
        }
        var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);
        var date = LocalDate.from(temporal);
        var dow = date.get(ChronoField.DAY_OF_WEEK);
        var week = Field._getWeek(date);
        if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {
          week = 52;
        }
        var resolved = LocalDate.of(newWby, 1, 4);
        var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;
        resolved = resolved.plusDays(days);
        return temporal.with(resolved);
      };
      return WEEK_BASED_YEAR_FIELD2;
    }(Field);
    Unit = function(_TemporalUnit) {
      _inheritsLoose(Unit2, _TemporalUnit);
      function Unit2(name3, estimatedDuration) {
        var _this;
        _this = _TemporalUnit.call(this) || this;
        _this._name = name3;
        _this._duration = estimatedDuration;
        return _this;
      }
      var _proto6 = Unit2.prototype;
      _proto6.duration = function duration() {
        return this._duration;
      };
      _proto6.isDurationEstimated = function isDurationEstimated() {
        return true;
      };
      _proto6.isDateBased = function isDateBased() {
        return true;
      };
      _proto6.isTimeBased = function isTimeBased() {
        return false;
      };
      _proto6.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.EPOCH_DAY);
      };
      _proto6.addTo = function addTo(temporal, periodToAdd) {
        switch (this) {
          case WEEK_BASED_YEARS: {
            var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);
            return temporal.with(WEEK_BASED_YEAR, added);
          }
          case QUARTER_YEARS:
            return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);
          default:
            throw new IllegalStateException("Unreachable");
        }
      };
      _proto6.between = function between(temporal1, temporal2) {
        switch (this) {
          case WEEK_BASED_YEARS:
            return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));
          case QUARTER_YEARS:
            return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);
          default:
            throw new IllegalStateException("Unreachable");
        }
      };
      _proto6.toString = function toString() {
        return this._name;
      };
      return Unit2;
    }(TemporalUnit);
    DAY_OF_QUARTER = null;
    QUARTER_OF_YEAR = null;
    WEEK_OF_WEEK_BASED_YEAR = null;
    WEEK_BASED_YEAR = null;
    WEEK_BASED_YEARS = null;
    QUARTER_YEARS = null;
    DecimalStyle = function() {
      function DecimalStyle2(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {
        this._zeroDigit = zeroChar;
        this._zeroDigitCharCode = zeroChar.charCodeAt(0);
        this._positiveSign = positiveSignChar;
        this._negativeSign = negativeSignChar;
        this._decimalSeparator = decimalPointChar;
      }
      var _proto = DecimalStyle2.prototype;
      _proto.positiveSign = function positiveSign() {
        return this._positiveSign;
      };
      _proto.withPositiveSign = function withPositiveSign(positiveSign) {
        if (positiveSign === this._positiveSign) {
          return this;
        }
        return new DecimalStyle2(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);
      };
      _proto.negativeSign = function negativeSign() {
        return this._negativeSign;
      };
      _proto.withNegativeSign = function withNegativeSign(negativeSign) {
        if (negativeSign === this._negativeSign) {
          return this;
        }
        return new DecimalStyle2(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);
      };
      _proto.zeroDigit = function zeroDigit() {
        return this._zeroDigit;
      };
      _proto.withZeroDigit = function withZeroDigit(zeroDigit) {
        if (zeroDigit === this._zeroDigit) {
          return this;
        }
        return new DecimalStyle2(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);
      };
      _proto.decimalSeparator = function decimalSeparator() {
        return this._decimalSeparator;
      };
      _proto.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {
        if (decimalSeparator === this._decimalSeparator) {
          return this;
        }
        return new DecimalStyle2(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);
      };
      _proto.convertToDigit = function convertToDigit(char) {
        var val = char.charCodeAt(0) - this._zeroDigitCharCode;
        return val >= 0 && val <= 9 ? val : -1;
      };
      _proto.convertNumberToI18N = function convertNumberToI18N(numericText) {
        if (this._zeroDigit === "0") {
          return numericText;
        }
        var diff = this._zeroDigitCharCode - "0".charCodeAt(0);
        var convertedText = "";
        for (var i = 0; i < numericText.length; i++) {
          convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);
        }
        return convertedText;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof DecimalStyle2) {
          return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;
      };
      _proto.toString = function toString() {
        return "DecimalStyle[" + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + "]";
      };
      DecimalStyle2.of = function of() {
        throw new Error("not yet supported");
      };
      DecimalStyle2.availableLocales = function availableLocales() {
        throw new Error("not yet supported");
      };
      return DecimalStyle2;
    }();
    DecimalStyle.STANDARD = new DecimalStyle("0", "+", "-", ".");
    SignStyle = function(_Enum) {
      _inheritsLoose(SignStyle2, _Enum);
      function SignStyle2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = SignStyle2.prototype;
      _proto.parse = function parse2(positive, strict, fixedWidth) {
        switch (this) {
          case SignStyle2.NORMAL:
            return !positive || !strict;
          case SignStyle2.ALWAYS:
          case SignStyle2.EXCEEDS_PAD:
            return true;
          default:
            return !strict && !fixedWidth;
        }
      };
      return SignStyle2;
    }(Enum);
    SignStyle.NORMAL = new SignStyle("NORMAL");
    SignStyle.NEVER = new SignStyle("NEVER");
    SignStyle.ALWAYS = new SignStyle("ALWAYS");
    SignStyle.EXCEEDS_PAD = new SignStyle("EXCEEDS_PAD");
    SignStyle.NOT_NEGATIVE = new SignStyle("NOT_NEGATIVE");
    TextStyle = function(_Enum) {
      _inheritsLoose(TextStyle2, _Enum);
      function TextStyle2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = TextStyle2.prototype;
      _proto.isStandalone = function isStandalone() {
        switch (this) {
          case TextStyle2.FULL_STANDALONE:
          case TextStyle2.SHORT_STANDALONE:
          case TextStyle2.NARROW_STANDALONE:
            return true;
          default:
            return false;
        }
      };
      _proto.asStandalone = function asStandalone() {
        switch (this) {
          case TextStyle2.FULL:
            return TextStyle2.FULL_STANDALONE;
          case TextStyle2.SHORT:
            return TextStyle2.SHORT_STANDALONE;
          case TextStyle2.NARROW:
            return TextStyle2.NARROW_STANDALONE;
          default:
            return this;
        }
      };
      _proto.asNormal = function asNormal() {
        switch (this) {
          case TextStyle2.FULL_STANDALONE:
            return TextStyle2.FULL;
          case TextStyle2.SHORT_STANDALONE:
            return TextStyle2.SHORT;
          case TextStyle2.NARROW_STANDALONE:
            return TextStyle2.NARROW;
          default:
            return this;
        }
      };
      return TextStyle2;
    }(Enum);
    TextStyle.FULL = new TextStyle("FULL");
    TextStyle.FULL_STANDALONE = new TextStyle("FULL_STANDALONE");
    TextStyle.SHORT = new TextStyle("SHORT");
    TextStyle.SHORT_STANDALONE = new TextStyle("SHORT_STANDALONE");
    TextStyle.NARROW = new TextStyle("NARROW");
    TextStyle.NARROW_STANDALONE = new TextStyle("NARROW_STANDALONE");
    CharLiteralPrinterParser = function() {
      function CharLiteralPrinterParser2(literal) {
        if (literal.length > 1) {
          throw new IllegalArgumentException('invalid literal, too long: "' + literal + '"');
        }
        this._literal = literal;
      }
      var _proto = CharLiteralPrinterParser2.prototype;
      _proto.print = function print(context, buf) {
        buf.append(this._literal);
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        if (position === length) {
          return ~position;
        }
        var ch = text.charAt(position);
        if (context.charEquals(this._literal, ch) === false) {
          return ~position;
        }
        return position + this._literal.length;
      };
      _proto.toString = function toString() {
        if (this._literal === "'") {
          return "''";
        }
        return "'" + this._literal + "'";
      };
      return CharLiteralPrinterParser2;
    }();
    CompositePrinterParser = function() {
      function CompositePrinterParser2(printerParsers, optional) {
        this._printerParsers = printerParsers;
        this._optional = optional;
      }
      var _proto = CompositePrinterParser2.prototype;
      _proto.withOptional = function withOptional(optional) {
        if (optional === this._optional) {
          return this;
        }
        return new CompositePrinterParser2(this._printerParsers, optional);
      };
      _proto.print = function print(context, buf) {
        var length = buf.length();
        if (this._optional) {
          context.startOptional();
        }
        try {
          for (var i = 0; i < this._printerParsers.length; i++) {
            var pp = this._printerParsers[i];
            if (pp.print(context, buf) === false) {
              buf.setLength(length);
              return true;
            }
          }
        } finally {
          if (this._optional) {
            context.endOptional();
          }
        }
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        if (this._optional) {
          context.startOptional();
          var pos = position;
          for (var i = 0; i < this._printerParsers.length; i++) {
            var pp = this._printerParsers[i];
            pos = pp.parse(context, text, pos);
            if (pos < 0) {
              context.endOptional(false);
              return position;
            }
          }
          context.endOptional(true);
          return pos;
        } else {
          for (var _i = 0; _i < this._printerParsers.length; _i++) {
            var _pp = this._printerParsers[_i];
            position = _pp.parse(context, text, position);
            if (position < 0) {
              break;
            }
          }
          return position;
        }
      };
      _proto.toString = function toString() {
        var buf = "";
        if (this._printerParsers != null) {
          buf += this._optional ? "[" : "(";
          for (var i = 0; i < this._printerParsers.length; i++) {
            var pp = this._printerParsers[i];
            buf += pp.toString();
          }
          buf += this._optional ? "]" : ")";
        }
        return buf;
      };
      return CompositePrinterParser2;
    }();
    FractionPrinterParser = function() {
      function FractionPrinterParser2(field, minWidth, maxWidth, decimalPoint) {
        requireNonNull(field, "field");
        if (field.range().isFixed() === false) {
          throw new IllegalArgumentException("Field must have a fixed set of values: " + field);
        }
        if (minWidth < 0 || minWidth > 9) {
          throw new IllegalArgumentException("Minimum width must be from 0 to 9 inclusive but was " + minWidth);
        }
        if (maxWidth < 1 || maxWidth > 9) {
          throw new IllegalArgumentException("Maximum width must be from 1 to 9 inclusive but was " + maxWidth);
        }
        if (maxWidth < minWidth) {
          throw new IllegalArgumentException("Maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
        }
        this.field = field;
        this.minWidth = minWidth;
        this.maxWidth = maxWidth;
        this.decimalPoint = decimalPoint;
      }
      var _proto = FractionPrinterParser2.prototype;
      _proto.print = function print(context, buf) {
        var value = context.getValue(this.field);
        if (value === null) {
          return false;
        }
        var symbols = context.symbols();
        if (value === 0) {
          if (this.minWidth > 0) {
            if (this.decimalPoint) {
              buf.append(symbols.decimalSeparator());
            }
            for (var i = 0; i < this.minWidth; i++) {
              buf.append(symbols.zeroDigit());
            }
          }
        } else {
          var fraction = this.convertToFraction(value, symbols.zeroDigit());
          var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);
          fraction = fraction.substr(0, outputScale);
          if (fraction * 1 > 0) {
            while (fraction.length > this.minWidth && fraction[fraction.length - 1] === "0") {
              fraction = fraction.substr(0, fraction.length - 1);
            }
          }
          var str = fraction;
          str = symbols.convertNumberToI18N(str);
          if (this.decimalPoint) {
            buf.append(symbols.decimalSeparator());
          }
          buf.append(str);
        }
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var effectiveMin = context.isStrict() ? this.minWidth : 0;
        var effectiveMax = context.isStrict() ? this.maxWidth : 9;
        var length = text.length;
        if (position === length) {
          return effectiveMin > 0 ? ~position : position;
        }
        if (this.decimalPoint) {
          if (text[position] !== context.symbols().decimalSeparator()) {
            return effectiveMin > 0 ? ~position : position;
          }
          position++;
        }
        var minEndPos = position + effectiveMin;
        if (minEndPos > length) {
          return ~position;
        }
        var maxEndPos = Math.min(position + effectiveMax, length);
        var total = 0;
        var pos = position;
        while (pos < maxEndPos) {
          var ch = text.charAt(pos++);
          var digit = context.symbols().convertToDigit(ch);
          if (digit < 0) {
            if (pos < minEndPos) {
              return ~position;
            }
            pos--;
            break;
          }
          total = total * 10 + digit;
        }
        var moveLeft = pos - position;
        var scale = Math.pow(10, moveLeft);
        var value = this.convertFromFraction(total, scale);
        return context.setParsedField(this.field, value, position, pos);
      };
      _proto.convertToFraction = function convertToFraction(value, zeroDigit) {
        var range = this.field.range();
        range.checkValidValue(value, this.field);
        var _min = range.minimum();
        var _range = range.maximum() - _min + 1;
        var _value = value - _min;
        var _scaled = MathUtil.intDiv(_value * 1e9, _range);
        var fraction = "" + _scaled;
        while (fraction.length < 9) {
          fraction = zeroDigit + fraction;
        }
        return fraction;
      };
      _proto.convertFromFraction = function convertFromFraction(total, scale) {
        var range = this.field.range();
        var _min = range.minimum();
        var _range = range.maximum() - _min + 1;
        var _value = MathUtil.intDiv(total * _range, scale);
        return _value;
      };
      _proto.toString = function toString() {
        var decimal = this.decimalPoint ? ",DecimalPoint" : "";
        return "Fraction(" + this.field + "," + this.minWidth + "," + this.maxWidth + decimal + ")";
      };
      return FractionPrinterParser2;
    }();
    MAX_WIDTH$1 = 15;
    EXCEED_POINTS = [0, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
    NumberPrinterParser = function() {
      function NumberPrinterParser2(field, minWidth, maxWidth, signStyle, subsequentWidth) {
        if (subsequentWidth === void 0) {
          subsequentWidth = 0;
        }
        this._field = field;
        this._minWidth = minWidth;
        this._maxWidth = maxWidth;
        this._signStyle = signStyle;
        this._subsequentWidth = subsequentWidth;
      }
      var _proto = NumberPrinterParser2.prototype;
      _proto.field = function field() {
        return this._field;
      };
      _proto.minWidth = function minWidth() {
        return this._minWidth;
      };
      _proto.maxWidth = function maxWidth() {
        return this._maxWidth;
      };
      _proto.signStyle = function signStyle() {
        return this._signStyle;
      };
      _proto.withFixedWidth = function withFixedWidth() {
        if (this._subsequentWidth === -1) {
          return this;
        }
        return new NumberPrinterParser2(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);
      };
      _proto.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
        return new NumberPrinterParser2(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);
      };
      _proto._isFixedWidth = function _isFixedWidth() {
        return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;
      };
      _proto.print = function print(context, buf) {
        var contextValue = context.getValue(this._field);
        if (contextValue == null) {
          return false;
        }
        var value = this._getValue(context, contextValue);
        var symbols = context.symbols();
        var str = "" + Math.abs(value);
        if (str.length > this._maxWidth) {
          throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " exceeds the maximum print width of " + this._maxWidth);
        }
        str = symbols.convertNumberToI18N(str);
        if (value >= 0) {
          switch (this._signStyle) {
            case SignStyle.EXCEEDS_PAD:
              if (this._minWidth < MAX_WIDTH$1 && value >= EXCEED_POINTS[this._minWidth]) {
                buf.append(symbols.positiveSign());
              }
              break;
            case SignStyle.ALWAYS:
              buf.append(symbols.positiveSign());
              break;
          }
        } else {
          switch (this._signStyle) {
            case SignStyle.NORMAL:
            case SignStyle.EXCEEDS_PAD:
            case SignStyle.ALWAYS:
              buf.append(symbols.negativeSign());
              break;
            case SignStyle.NOT_NEGATIVE:
              throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " cannot be negative according to the SignStyle");
          }
        }
        for (var i = 0; i < this._minWidth - str.length; i++) {
          buf.append(symbols.zeroDigit());
        }
        buf.append(str);
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        if (position === length) {
          return ~position;
        }
        assert(position >= 0 && position < length);
        var sign2 = text.charAt(position);
        var negative = false;
        var positive = false;
        if (sign2 === context.symbols().positiveSign()) {
          if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {
            return ~position;
          }
          positive = true;
          position++;
        } else if (sign2 === context.symbols().negativeSign()) {
          if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {
            return ~position;
          }
          negative = true;
          position++;
        } else {
          if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {
            return ~position;
          }
        }
        var effMinWidth = context.isStrict() || this._isFixedWidth() ? this._minWidth : 1;
        var minEndPos = position + effMinWidth;
        if (minEndPos > length) {
          return ~position;
        }
        var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);
        var total = 0;
        var pos = position;
        for (var pass = 0; pass < 2; pass++) {
          var maxEndPos = Math.min(pos + effMaxWidth, length);
          while (pos < maxEndPos) {
            var ch = text.charAt(pos++);
            var digit = context.symbols().convertToDigit(ch);
            if (digit < 0) {
              pos--;
              if (pos < minEndPos) {
                return ~position;
              }
              break;
            }
            if (pos - position > MAX_WIDTH$1) {
              throw new ArithmeticException("number text exceeds length");
            } else {
              total = total * 10 + digit;
            }
          }
          if (this._subsequentWidth > 0 && pass === 0) {
            var parseLen = pos - position;
            effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);
            pos = position;
            total = 0;
          } else {
            break;
          }
        }
        if (negative) {
          if (total === 0 && context.isStrict()) {
            return ~(position - 1);
          }
          if (total !== 0) {
            total = -total;
          }
        } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {
          var _parseLen = pos - position;
          if (positive) {
            if (_parseLen <= this._minWidth) {
              return ~(position - 1);
            }
          } else {
            if (_parseLen > this._minWidth) {
              return ~position;
            }
          }
        }
        return this._setValue(context, total, position, pos);
      };
      _proto._getValue = function _getValue(context, value) {
        return value;
      };
      _proto._setValue = function _setValue(context, value, errorPos, successPos) {
        return context.setParsedField(this._field, value, errorPos, successPos);
      };
      _proto.toString = function toString() {
        if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH$1 && this._signStyle === SignStyle.NORMAL) {
          return "Value(" + this._field + ")";
        }
        if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {
          return "Value(" + this._field + "," + this._minWidth + ")";
        }
        return "Value(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + this._signStyle + ")";
      };
      return NumberPrinterParser2;
    }();
    ReducedPrinterParser = function(_NumberPrinterParser) {
      _inheritsLoose(ReducedPrinterParser2, _NumberPrinterParser);
      function ReducedPrinterParser2(field, width, maxWidth, baseValue, baseDate) {
        var _this;
        _this = _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE) || this;
        if (width < 1 || width > 10) {
          throw new IllegalArgumentException("The width must be from 1 to 10 inclusive but was " + width);
        }
        if (maxWidth < 1 || maxWidth > 10) {
          throw new IllegalArgumentException("The maxWidth must be from 1 to 10 inclusive but was " + maxWidth);
        }
        if (maxWidth < width) {
          throw new IllegalArgumentException("The maxWidth must be greater than the width");
        }
        if (baseDate === null) {
          if (field.range().isValidValue(baseValue) === false) {
            throw new IllegalArgumentException("The base value must be within the range of the field");
          }
          if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {
            throw new DateTimeException("Unable to add printer-parser as the range exceeds the capacity of an int");
          }
        }
        _this._baseValue = baseValue;
        _this._baseDate = baseDate;
        return _this;
      }
      var _proto2 = ReducedPrinterParser2.prototype;
      _proto2._getValue = function _getValue(context, value) {
        var absValue = Math.abs(value);
        var baseValue = this._baseValue;
        if (this._baseDate !== null) {
          context.temporal();
          var chrono = IsoChronology.INSTANCE;
          baseValue = chrono.date(this._baseDate).get(this._field);
        }
        if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {
          return absValue % EXCEED_POINTS[this._minWidth];
        }
        return absValue % EXCEED_POINTS[this._maxWidth];
      };
      _proto2._setValue = function _setValue(context, value, errorPos, successPos) {
        var baseValue = this._baseValue;
        if (this._baseDate != null) {
          var chrono = context.getEffectiveChronology();
          baseValue = chrono.date(this._baseDate).get(this._field);
        }
        var parseLen = successPos - errorPos;
        if (parseLen === this._minWidth && value >= 0) {
          var range = EXCEED_POINTS[this._minWidth];
          var lastPart = baseValue % range;
          var basePart = baseValue - lastPart;
          if (baseValue > 0) {
            value = basePart + value;
          } else {
            value = basePart - value;
          }
          if (value < baseValue) {
            value += range;
          }
        }
        return context.setParsedField(this._field, value, errorPos, successPos);
      };
      _proto2.withFixedWidth = function withFixedWidth() {
        if (this._subsequentWidth === -1) {
          return this;
        }
        return new ReducedPrinterParser2(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate);
      };
      _proto2.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
        return new ReducedPrinterParser2(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);
      };
      _proto2.isFixedWidth = function isFixedWidth(context) {
        if (context.isStrict() === false) {
          return false;
        }
        return _NumberPrinterParser.prototype.isFixedWidth.call(this, context);
      };
      _proto2.toString = function toString() {
        return "ReducedValue(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + (this._baseDate != null ? this._baseDate : this._baseValue) + ")";
      };
      return ReducedPrinterParser2;
    }(NumberPrinterParser);
    PATTERNS = ["+HH", "+HHmm", "+HH:mm", "+HHMM", "+HH:MM", "+HHMMss", "+HH:MM:ss", "+HHMMSS", "+HH:MM:SS"];
    OffsetIdPrinterParser = function() {
      function OffsetIdPrinterParser2(noOffsetText, pattern) {
        requireNonNull(noOffsetText, "noOffsetText");
        requireNonNull(pattern, "pattern");
        this.noOffsetText = noOffsetText;
        this.type = this._checkPattern(pattern);
      }
      var _proto = OffsetIdPrinterParser2.prototype;
      _proto._checkPattern = function _checkPattern(pattern) {
        for (var i = 0; i < PATTERNS.length; i++) {
          if (PATTERNS[i] === pattern) {
            return i;
          }
        }
        throw new IllegalArgumentException("Invalid zone offset pattern: " + pattern);
      };
      _proto.print = function print(context, buf) {
        var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);
        if (offsetSecs == null) {
          return false;
        }
        var totalSecs = MathUtil.safeToInt(offsetSecs);
        if (totalSecs === 0) {
          buf.append(this.noOffsetText);
        } else {
          var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));
          var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));
          var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));
          var bufPos = buf.length();
          var output = absHours;
          buf.append(totalSecs < 0 ? "-" : "+").appendChar(MathUtil.intDiv(absHours, 10) + "0").appendChar(MathUtil.intMod(absHours, 10) + "0");
          if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {
            buf.append(this.type % 2 === 0 ? ":" : "").appendChar(MathUtil.intDiv(absMinutes, 10) + "0").appendChar(absMinutes % 10 + "0");
            output += absMinutes;
            if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {
              buf.append(this.type % 2 === 0 ? ":" : "").appendChar(MathUtil.intDiv(absSeconds, 10) + "0").appendChar(absSeconds % 10 + "0");
              output += absSeconds;
            }
          }
          if (output === 0) {
            buf.setLength(bufPos);
            buf.append(this.noOffsetText);
          }
        }
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        var noOffsetLen = this.noOffsetText.length;
        if (noOffsetLen === 0) {
          if (position === length) {
            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);
          }
        } else {
          if (position === length) {
            return ~position;
          }
          if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {
            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
          }
        }
        var sign2 = text[position];
        if (sign2 === "+" || sign2 === "-") {
          var negative = sign2 === "-" ? -1 : 1;
          var array = [0, 0, 0, 0];
          array[0] = position + 1;
          if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {
            var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));
            return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);
          }
        }
        if (noOffsetLen === 0) {
          return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
        }
        return ~position;
      };
      _proto._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {
        if ((this.type + 3) / 2 < arrayIndex) {
          return false;
        }
        var pos = array[0];
        if (this.type % 2 === 0 && arrayIndex > 1) {
          if (pos + 1 > parseText.length || parseText[pos] !== ":") {
            return required;
          }
          pos++;
        }
        if (pos + 2 > parseText.length) {
          return required;
        }
        var ch1 = parseText[pos++];
        var ch2 = parseText[pos++];
        if (ch1 < "0" || ch1 > "9" || ch2 < "0" || ch2 > "9") {
          return required;
        }
        var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
        if (value < 0 || value > 59) {
          return required;
        }
        array[arrayIndex] = value;
        array[0] = pos;
        return false;
      };
      _proto.toString = function toString() {
        var converted = this.noOffsetText.replace("'", "''");
        return "Offset(" + PATTERNS[this.type] + ",'" + converted + "')";
      };
      return OffsetIdPrinterParser2;
    }();
    OffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser("Z", "+HH:MM:ss");
    OffsetIdPrinterParser.PATTERNS = PATTERNS;
    PadPrinterParserDecorator = function() {
      function PadPrinterParserDecorator2(printerParser, padWidth, padChar) {
        this._printerParser = printerParser;
        this._padWidth = padWidth;
        this._padChar = padChar;
      }
      var _proto = PadPrinterParserDecorator2.prototype;
      _proto.print = function print(context, buf) {
        var preLen = buf.length();
        if (this._printerParser.print(context, buf) === false) {
          return false;
        }
        var len = buf.length() - preLen;
        if (len > this._padWidth) {
          throw new DateTimeException("Cannot print as output of " + len + " characters exceeds pad width of " + this._padWidth);
        }
        for (var i = 0; i < this._padWidth - len; i++) {
          buf.insert(preLen, this._padChar);
        }
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var strict = context.isStrict();
        var caseSensitive = context.isCaseSensitive();
        assert(!(position > text.length));
        assert(position >= 0);
        if (position === text.length) {
          return ~position;
        }
        var endPos = position + this._padWidth;
        if (endPos > text.length) {
          if (strict) {
            return ~position;
          }
          endPos = text.length;
        }
        var pos = position;
        while (pos < endPos && (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {
          pos++;
        }
        text = text.substring(0, endPos);
        var resultPos = this._printerParser.parse(context, text, pos);
        if (resultPos !== endPos && strict) {
          return ~(position + pos);
        }
        return resultPos;
      };
      _proto.toString = function toString() {
        return "Pad(" + this._printerParser + "," + this._padWidth + (this._padChar === " " ? ")" : ",'" + this._padChar + "')");
      };
      return PadPrinterParserDecorator2;
    }();
    SettingsParser = function(_Enum) {
      _inheritsLoose(SettingsParser2, _Enum);
      function SettingsParser2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = SettingsParser2.prototype;
      _proto.print = function print() {
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        switch (this) {
          case SettingsParser2.SENSITIVE:
            context.setCaseSensitive(true);
            break;
          case SettingsParser2.INSENSITIVE:
            context.setCaseSensitive(false);
            break;
          case SettingsParser2.STRICT:
            context.setStrict(true);
            break;
          case SettingsParser2.LENIENT:
            context.setStrict(false);
            break;
        }
        return position;
      };
      _proto.toString = function toString() {
        switch (this) {
          case SettingsParser2.SENSITIVE:
            return "ParseCaseSensitive(true)";
          case SettingsParser2.INSENSITIVE:
            return "ParseCaseSensitive(false)";
          case SettingsParser2.STRICT:
            return "ParseStrict(true)";
          case SettingsParser2.LENIENT:
            return "ParseStrict(false)";
        }
      };
      return SettingsParser2;
    }(Enum);
    SettingsParser.SENSITIVE = new SettingsParser("SENSITIVE");
    SettingsParser.INSENSITIVE = new SettingsParser("INSENSITIVE");
    SettingsParser.STRICT = new SettingsParser("STRICT");
    SettingsParser.LENIENT = new SettingsParser("LENIENT");
    StringLiteralPrinterParser = function() {
      function StringLiteralPrinterParser2(literal) {
        this._literal = literal;
      }
      var _proto = StringLiteralPrinterParser2.prototype;
      _proto.print = function print(context, buf) {
        buf.append(this._literal);
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        assert(!(position > length || position < 0));
        if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {
          return ~position;
        }
        return position + this._literal.length;
      };
      _proto.toString = function toString() {
        var converted = this._literal.replace("'", "''");
        return "'" + converted + "'";
      };
      return StringLiteralPrinterParser2;
    }();
    ZoneRulesProvider = function() {
      function ZoneRulesProvider2() {
      }
      ZoneRulesProvider2.getRules = function getRules(zoneId) {
        throw new DateTimeException("unsupported ZoneId:" + zoneId);
      };
      ZoneRulesProvider2.getAvailableZoneIds = function getAvailableZoneIds() {
        return [];
      };
      return ZoneRulesProvider2;
    }();
    ZoneRegion = function(_ZoneId) {
      _inheritsLoose(ZoneRegion2, _ZoneId);
      ZoneRegion2.ofId = function ofId(zoneId) {
        var rules = ZoneRulesProvider.getRules(zoneId);
        return new ZoneRegion2(zoneId, rules);
      };
      function ZoneRegion2(id, rules) {
        var _this;
        _this = _ZoneId.call(this) || this;
        _this._id = id;
        _this._rules = rules;
        return _this;
      }
      var _proto = ZoneRegion2.prototype;
      _proto.id = function id() {
        return this._id;
      };
      _proto.rules = function rules() {
        return this._rules;
      };
      return ZoneRegion2;
    }(ZoneId);
    ZoneIdPrinterParser = function() {
      function ZoneIdPrinterParser2(query, description) {
        this.query = query;
        this.description = description;
      }
      var _proto = ZoneIdPrinterParser2.prototype;
      _proto.print = function print(context, buf) {
        var zone = context.getValueQuery(this.query);
        if (zone == null) {
          return false;
        }
        buf.append(zone.id());
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        if (position > length) {
          return ~position;
        }
        if (position === length) {
          return ~position;
        }
        var nextChar = text.charAt(position);
        if (nextChar === "+" || nextChar === "-") {
          var newContext = context.copy();
          var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
          if (endPos < 0) {
            return endPos;
          }
          var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);
          var zone = ZoneOffset.ofTotalSeconds(offset);
          context.setParsedZone(zone);
          return endPos;
        } else if (length >= position + 2) {
          var nextNextChar = text.charAt(position + 1);
          if (context.charEquals(nextChar, "U") && context.charEquals(nextNextChar, "T")) {
            if (length >= position + 3 && context.charEquals(text.charAt(position + 2), "C")) {
              return this._parsePrefixedOffset(context, text, position, position + 3);
            }
            return this._parsePrefixedOffset(context, text, position, position + 2);
          } else if (context.charEquals(nextChar, "G") && length >= position + 3 && context.charEquals(nextNextChar, "M") && context.charEquals(text.charAt(position + 2), "T")) {
            return this._parsePrefixedOffset(context, text, position, position + 3);
          }
        }
        if (text.substr(position, 6) === "SYSTEM") {
          context.setParsedZone(ZoneId.systemDefault());
          return position + 6;
        }
        if (context.charEquals(nextChar, "Z")) {
          context.setParsedZone(ZoneOffset.UTC);
          return position + 1;
        }
        var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();
        if (zoneIdTree.size !== availableZoneIds.length) {
          zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);
        }
        var maxParseLength = length - position;
        var treeMap = zoneIdTree.treeMap;
        var parsedZoneId = null;
        var parseLength = 0;
        while (treeMap != null) {
          var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));
          treeMap = treeMap.get(parsedSubZoneId);
          if (treeMap != null && treeMap.isLeaf) {
            parsedZoneId = parsedSubZoneId;
            parseLength = treeMap.length;
          }
        }
        if (parsedZoneId != null) {
          context.setParsedZone(ZoneRegion.ofId(parsedZoneId));
          return position + parseLength;
        }
        return ~position;
      };
      _proto._parsePrefixedOffset = function _parsePrefixedOffset(context, text, prefixPos, position) {
        var prefix = text.substring(prefixPos, position).toUpperCase();
        var newContext = context.copy();
        if (position < text.length && context.charEquals(text.charAt(position), "Z")) {
          context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
          return position;
        }
        var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
        if (endPos < 0) {
          context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
          return position;
        }
        var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);
        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
        context.setParsedZone(ZoneId.ofOffset(prefix, offset));
        return endPos;
      };
      _proto.toString = function toString() {
        return this.description;
      };
      return ZoneIdPrinterParser2;
    }();
    ZoneIdTree = function() {
      ZoneIdTree2.createTreeMap = function createTreeMap(availableZoneIds) {
        var sortedZoneIds = availableZoneIds.sort(function(a, b) {
          return a.length - b.length;
        });
        var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);
        for (var i = 0; i < sortedZoneIds.length; i++) {
          treeMap.add(sortedZoneIds[i]);
        }
        return new ZoneIdTree2(sortedZoneIds.length, treeMap);
      };
      function ZoneIdTree2(size, treeMap) {
        this.size = size;
        this.treeMap = treeMap;
      }
      return ZoneIdTree2;
    }();
    ZoneIdTreeMap = function() {
      function ZoneIdTreeMap2(length, isLeaf) {
        if (length === void 0) {
          length = 0;
        }
        if (isLeaf === void 0) {
          isLeaf = false;
        }
        this.length = length;
        this.isLeaf = isLeaf;
        this._treeMap = {};
      }
      var _proto2 = ZoneIdTreeMap2.prototype;
      _proto2.add = function add(zoneId) {
        var idLength = zoneId.length;
        if (idLength === this.length) {
          this._treeMap[zoneId] = new ZoneIdTreeMap2(idLength, true);
        } else if (idLength > this.length) {
          var subZoneId = zoneId.substr(0, this.length);
          var subTreeMap = this._treeMap[subZoneId];
          if (subTreeMap == null) {
            subTreeMap = new ZoneIdTreeMap2(idLength, false);
            this._treeMap[subZoneId] = subTreeMap;
          }
          subTreeMap.add(zoneId);
        }
      };
      _proto2.get = function get(zoneId) {
        return this._treeMap[zoneId];
      };
      return ZoneIdTreeMap2;
    }();
    zoneIdTree = new ZoneIdTree([]);
    MAX_WIDTH = 15;
    DateTimeFormatterBuilder = function() {
      function DateTimeFormatterBuilder2() {
        this._active = this;
        this._parent = null;
        this._printerParsers = [];
        this._optional = false;
        this._padNextWidth = 0;
        this._padNextChar = null;
        this._valueParserIndex = -1;
      }
      DateTimeFormatterBuilder2._of = function _of(parent, optional) {
        requireNonNull(parent, "parent");
        requireNonNull(optional, "optional");
        var dtFormatterBuilder = new DateTimeFormatterBuilder2();
        dtFormatterBuilder._parent = parent;
        dtFormatterBuilder._optional = optional;
        return dtFormatterBuilder;
      };
      var _proto = DateTimeFormatterBuilder2.prototype;
      _proto.parseCaseSensitive = function parseCaseSensitive() {
        this._appendInternalPrinterParser(SettingsParser.SENSITIVE);
        return this;
      };
      _proto.parseCaseInsensitive = function parseCaseInsensitive() {
        this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);
        return this;
      };
      _proto.parseStrict = function parseStrict() {
        this._appendInternalPrinterParser(SettingsParser.STRICT);
        return this;
      };
      _proto.parseLenient = function parseLenient() {
        this._appendInternalPrinterParser(SettingsParser.LENIENT);
        return this;
      };
      _proto.appendValue = function appendValue() {
        if (arguments.length === 1) {
          return this._appendValue1.apply(this, arguments);
        } else if (arguments.length === 2) {
          return this._appendValue2.apply(this, arguments);
        } else {
          return this._appendValue4.apply(this, arguments);
        }
      };
      _proto._appendValue1 = function _appendValue1(field) {
        requireNonNull(field);
        this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));
        return this;
      };
      _proto._appendValue2 = function _appendValue2(field, width) {
        requireNonNull(field);
        if (width < 1 || width > MAX_WIDTH) {
          throw new IllegalArgumentException("The width must be from 1 to " + MAX_WIDTH + " inclusive but was " + width);
        }
        var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {
        requireNonNull(field);
        requireNonNull(signStyle);
        if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {
          return this._appendValue2(field, maxWidth);
        }
        if (minWidth < 1 || minWidth > MAX_WIDTH) {
          throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + minWidth);
        }
        if (maxWidth < 1 || maxWidth > MAX_WIDTH) {
          throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + maxWidth);
        }
        if (maxWidth < minWidth) {
          throw new IllegalArgumentException("The maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
        }
        var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto.appendValueReduced = function appendValueReduced() {
        if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {
          return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);
        } else {
          return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);
        }
      };
      _proto._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {
        requireNonNull(field, "field");
        var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {
        requireNonNull(field, "field");
        requireNonNull(baseDate, "baseDate");
        requireInstance(baseDate, ChronoLocalDate, "baseDate");
        var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto._appendValuePrinterParser = function _appendValuePrinterParser(pp) {
        assert(pp != null);
        if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {
          var activeValueParser = this._active._valueParserIndex;
          var basePP = this._active._printerParsers[activeValueParser];
          if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {
            basePP = basePP.withSubsequentWidth(pp.maxWidth());
            this._appendInternal(pp.withFixedWidth());
            this._active._valueParserIndex = activeValueParser;
          } else {
            basePP = basePP.withFixedWidth();
            this._active._valueParserIndex = this._appendInternal(pp);
          }
          this._active._printerParsers[activeValueParser] = basePP;
        } else {
          this._active._valueParserIndex = this._appendInternal(pp);
        }
        return this;
      };
      _proto.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {
        this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));
        return this;
      };
      _proto.appendInstant = function appendInstant(fractionalDigits) {
        if (fractionalDigits === void 0) {
          fractionalDigits = -2;
        }
        if (fractionalDigits < -2 || fractionalDigits > 9) {
          throw new IllegalArgumentException("Invalid fractional digits: " + fractionalDigits);
        }
        this._appendInternal(new InstantPrinterParser(fractionalDigits));
        return this;
      };
      _proto.appendOffsetId = function appendOffsetId() {
        this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);
        return this;
      };
      _proto.appendOffset = function appendOffset(pattern, noOffsetText) {
        this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));
        return this;
      };
      _proto.appendZoneId = function appendZoneId() {
        this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), "ZoneId()"));
        return this;
      };
      _proto.appendPattern = function appendPattern(pattern) {
        requireNonNull(pattern, "pattern");
        this._parsePattern(pattern);
        return this;
      };
      _proto.appendZoneText = function appendZoneText() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto.appendText = function appendText() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto.appendLocalizedOffset = function appendLocalizedOffset() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto.appendWeekField = function appendWeekField() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto._parsePattern = function _parsePattern(pattern) {
        var FIELD_MAP = {
          "G": ChronoField.ERA,
          "y": ChronoField.YEAR_OF_ERA,
          "u": ChronoField.YEAR,
          "Q": IsoFields.QUARTER_OF_YEAR,
          "q": IsoFields.QUARTER_OF_YEAR,
          "M": ChronoField.MONTH_OF_YEAR,
          "L": ChronoField.MONTH_OF_YEAR,
          "D": ChronoField.DAY_OF_YEAR,
          "d": ChronoField.DAY_OF_MONTH,
          "F": ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,
          "E": ChronoField.DAY_OF_WEEK,
          "c": ChronoField.DAY_OF_WEEK,
          "e": ChronoField.DAY_OF_WEEK,
          "a": ChronoField.AMPM_OF_DAY,
          "H": ChronoField.HOUR_OF_DAY,
          "k": ChronoField.CLOCK_HOUR_OF_DAY,
          "K": ChronoField.HOUR_OF_AMPM,
          "h": ChronoField.CLOCK_HOUR_OF_AMPM,
          "m": ChronoField.MINUTE_OF_HOUR,
          "s": ChronoField.SECOND_OF_MINUTE,
          "S": ChronoField.NANO_OF_SECOND,
          "A": ChronoField.MILLI_OF_DAY,
          "n": ChronoField.NANO_OF_SECOND,
          "N": ChronoField.NANO_OF_DAY
        };
        for (var pos = 0; pos < pattern.length; pos++) {
          var cur = pattern.charAt(pos);
          if (cur >= "A" && cur <= "Z" || cur >= "a" && cur <= "z") {
            var start = pos++;
            for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++)
              ;
            var count = pos - start;
            if (cur === "p") {
              var pad = 0;
              if (pos < pattern.length) {
                cur = pattern.charAt(pos);
                if (cur >= "A" && cur <= "Z" || cur >= "a" && cur <= "z") {
                  pad = count;
                  start = pos++;
                  for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++)
                    ;
                  count = pos - start;
                }
              }
              if (pad === 0) {
                throw new IllegalArgumentException("Pad letter 'p' must be followed by valid pad pattern: " + pattern);
              }
              this.padNext(pad);
            }
            var field = FIELD_MAP[cur];
            if (field != null) {
              this._parseField(cur, count, field);
            } else if (cur === "z") {
              if (count > 4) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              } else if (count === 4) {
                this.appendZoneText(TextStyle.FULL);
              } else {
                this.appendZoneText(TextStyle.SHORT);
              }
            } else if (cur === "V") {
              if (count !== 2) {
                throw new IllegalArgumentException("Pattern letter count must be 2: " + cur);
              }
              this.appendZoneId();
            } else if (cur === "Z") {
              if (count < 4) {
                this.appendOffset("+HHMM", "+0000");
              } else if (count === 4) {
                this.appendLocalizedOffset(TextStyle.FULL);
              } else if (count === 5) {
                this.appendOffset("+HH:MM:ss", "Z");
              } else {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
            } else if (cur === "O") {
              if (count === 1) {
                this.appendLocalizedOffset(TextStyle.SHORT);
              } else if (count === 4) {
                this.appendLocalizedOffset(TextStyle.FULL);
              } else {
                throw new IllegalArgumentException("Pattern letter count must be 1 or 4: " + cur);
              }
            } else if (cur === "X") {
              if (count > 5) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], "Z");
            } else if (cur === "x") {
              if (count > 5) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              var zero = count === 1 ? "+00" : count % 2 === 0 ? "+0000" : "+00:00";
              this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);
            } else if (cur === "W") {
              if (count > 1) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              this.appendWeekField("W", count);
            } else if (cur === "w") {
              if (count > 2) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              this.appendWeekField("w", count);
            } else if (cur === "Y") {
              this.appendWeekField("Y", count);
            } else {
              throw new IllegalArgumentException("Unknown pattern letter: " + cur);
            }
            pos--;
          } else if (cur === "'") {
            var _start = pos++;
            for (; pos < pattern.length; pos++) {
              if (pattern.charAt(pos) === "'") {
                if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === "'") {
                  pos++;
                } else {
                  break;
                }
              }
            }
            if (pos >= pattern.length) {
              throw new IllegalArgumentException("Pattern ends with an incomplete string literal: " + pattern);
            }
            var str = pattern.substring(_start + 1, pos);
            if (str.length === 0) {
              this.appendLiteral("'");
            } else {
              this.appendLiteral(str.replace("''", "'"));
            }
          } else if (cur === "[") {
            this.optionalStart();
          } else if (cur === "]") {
            if (this._active._parent === null) {
              throw new IllegalArgumentException("Pattern invalid as it contains ] without previous [");
            }
            this.optionalEnd();
          } else if (cur === "{" || cur === "}" || cur === "#") {
            throw new IllegalArgumentException("Pattern includes reserved character: '" + cur + "'");
          } else {
            this.appendLiteral(cur);
          }
        }
      };
      _proto._parseField = function _parseField(cur, count, field) {
        switch (cur) {
          case "u":
          case "y":
            if (count === 2) {
              this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);
            } else if (count < 4) {
              this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);
            } else {
              this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);
            }
            break;
          case "M":
          case "Q":
            switch (count) {
              case 1:
                this.appendValue(field);
                break;
              case 2:
                this.appendValue(field, 2);
                break;
              case 3:
                this.appendText(field, TextStyle.SHORT);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "L":
          case "q":
            switch (count) {
              case 1:
                this.appendValue(field);
                break;
              case 2:
                this.appendValue(field, 2);
                break;
              case 3:
                this.appendText(field, TextStyle.SHORT_STANDALONE);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL_STANDALONE);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW_STANDALONE);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "e":
            switch (count) {
              case 1:
              case 2:
                this.appendWeekField("e", count);
                break;
              case 3:
                this.appendText(field, TextStyle.SHORT);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "c":
            switch (count) {
              case 1:
                this.appendWeekField("c", count);
                break;
              case 2:
                throw new IllegalArgumentException("Invalid number of pattern letters: " + cur);
              case 3:
                this.appendText(field, TextStyle.SHORT_STANDALONE);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL_STANDALONE);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW_STANDALONE);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "a":
            if (count === 1) {
              this.appendText(field, TextStyle.SHORT);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "E":
          case "G":
            switch (count) {
              case 1:
              case 2:
              case 3:
                this.appendText(field, TextStyle.SHORT);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "S":
            this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);
            break;
          case "F":
            if (count === 1) {
              this.appendValue(field);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "d":
          case "h":
          case "H":
          case "k":
          case "K":
          case "m":
          case "s":
            if (count === 1) {
              this.appendValue(field);
            } else if (count === 2) {
              this.appendValue(field, count);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "D":
            if (count === 1) {
              this.appendValue(field);
            } else if (count <= 3) {
              this.appendValue(field, count);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          default:
            if (count === 1) {
              this.appendValue(field);
            } else {
              this.appendValue(field, count);
            }
            break;
        }
      };
      _proto.padNext = function padNext() {
        if (arguments.length === 1) {
          return this._padNext1.apply(this, arguments);
        } else {
          return this._padNext2.apply(this, arguments);
        }
      };
      _proto._padNext1 = function _padNext1(padWidth) {
        return this._padNext2(padWidth, " ");
      };
      _proto._padNext2 = function _padNext2(padWidth, padChar) {
        if (padWidth < 1) {
          throw new IllegalArgumentException("The pad width must be at least one but was " + padWidth);
        }
        this._active._padNextWidth = padWidth;
        this._active._padNextChar = padChar;
        this._active._valueParserIndex = -1;
        return this;
      };
      _proto.optionalStart = function optionalStart() {
        this._active._valueParserIndex = -1;
        this._active = DateTimeFormatterBuilder2._of(this._active, true);
        return this;
      };
      _proto.optionalEnd = function optionalEnd() {
        if (this._active._parent == null) {
          throw new IllegalStateException("Cannot call optionalEnd() as there was no previous call to optionalStart()");
        }
        if (this._active._printerParsers.length > 0) {
          var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);
          this._active = this._active._parent;
          this._appendInternal(cpp);
        } else {
          this._active = this._active._parent;
        }
        return this;
      };
      _proto._appendInternal = function _appendInternal(pp) {
        assert(pp != null);
        if (this._active._padNextWidth > 0) {
          if (pp != null) {
            pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
          }
          this._active._padNextWidth = 0;
          this._active._padNextChar = 0;
        }
        this._active._printerParsers.push(pp);
        this._active._valueParserIndex = -1;
        return this._active._printerParsers.length - 1;
      };
      _proto.appendLiteral = function appendLiteral(literal) {
        assert(literal != null);
        if (literal.length > 0) {
          if (literal.length === 1) {
            this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));
          } else {
            this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));
          }
        }
        return this;
      };
      _proto._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {
        assert(pp != null);
        if (this._active._padNextWidth > 0) {
          if (pp != null) {
            pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
          }
          this._active._padNextWidth = 0;
          this._active._padNextChar = 0;
        }
        this._active._printerParsers.push(pp);
        this._active._valueParserIndex = -1;
        return this._active._printerParsers.length - 1;
      };
      _proto.append = function append(formatter) {
        requireNonNull(formatter, "formatter");
        this._appendInternal(formatter._toPrinterParser(false));
        return this;
      };
      _proto.toFormatter = function toFormatter(resolverStyle) {
        if (resolverStyle === void 0) {
          resolverStyle = ResolverStyle.SMART;
        }
        while (this._active._parent != null) {
          this.optionalEnd();
        }
        var pp = new CompositePrinterParser(this._printerParsers, false);
        return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);
      };
      return DateTimeFormatterBuilder2;
    }();
    SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;
    SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;
    InstantPrinterParser = function() {
      function InstantPrinterParser2(fractionalDigits) {
        this.fractionalDigits = fractionalDigits;
      }
      var _proto2 = InstantPrinterParser2.prototype;
      _proto2.print = function print(context, buf) {
        var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);
        var inNanos = 0;
        if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {
          inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);
        }
        if (inSecs == null) {
          return false;
        }
        var inSec = inSecs;
        var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);
        if (inSec >= -SECONDS_0000_TO_1970) {
          var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;
          var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;
          var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);
          var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
          if (hi > 0) {
            buf.append("+").append(hi);
          }
          buf.append(ldt.toString());
          if (ldt.second() === 0) {
            buf.append(":00");
          }
        } else {
          var _zeroSecs = inSec + SECONDS_0000_TO_1970;
          var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);
          var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);
          var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
          var pos = buf.length();
          buf.append(_ldt.toString());
          if (_ldt.second() === 0) {
            buf.append(":00");
          }
          if (_hi < 0) {
            if (_ldt.year() === -1e4) {
              buf.replace(pos, pos + 2, "" + (_hi - 1));
            } else if (_lo === 0) {
              buf.insert(pos, _hi);
            } else {
              buf.insert(pos + 1, Math.abs(_hi));
            }
          }
        }
        if (this.fractionalDigits === -2) {
          if (inNano !== 0) {
            buf.append(".");
            if (MathUtil.intMod(inNano, 1e6) === 0) {
              buf.append(("" + (MathUtil.intDiv(inNano, 1e6) + 1e3)).substring(1));
            } else if (MathUtil.intMod(inNano, 1e3) === 0) {
              buf.append(("" + (MathUtil.intDiv(inNano, 1e3) + 1e6)).substring(1));
            } else {
              buf.append(("" + (inNano + 1e9)).substring(1));
            }
          }
        } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {
          buf.append(".");
          var div = 1e8;
          for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {
            var digit = MathUtil.intDiv(inNano, div);
            buf.append(digit);
            inNano = inNano - digit * div;
            div = MathUtil.intDiv(div, 10);
          }
        }
        buf.append("Z");
        return true;
      };
      _proto2.parse = function parse2(context, text, position) {
        var newContext = context.copy();
        var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;
        var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;
        var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral("T").appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(":").appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(":").appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral("Z").toFormatter()._toPrinterParser(false);
        var pos = parser.parse(newContext, text, position);
        if (pos < 0) {
          return pos;
        }
        var yearParsed = newContext.getParsed(ChronoField.YEAR);
        var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);
        var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);
        var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);
        var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);
        var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);
        var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);
        var sec = secVal != null ? secVal : 0;
        var nano = nanoVal != null ? nanoVal : 0;
        var year = MathUtil.intMod(yearParsed, 1e4);
        var days = 0;
        if (hour === 24 && min === 0 && sec === 0 && nano === 0) {
          hour = 0;
          days = 1;
        } else if (hour === 23 && min === 59 && sec === 60) {
          context.setParsedLeapSecond();
          sec = 59;
        }
        var instantSecs;
        try {
          var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);
          instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);
          instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 1e4), SECONDS_PER_10000_YEARS);
        } catch (ex) {
          return ~position;
        }
        var successPos = pos;
        successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);
        return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);
      };
      _proto2.toString = function toString() {
        return "Instant()";
      };
      return InstantPrinterParser2;
    }();
    StringBuilder = function() {
      function StringBuilder2() {
        this._str = "";
      }
      var _proto = StringBuilder2.prototype;
      _proto.append = function append(str) {
        this._str += str;
        return this;
      };
      _proto.appendChar = function appendChar(str) {
        this._str += str[0];
        return this;
      };
      _proto.insert = function insert(offset, str) {
        this._str = this._str.slice(0, offset) + str + this._str.slice(offset);
        return this;
      };
      _proto.replace = function replace(start, end, str) {
        this._str = this._str.slice(0, start) + str + this._str.slice(end);
        return this;
      };
      _proto.length = function length() {
        return this._str.length;
      };
      _proto.setLength = function setLength(length) {
        this._str = this._str.slice(0, length);
        return this;
      };
      _proto.toString = function toString() {
        return this._str;
      };
      return StringBuilder2;
    }();
    DateTimeFormatter = function() {
      DateTimeFormatter2.parsedExcessDays = function parsedExcessDays() {
        return DateTimeFormatter2.PARSED_EXCESS_DAYS;
      };
      DateTimeFormatter2.parsedLeapSecond = function parsedLeapSecond() {
        return DateTimeFormatter2.PARSED_LEAP_SECOND;
      };
      DateTimeFormatter2.ofPattern = function ofPattern(pattern) {
        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
      };
      function DateTimeFormatter2(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone) {
        if (chrono === void 0) {
          chrono = IsoChronology.INSTANCE;
        }
        assert(printerParser != null);
        assert(decimalStyle != null);
        assert(resolverStyle != null);
        this._printerParser = printerParser;
        this._locale = locale;
        this._decimalStyle = decimalStyle;
        this._resolverStyle = resolverStyle;
        this._resolverFields = resolverFields;
        this._chrono = chrono;
        this._zone = zone;
      }
      var _proto = DateTimeFormatter2.prototype;
      _proto.locale = function locale() {
        return this._locale;
      };
      _proto.decimalStyle = function decimalStyle() {
        return this._decimalStyle;
      };
      _proto.chronology = function chronology() {
        return this._chrono;
      };
      _proto.withChronology = function withChronology(chrono) {
        if (this._chrono != null && this._chrono.equals(chrono)) {
          return this;
        }
        return new DateTimeFormatter2(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);
      };
      _proto.withLocale = function withLocale() {
        return this;
      };
      _proto.withResolverStyle = function withResolverStyle(resolverStyle) {
        requireNonNull(resolverStyle, "resolverStyle");
        if (resolverStyle.equals(this._resolverStyle)) {
          return this;
        }
        return new DateTimeFormatter2(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);
      };
      _proto.format = function format(temporal) {
        var buf = new StringBuilder(32);
        this._formatTo(temporal, buf);
        return buf.toString();
      };
      _proto._formatTo = function _formatTo(temporal, appendable) {
        requireNonNull(temporal, "temporal");
        requireNonNull(appendable, "appendable");
        var context = new DateTimePrintContext(temporal, this);
        this._printerParser.print(context, appendable);
      };
      _proto.parse = function parse2(text, type2) {
        if (arguments.length === 1) {
          return this.parse1(text);
        } else {
          return this.parse2(text, type2);
        }
      };
      _proto.parse1 = function parse1(text) {
        requireNonNull(text, "text");
        try {
          return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
        } catch (ex) {
          if (ex instanceof DateTimeParseException) {
            throw ex;
          } else {
            throw this._createError(text, ex);
          }
        }
      };
      _proto.parse2 = function parse2(text, type2) {
        requireNonNull(text, "text");
        requireNonNull(type2, "type");
        try {
          var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
          return builder.build(type2);
        } catch (ex) {
          if (ex instanceof DateTimeParseException) {
            throw ex;
          } else {
            throw this._createError(text, ex);
          }
        }
      };
      _proto._createError = function _createError(text, ex) {
        var abbr = "";
        if (text.length > 64) {
          abbr = text.substring(0, 64) + "...";
        } else {
          abbr = text;
        }
        return new DateTimeParseException("Text '" + abbr + "' could not be parsed: " + ex.message, text, 0, ex);
      };
      _proto._parseToBuilder = function _parseToBuilder(text, position) {
        var pos = position != null ? position : new ParsePosition(0);
        var result = this._parseUnresolved0(text, pos);
        if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {
          var abbr = "";
          if (text.length > 64) {
            abbr = text.substr(0, 64).toString() + "...";
          } else {
            abbr = text;
          }
          if (pos.getErrorIndex() >= 0) {
            throw new DateTimeParseException("Text '" + abbr + "' could not be parsed at index " + pos.getErrorIndex(), text, pos.getErrorIndex());
          } else {
            throw new DateTimeParseException("Text '" + abbr + "' could not be parsed, unparsed text found at index " + pos.getIndex(), text, pos.getIndex());
          }
        }
        return result.toBuilder();
      };
      _proto.parseUnresolved = function parseUnresolved(text, position) {
        return this._parseUnresolved0(text, position);
      };
      _proto._parseUnresolved0 = function _parseUnresolved0(text, position) {
        assert(text != null, "text", NullPointerException);
        assert(position != null, "position", NullPointerException);
        var context = new DateTimeParseContext(this);
        var pos = position.getIndex();
        pos = this._printerParser.parse(context, text, pos);
        if (pos < 0) {
          position.setErrorIndex(~pos);
          return null;
        }
        position.setIndex(pos);
        return context.toParsed();
      };
      _proto._toPrinterParser = function _toPrinterParser(optional) {
        return this._printerParser.withOptional(optional);
      };
      _proto.toString = function toString() {
        var pattern = this._printerParser.toString();
        return pattern.indexOf("[") === 0 ? pattern : pattern.substring(1, pattern.length - 1);
      };
      return DateTimeFormatter2;
    }();
    MonthDay = function(_TemporalAccessor) {
      _inheritsLoose(MonthDay2, _TemporalAccessor);
      MonthDay2.now = function now(zoneIdOrClock) {
        if (arguments.length === 0) {
          return MonthDay2.now0();
        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
          return MonthDay2.nowZoneId(zoneIdOrClock);
        } else {
          return MonthDay2.nowClock(zoneIdOrClock);
        }
      };
      MonthDay2.now0 = function now0() {
        return this.nowClock(Clock.systemDefaultZone());
      };
      MonthDay2.nowZoneId = function nowZoneId(zone) {
        requireNonNull(zone, "zone");
        return this.nowClock(Clock.system(zone));
      };
      MonthDay2.nowClock = function nowClock(clock) {
        requireNonNull(clock, "clock");
        var now = LocalDate.now(clock);
        return MonthDay2.of(now.month(), now.dayOfMonth());
      };
      MonthDay2.of = function of(monthOrNumber, number) {
        if (arguments.length === 2 && monthOrNumber instanceof Month) {
          return MonthDay2.ofMonthNumber(monthOrNumber, number);
        } else {
          return MonthDay2.ofNumberNumber(monthOrNumber, number);
        }
      };
      MonthDay2.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {
        requireNonNull(month, "month");
        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
        if (dayOfMonth > month.maxLength()) {
          throw new DateTimeException("Illegal value for DayOfMonth field, value " + dayOfMonth + " is not valid for month " + month.toString());
        }
        return new MonthDay2(month.value(), dayOfMonth);
      };
      MonthDay2.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {
        requireNonNull(month, "month");
        requireNonNull(dayOfMonth, "dayOfMonth");
        return MonthDay2.of(Month.of(month), dayOfMonth);
      };
      MonthDay2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        requireInstance(temporal, TemporalAccessor, "temporal");
        if (temporal instanceof MonthDay2) {
          return temporal;
        }
        try {
          return MonthDay2.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain MonthDay from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      MonthDay2.parse = function parse2(text, formatter) {
        if (arguments.length === 1) {
          return MonthDay2.parseString(text);
        } else {
          return MonthDay2.parseStringFormatter(text, formatter);
        }
      };
      MonthDay2.parseString = function parseString(text) {
        return MonthDay2.parseStringFormatter(text, PARSER$2);
      };
      MonthDay2.parseStringFormatter = function parseStringFormatter(text, formatter) {
        requireNonNull(text, "text");
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.parse(text, MonthDay2.FROM);
      };
      function MonthDay2(month, dayOfMonth) {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this._month = MathUtil.safeToInt(month);
        _this._day = MathUtil.safeToInt(dayOfMonth);
        return _this;
      }
      var _proto = MonthDay2.prototype;
      _proto.monthValue = function monthValue() {
        return this._month;
      };
      _proto.month = function month() {
        return Month.of(this._month);
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._day;
      };
      _proto.isSupported = function isSupported(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field === ChronoField.MONTH_OF_YEAR) {
          return field.range();
        } else if (field === ChronoField.DAY_OF_MONTH) {
          return ValueRange.of(1, this.month().minLength(), this.month().maxLength());
        }
        return _TemporalAccessor.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.DAY_OF_MONTH:
              return this._day;
            case ChronoField.MONTH_OF_YEAR:
              return this._month;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.isValidYear = function isValidYear(year) {
        return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;
      };
      _proto.withMonth = function withMonth(month) {
        return this.with(Month.of(month));
      };
      _proto.with = function _with(month) {
        requireNonNull(month, "month");
        if (month.value() === this._month) {
          return this;
        }
        var day = Math.min(this._day, month.maxLength());
        return new MonthDay2(month.value(), day);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        if (dayOfMonth === this._day) {
          return this;
        }
        return MonthDay2.of(this._month, dayOfMonth);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        requireInstance(_query, TemporalQuery, "query");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        }
        return _TemporalAccessor.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);
        return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));
      };
      _proto.atYear = function atYear(year) {
        return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, MonthDay2, "other");
        var cmp = this._month - other.monthValue();
        if (cmp === 0) {
          cmp = this._day - other.dayOfMonth();
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        requireInstance(other, MonthDay2, "other");
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        requireInstance(other, MonthDay2, "other");
        return this.compareTo(other) < 0;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof MonthDay2) {
          var other = obj;
          return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();
        }
        return false;
      };
      _proto.toString = function toString() {
        return "--" + (this._month < 10 ? "0" : "") + this._month + (this._day < 10 ? "-0" : "-") + this._day;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.format(this);
      };
      return MonthDay2;
    }(TemporalAccessor);
    YearMonth = function(_Temporal) {
      _inheritsLoose(YearMonth2, _Temporal);
      YearMonth2.now = function now(zoneIdOrClock) {
        if (arguments.length === 0) {
          return YearMonth2.now0();
        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
          return YearMonth2.nowZoneId(zoneIdOrClock);
        } else {
          return YearMonth2.nowClock(zoneIdOrClock);
        }
      };
      YearMonth2.now0 = function now0() {
        return YearMonth2.nowClock(Clock.systemDefaultZone());
      };
      YearMonth2.nowZoneId = function nowZoneId(zone) {
        return YearMonth2.nowClock(Clock.system(zone));
      };
      YearMonth2.nowClock = function nowClock(clock) {
        var now = LocalDate.now(clock);
        return YearMonth2.of(now.year(), now.month());
      };
      YearMonth2.of = function of(year, monthOrNumber) {
        if (arguments.length === 2 && monthOrNumber instanceof Month) {
          return YearMonth2.ofNumberMonth(year, monthOrNumber);
        } else {
          return YearMonth2.ofNumberNumber(year, monthOrNumber);
        }
      };
      YearMonth2.ofNumberMonth = function ofNumberMonth(year, month) {
        requireNonNull(month, "month");
        requireInstance(month, Month, "month");
        return YearMonth2.ofNumberNumber(year, month.value());
      };
      YearMonth2.ofNumberNumber = function ofNumberNumber(year, month) {
        requireNonNull(year, "year");
        requireNonNull(month, "month");
        ChronoField.YEAR.checkValidValue(year);
        ChronoField.MONTH_OF_YEAR.checkValidValue(month);
        return new YearMonth2(year, month);
      };
      YearMonth2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof YearMonth2) {
          return temporal;
        }
        try {
          return YearMonth2.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain YearMonth from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      YearMonth2.parse = function parse2(text, formatter) {
        if (arguments.length === 1) {
          return YearMonth2.parseString(text);
        } else {
          return YearMonth2.parseStringFormatter(text, formatter);
        }
      };
      YearMonth2.parseString = function parseString(text) {
        return YearMonth2.parseStringFormatter(text, PARSER$1);
      };
      YearMonth2.parseStringFormatter = function parseStringFormatter(text, formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, YearMonth2.FROM);
      };
      function YearMonth2(year, month) {
        var _this;
        _this = _Temporal.call(this) || this;
        _this._year = MathUtil.safeToInt(year);
        _this._month = MathUtil.safeToInt(month);
        return _this;
      }
      var _proto = YearMonth2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
          return this.isSupportedField(fieldOrUnit);
        } else {
          return this.isSupportedUnit(fieldOrUnit);
        }
      };
      _proto.isSupportedField = function isSupportedField(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.isSupportedUnit = function isSupportedUnit(unit) {
        if (unit instanceof ChronoUnit) {
          return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
        }
        return unit != null && unit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field === ChronoField.YEAR_OF_ERA) {
          return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
        }
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.MONTH_OF_YEAR:
              return this._month;
            case ChronoField.PROLEPTIC_MONTH:
              return this._getProlepticMonth();
            case ChronoField.YEAR_OF_ERA:
              return this._year < 1 ? 1 - this._year : this._year;
            case ChronoField.YEAR:
              return this._year;
            case ChronoField.ERA:
              return this._year < 1 ? 0 : 1;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto._getProlepticMonth = function _getProlepticMonth() {
        return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);
      };
      _proto.year = function year() {
        return this._year;
      };
      _proto.monthValue = function monthValue() {
        return this._month;
      };
      _proto.month = function month() {
        return Month.of(this._month);
      };
      _proto.isLeapYear = function isLeapYear() {
        return IsoChronology.isLeapYear(this._year);
      };
      _proto.isValidDay = function isValidDay(dayOfMonth) {
        return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();
      };
      _proto.lengthOfMonth = function lengthOfMonth() {
        return this.month().length(this.isLeapYear());
      };
      _proto.lengthOfYear = function lengthOfYear() {
        return this.isLeapYear() ? 366 : 365;
      };
      _proto.with = function _with(adjusterOrField, value) {
        if (arguments.length === 1) {
          return this._withAdjuster(adjusterOrField);
        } else {
          return this._withField(adjusterOrField, value);
        }
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          var f = field;
          f.checkValidValue(newValue);
          switch (f) {
            case ChronoField.MONTH_OF_YEAR:
              return this.withMonth(newValue);
            case ChronoField.PROLEPTIC_MONTH:
              return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
            case ChronoField.YEAR_OF_ERA:
              return this.withYear(this._year < 1 ? 1 - newValue : newValue);
            case ChronoField.YEAR:
              return this.withYear(newValue);
            case ChronoField.ERA:
              return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        ChronoField.YEAR.checkValidValue(year);
        return new YearMonth2(year, this._month);
      };
      _proto.withMonth = function withMonth(month) {
        ChronoField.MONTH_OF_YEAR.checkValidValue(month);
        return new YearMonth2(this._year, month);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.MONTHS:
              return this.plusMonths(amountToAdd);
            case ChronoUnit.YEARS:
              return this.plusYears(amountToAdd);
            case ChronoUnit.DECADES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
            case ChronoUnit.CENTURIES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
            case ChronoUnit.MILLENNIA:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
            case ChronoUnit.ERAS:
              return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
        return this.withYear(newYear);
      };
      _proto.plusMonths = function plusMonths(monthsToAdd) {
        if (monthsToAdd === 0) {
          return this;
        }
        var monthCount = this._year * 12 + (this._month - 1);
        var calcMonths = monthCount + monthsToAdd;
        var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
        var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
        return new YearMonth2(newYear, newMonth);
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
      };
      _proto.minusMonths = function minusMonths(monthsToSubtract) {
        return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        requireInstance(_query, TemporalQuery, "query");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.MONTHS;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        requireInstance(temporal, Temporal, "temporal");
        return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        requireInstance(endExclusive, Temporal, "endExclusive");
        requireInstance(unit, TemporalUnit, "unit");
        var end = YearMonth2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();
          switch (unit) {
            case ChronoUnit.MONTHS:
              return monthsUntil;
            case ChronoUnit.YEARS:
              return MathUtil.intDiv(monthsUntil, 12);
            case ChronoUnit.DECADES:
              return MathUtil.intDiv(monthsUntil, 120);
            case ChronoUnit.CENTURIES:
              return MathUtil.intDiv(monthsUntil, 1200);
            case ChronoUnit.MILLENNIA:
              return MathUtil.intDiv(monthsUntil, 12e3);
            case ChronoUnit.ERAS:
              return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.atDay = function atDay(dayOfMonth) {
        requireNonNull(dayOfMonth, "dayOfMonth");
        return LocalDate.of(this._year, this._month, dayOfMonth);
      };
      _proto.atEndOfMonth = function atEndOfMonth() {
        return LocalDate.of(this._year, this._month, this.lengthOfMonth());
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, YearMonth2, "other");
        var cmp = this._year - other.year();
        if (cmp === 0) {
          cmp = this._month - other.monthValue();
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof YearMonth2) {
          var other = obj;
          return this.year() === other.year() && this.monthValue() === other.monthValue();
        }
        return false;
      };
      _proto.toString = function toString() {
        return PARSER$1.format(this);
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return YearMonth2;
    }(Temporal);
    Year = function(_Temporal) {
      _inheritsLoose(Year2, _Temporal);
      function Year2(value) {
        var _this;
        _this = _Temporal.call(this) || this;
        _this._year = MathUtil.safeToInt(value);
        return _this;
      }
      var _proto = Year2.prototype;
      _proto.value = function value() {
        return this._year;
      };
      Year2.now = function now(zoneIdOrClock) {
        if (zoneIdOrClock === void 0) {
          zoneIdOrClock = void 0;
        }
        if (zoneIdOrClock === void 0) {
          return Year2.now0();
        } else if (zoneIdOrClock instanceof ZoneId) {
          return Year2.nowZoneId(zoneIdOrClock);
        } else {
          return Year2.nowClock(zoneIdOrClock);
        }
      };
      Year2.now0 = function now0() {
        return Year2.nowClock(Clock.systemDefaultZone());
      };
      Year2.nowZoneId = function nowZoneId(zone) {
        requireNonNull(zone, "zone");
        requireInstance(zone, ZoneId, "zone");
        return Year2.nowClock(Clock.system(zone));
      };
      Year2.nowClock = function nowClock(clock) {
        requireNonNull(clock, "clock");
        requireInstance(clock, Clock, "clock");
        var now = LocalDate.now(clock);
        return Year2.of(now.year());
      };
      Year2.of = function of(isoYear) {
        requireNonNull(isoYear, "isoYear");
        ChronoField.YEAR.checkValidValue(isoYear);
        return new Year2(isoYear);
      };
      Year2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        requireInstance(temporal, TemporalAccessor, "temporal");
        if (temporal instanceof Year2) {
          return temporal;
        }
        try {
          return Year2.of(temporal.get(ChronoField.YEAR));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain Year from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      Year2.parse = function parse2(text, formatter) {
        if (arguments.length <= 1) {
          return Year2.parseText(text);
        } else {
          return Year2.parseTextFormatter(text, formatter);
        }
      };
      Year2.parseText = function parseText(text) {
        requireNonNull(text, "text");
        return Year2.parse(text, PARSER);
      };
      Year2.parseTextFormatter = function parseTextFormatter(text, formatter) {
        if (formatter === void 0) {
          formatter = PARSER;
        }
        requireNonNull(text, "text");
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.parse(text, Year2.FROM);
      };
      Year2.isLeap = function isLeap(year) {
        return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
          return this.isSupportedField(fieldOrUnit);
        } else {
          return this.isSupportedUnit(fieldOrUnit);
        }
      };
      _proto.isSupportedField = function isSupportedField(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.isSupportedUnit = function isSupportedUnit(unit) {
        if (unit instanceof ChronoUnit) {
          return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
        }
        return unit != null && unit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (this.isSupported(field)) {
          return field.range();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.YEAR_OF_ERA:
              return this._year < 1 ? 1 - this._year : this._year;
            case ChronoField.YEAR:
              return this._year;
            case ChronoField.ERA:
              return this._year < 1 ? 0 : 1;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.isLeap = function isLeap() {
        return Year2.isLeap(this._year);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          field.checkValidValue(newValue);
          switch (field) {
            case ChronoField.YEAR_OF_ERA:
              return Year2.of(this._year < 1 ? 1 - newValue : newValue);
            case ChronoField.YEAR:
              return Year2.of(newValue);
            case ChronoField.ERA:
              return this.getLong(ChronoField.ERA) === newValue ? this : Year2.of(1 - this._year);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.YEARS:
              return this.plusYears(amountToAdd);
            case ChronoUnit.DECADES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
            case ChronoUnit.CENTURIES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
            case ChronoUnit.MILLENNIA:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
            case ChronoUnit.ERAS:
              return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        return Year2.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        return temporal.with(ChronoField.YEAR, this._year);
      };
      _proto.isValidMonthDay = function isValidMonthDay(monthDay) {
        return monthDay != null && monthDay.isValidYear(this._year);
      };
      _proto.length = function length() {
        return this.isLeap() ? 366 : 365;
      };
      _proto.atDay = function atDay(dayOfYear) {
        return LocalDate.ofYearDay(this._year, dayOfYear);
      };
      _proto.atMonth = function atMonth(monthOrNumber) {
        if (arguments.length === 1 && monthOrNumber instanceof Month) {
          return this.atMonthMonth(monthOrNumber);
        } else {
          return this.atMonthNumber(monthOrNumber);
        }
      };
      _proto.atMonthMonth = function atMonthMonth(month) {
        requireNonNull(month, "month");
        requireInstance(month, Month, "month");
        return YearMonth.of(this._year, month);
      };
      _proto.atMonthNumber = function atMonthNumber(month) {
        requireNonNull(month, "month");
        return YearMonth.of(this._year, month);
      };
      _proto.atMonthDay = function atMonthDay(monthDay) {
        requireNonNull(monthDay, "monthDay");
        requireInstance(monthDay, MonthDay, "monthDay");
        return monthDay.atYear(this._year);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query()");
        requireInstance(_query, TemporalQuery, "query()");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.YEARS;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, Year2, "other");
        return this._year - other._year;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        requireInstance(other, Year2, "other");
        return this._year > other._year;
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        requireInstance(other, Year2, "other");
        return this._year < other._year;
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.format(this);
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof Year2) {
          return this.value() === other.value();
        }
        return false;
      };
      _proto.toString = function toString() {
        return "" + this._year;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.until = function until(endExclusive, unit) {
        var end = Year2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var yearsUntil = end.value() - this.value();
          switch (unit) {
            case ChronoUnit.YEARS:
              return yearsUntil;
            case ChronoUnit.DECADES:
              return MathUtil.intDiv(yearsUntil, 10);
            case ChronoUnit.CENTURIES:
              return MathUtil.intDiv(yearsUntil, 100);
            case ChronoUnit.MILLENNIA:
              return MathUtil.intDiv(yearsUntil, 1e3);
            case ChronoUnit.ERAS:
              return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      return Year2;
    }(Temporal);
    TemporalAdjuster = function() {
      function TemporalAdjuster2() {
      }
      var _proto = TemporalAdjuster2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        abstractMethodFail("adjustInto");
      };
      return TemporalAdjuster2;
    }();
    TemporalAdjusters = function() {
      function TemporalAdjusters2() {
      }
      TemporalAdjusters2.firstDayOfMonth = function firstDayOfMonth() {
        return Impl.FIRST_DAY_OF_MONTH;
      };
      TemporalAdjusters2.lastDayOfMonth = function lastDayOfMonth() {
        return Impl.LAST_DAY_OF_MONTH;
      };
      TemporalAdjusters2.firstDayOfNextMonth = function firstDayOfNextMonth() {
        return Impl.FIRST_DAY_OF_NEXT_MONTH;
      };
      TemporalAdjusters2.firstDayOfYear = function firstDayOfYear() {
        return Impl.FIRST_DAY_OF_YEAR;
      };
      TemporalAdjusters2.lastDayOfYear = function lastDayOfYear() {
        return Impl.LAST_DAY_OF_YEAR;
      };
      TemporalAdjusters2.firstDayOfNextYear = function firstDayOfNextYear() {
        return Impl.FIRST_DAY_OF_NEXT_YEAR;
      };
      TemporalAdjusters2.firstInMonth = function firstInMonth(dayOfWeek) {
        requireNonNull(dayOfWeek, "dayOfWeek");
        return new DayOfWeekInMonth(1, dayOfWeek);
      };
      TemporalAdjusters2.lastInMonth = function lastInMonth(dayOfWeek) {
        requireNonNull(dayOfWeek, "dayOfWeek");
        return new DayOfWeekInMonth(-1, dayOfWeek);
      };
      TemporalAdjusters2.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {
        requireNonNull(dayOfWeek, "dayOfWeek");
        return new DayOfWeekInMonth(ordinal, dayOfWeek);
      };
      TemporalAdjusters2.next = function next(dayOfWeek) {
        return new RelativeDayOfWeek(2, dayOfWeek);
      };
      TemporalAdjusters2.nextOrSame = function nextOrSame(dayOfWeek) {
        return new RelativeDayOfWeek(0, dayOfWeek);
      };
      TemporalAdjusters2.previous = function previous(dayOfWeek) {
        return new RelativeDayOfWeek(3, dayOfWeek);
      };
      TemporalAdjusters2.previousOrSame = function previousOrSame(dayOfWeek) {
        return new RelativeDayOfWeek(1, dayOfWeek);
      };
      return TemporalAdjusters2;
    }();
    Impl = function(_TemporalAdjuster) {
      _inheritsLoose(Impl2, _TemporalAdjuster);
      function Impl2(ordinal) {
        var _this;
        _this = _TemporalAdjuster.call(this) || this;
        _this._ordinal = ordinal;
        return _this;
      }
      var _proto = Impl2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        switch (this._ordinal) {
          case 0:
            return temporal.with(ChronoField.DAY_OF_MONTH, 1);
          case 1:
            return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
          case 2:
            return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);
          case 3:
            return temporal.with(ChronoField.DAY_OF_YEAR, 1);
          case 4:
            return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());
          case 5:
            return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);
        }
        throw new IllegalStateException("Unreachable");
      };
      return Impl2;
    }(TemporalAdjuster);
    Impl.FIRST_DAY_OF_MONTH = new Impl(0);
    Impl.LAST_DAY_OF_MONTH = new Impl(1);
    Impl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);
    Impl.FIRST_DAY_OF_YEAR = new Impl(3);
    Impl.LAST_DAY_OF_YEAR = new Impl(4);
    Impl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);
    DayOfWeekInMonth = function(_TemporalAdjuster2) {
      _inheritsLoose(DayOfWeekInMonth2, _TemporalAdjuster2);
      function DayOfWeekInMonth2(ordinal, dow) {
        var _this2;
        _this2 = _TemporalAdjuster2.call(this) || this;
        _this2._ordinal = ordinal;
        _this2._dowValue = dow.value();
        return _this2;
      }
      var _proto2 = DayOfWeekInMonth2.prototype;
      _proto2.adjustInto = function adjustInto(temporal) {
        if (this._ordinal >= 0) {
          var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);
          var curDow = temp.get(ChronoField.DAY_OF_WEEK);
          var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);
          dowDiff += (this._ordinal - 1) * 7;
          return temp.plus(dowDiff, ChronoUnit.DAYS);
        } else {
          var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
          var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);
          var daysDiff = this._dowValue - _curDow;
          daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;
          daysDiff -= (-this._ordinal - 1) * 7;
          return _temp.plus(daysDiff, ChronoUnit.DAYS);
        }
      };
      return DayOfWeekInMonth2;
    }(TemporalAdjuster);
    RelativeDayOfWeek = function(_TemporalAdjuster3) {
      _inheritsLoose(RelativeDayOfWeek2, _TemporalAdjuster3);
      function RelativeDayOfWeek2(relative, dayOfWeek) {
        var _this3;
        _this3 = _TemporalAdjuster3.call(this) || this;
        requireNonNull(dayOfWeek, "dayOfWeek");
        _this3._relative = relative;
        _this3._dowValue = dayOfWeek.value();
        return _this3;
      }
      var _proto3 = RelativeDayOfWeek2.prototype;
      _proto3.adjustInto = function adjustInto(temporal) {
        var calDow = temporal.get(ChronoField.DAY_OF_WEEK);
        if (this._relative < 2 && calDow === this._dowValue) {
          return temporal;
        }
        if ((this._relative & 1) === 0) {
          var daysDiff = calDow - this._dowValue;
          return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);
        } else {
          var _daysDiff = this._dowValue - calDow;
          return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);
        }
      };
      return RelativeDayOfWeek2;
    }(TemporalAdjuster);
    IsoChronology = function(_Enum) {
      _inheritsLoose(IsoChronology2, _Enum);
      function IsoChronology2() {
        return _Enum.apply(this, arguments) || this;
      }
      IsoChronology2.isLeapYear = function isLeapYear(prolepticYear) {
        return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);
      };
      var _proto = IsoChronology2.prototype;
      _proto._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {
        requireNonNull(fieldValues, "fieldValues");
        requireNonNull(field, "field");
        var current = fieldValues.get(field);
        if (current != null && current !== value) {
          throw new DateTimeException("Invalid state, field: " + field + " " + current + " conflicts with " + field + " " + value);
        }
        fieldValues.put(field, value);
      };
      _proto.resolveDate = function resolveDate(fieldValues, resolverStyle) {
        if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {
          return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));
        }
        var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);
        if (prolepticMonth != null) {
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);
          }
          this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);
          this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));
        }
        var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);
        if (yoeLong != null) {
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);
          }
          var era = fieldValues.remove(ChronoField.ERA);
          if (era == null) {
            var year = fieldValues.get(ChronoField.YEAR);
            if (resolverStyle === ResolverStyle.STRICT) {
              if (year != null) {
                this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
              } else {
                fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);
              }
            } else {
              this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
            }
          } else if (era === 1) {
            this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);
          } else if (era === 0) {
            this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));
          } else {
            throw new DateTimeException("Invalid value for era: " + era);
          }
        } else if (fieldValues.containsKey(ChronoField.ERA)) {
          ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));
        }
        if (fieldValues.containsKey(ChronoField.YEAR)) {
          if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {
            if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {
              var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);
              var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);
              if (resolverStyle === ResolverStyle.LENIENT) {
                var months = moy - 1;
                var days = dom - 1;
                return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);
              } else if (resolverStyle === ResolverStyle.SMART) {
                ChronoField.DAY_OF_MONTH.checkValidValue(dom);
                if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {
                  dom = Math.min(dom, 30);
                } else if (moy === 2) {
                  dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));
                }
                return LocalDate.of(y, moy, dom);
              } else {
                return LocalDate.of(y, moy, dom);
              }
            }
          }
          if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {
            var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
            if (resolverStyle === ResolverStyle.LENIENT) {
              var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);
              return LocalDate.ofYearDay(_y, 1).plusDays(_days);
            }
            var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));
            return LocalDate.ofYearDay(_y, doy);
          }
          if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {
            if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {
              var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              if (resolverStyle === ResolverStyle.LENIENT) {
                var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
                var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);
                return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);
              }
              var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
              var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
              var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));
              if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {
                throw new DateTimeException("Strict mode rejected date parsed to a different year");
              }
              return date;
            }
            if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {
              var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              if (resolverStyle === ResolverStyle.LENIENT) {
                var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
                var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);
                return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);
              }
              var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
              var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));
              var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));
              if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {
                throw new DateTimeException("Strict mode rejected date parsed to a different month");
              }
              return _date;
            }
          }
        }
        return null;
      };
      _proto.date = function date(temporal) {
        return LocalDate.from(temporal);
      };
      return IsoChronology2;
    }(Enum);
    OffsetTime = function(_Temporal) {
      _inheritsLoose(OffsetTime2, _Temporal);
      OffsetTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof OffsetTime2) {
          return temporal;
        } else if (temporal instanceof OffsetDateTime) {
          return temporal.toOffsetTime();
        }
        try {
          var time = LocalTime.from(temporal);
          var offset = ZoneOffset.from(temporal);
          return new OffsetTime2(time, offset);
        } catch (ex) {
          throw new DateTimeException("Unable to obtain OffsetTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      OffsetTime2.now = function now(clockOrZone) {
        if (arguments.length === 0) {
          return OffsetTime2._now(Clock.systemDefaultZone());
        } else if (clockOrZone instanceof Clock) {
          return OffsetTime2._now(clockOrZone);
        } else {
          return OffsetTime2._now(Clock.system(clockOrZone));
        }
      };
      OffsetTime2._now = function _now(clock) {
        requireNonNull(clock, "clock");
        var now = clock.instant();
        return OffsetTime2.ofInstant(now, clock.zone().rules().offset(now));
      };
      OffsetTime2.of = function of() {
        if (arguments.length <= 2) {
          return OffsetTime2.ofTimeAndOffset.apply(this, arguments);
        } else {
          return OffsetTime2.ofNumbers.apply(this, arguments);
        }
      };
      OffsetTime2.ofNumbers = function ofNumbers(hour, minute, second, nanoOfSecond, offset) {
        var time = LocalTime.of(hour, minute, second, nanoOfSecond);
        return new OffsetTime2(time, offset);
      };
      OffsetTime2.ofTimeAndOffset = function ofTimeAndOffset(time, offset) {
        return new OffsetTime2(time, offset);
      };
      OffsetTime2.ofInstant = function ofInstant(instant, zone) {
        requireNonNull(instant, "instant");
        requireInstance(instant, Instant, "instant");
        requireNonNull(zone, "zone");
        requireInstance(zone, ZoneId, "zone");
        var rules = zone.rules();
        var offset = rules.offset(instant);
        var secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;
        secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;
        if (secsOfDay < 0) {
          secsOfDay += LocalTime.SECONDS_PER_DAY;
        }
        var time = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
        return new OffsetTime2(time, offset);
      };
      OffsetTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_OFFSET_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, OffsetTime2.FROM);
      };
      function OffsetTime2(time, offset) {
        var _this;
        _this = _Temporal.call(this) || this;
        requireNonNull(time, "time");
        requireInstance(time, LocalTime, "time");
        requireNonNull(offset, "offset");
        requireInstance(offset, ZoneOffset, "offset");
        _this._time = time;
        _this._offset = offset;
        return _this;
      }
      var _proto = OffsetTime2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
      };
      _proto.atDate = function atDate(date) {
        return OffsetDateTime.of(date, this._time, this._offset);
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this, OffsetTime2.FROM);
      };
      _proto.get = function get(field) {
        return _Temporal.prototype.get.call(this, field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return this._offset.totalSeconds();
          }
          return this._time.getLong(field);
        }
        return field.getFrom(this);
      };
      _proto.hour = function hour() {
        return this._time.hour();
      };
      _proto.minute = function minute() {
        return this._time.minute();
      };
      _proto.second = function second() {
        return this._time.second();
      };
      _proto.nano = function nano() {
        return this._time.nano();
      };
      _proto.offset = function offset() {
        return this._offset;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        return this._toEpochNano() > other._toEpochNano();
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        return this._toEpochNano() < other._toEpochNano();
      };
      _proto.isEqual = function isEqual(other) {
        requireNonNull(other, "other");
        return this._toEpochNano() === other._toEpochNano();
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.minusHours = function minusHours(hours) {
        return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);
      };
      _proto._minusAmount = function _minusAmount(amount) {
        requireNonNull(amount);
        return amount.subtractFrom(this);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this.plus(-1 * amountToSubtract, unit);
      };
      _proto._plusAmount = function _plusAmount(amount) {
        requireNonNull(amount);
        return amount.addTo(this);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        if (unit instanceof ChronoUnit) {
          return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusHours = function plusHours(hours) {
        return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
          return this.offset();
        } else if (_query === TemporalQueries.localTime()) {
          return this._time;
        } else if (_query === TemporalQueries.chronology() || _query === TemporalQueries.localDate() || _query === TemporalQueries.zoneId()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return field.range();
          }
          return this._time.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._time;
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = OffsetTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var nanosUntil = end._toEpochNano() - this._toEpochNano();
          switch (unit) {
            case ChronoUnit.NANOS:
              return nanosUntil;
            case ChronoUnit.MICROS:
              return MathUtil.intDiv(nanosUntil, 1e3);
            case ChronoUnit.MILLIS:
              return MathUtil.intDiv(nanosUntil, 1e6);
            case ChronoUnit.SECONDS:
              return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);
            case ChronoUnit.MINUTES:
              return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);
            case ChronoUnit.HOURS:
              return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);
            case ChronoUnit.HALF_DAYS:
              return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.withHour = function withHour(hour) {
        return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);
      };
      _proto.withMinute = function withMinute(minute) {
        return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);
      };
      _proto.withSecond = function withSecond(second) {
        return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);
      };
      _proto.withNano = function withNano(nano) {
        return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);
      };
      _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
        requireNonNull(offset, "offset");
        if (offset.equals(this._offset)) {
          return this;
        }
        var difference = offset.totalSeconds() - this._offset.totalSeconds();
        var adjusted = this._time.plusSeconds(difference);
        return new OffsetTime2(adjusted, offset);
      };
      _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
        return offset != null && offset.equals(this._offset) ? this : new OffsetTime2(this._time, offset);
      };
      _proto._toEpochNano = function _toEpochNano() {
        var nod = this._time.toNanoOfDay();
        var offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;
        return nod - offsetNanos;
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalTime) {
          return this._withLocalTimeOffset(adjuster, this._offset);
        } else if (adjuster instanceof ZoneOffset) {
          return this._withLocalTimeOffset(this._time, adjuster);
        } else if (adjuster instanceof OffsetTime2) {
          return adjuster;
        }
        return adjuster.adjustInto(this);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));
          }
          return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);
        }
        return field.adjustInto(this, newValue);
      };
      _proto._withLocalTimeOffset = function _withLocalTimeOffset(time, offset) {
        if (this._time === time && this._offset.equals(offset)) {
          return this;
        }
        return new OffsetTime2(time, offset);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, OffsetTime2, "other");
        if (this._offset.equals(other._offset)) {
          return this._time.compareTo(other._time);
        }
        var compare = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());
        if (compare === 0) {
          return this._time.compareTo(other._time);
        }
        return compare;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof OffsetTime2) {
          return this._time.equals(other._time) && this._offset.equals(other._offset);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._time.hashCode() ^ this._offset.hashCode();
      };
      _proto.toString = function toString() {
        return this._time.toString() + this._offset.toString();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return OffsetTime2;
    }(Temporal);
    ChronoZonedDateTime = function(_Temporal) {
      _inheritsLoose(ChronoZonedDateTime2, _Temporal);
      function ChronoZonedDateTime2() {
        return _Temporal.apply(this, arguments) || this;
      }
      var _proto = ChronoZonedDateTime2.prototype;
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
          return this.zone();
        } else if (_query === TemporalQueries.chronology()) {
          return this.toLocalDate().chronology();
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.offset()) {
          return this.offset();
        } else if (_query === TemporalQueries.localDate()) {
          return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
        } else if (_query === TemporalQueries.localTime()) {
          return this.toLocalTime();
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      _proto.toInstant = function toInstant() {
        return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());
      };
      _proto.toEpochSecond = function toEpochSecond() {
        var epochDay = this.toLocalDate().toEpochDay();
        var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
        secs -= this.offset().totalSeconds();
        return secs;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
        if (cmp === 0) {
          cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
          if (cmp === 0) {
            cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
            if (cmp === 0) {
              cmp = strcmp(this.zone().id(), other.zone().id());
            }
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
      };
      _proto.isEqual = function isEqual(other) {
        requireNonNull(other, "other");
        return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ChronoZonedDateTime2) {
          return this.compareTo(other) === 0;
        }
        return false;
      };
      return ChronoZonedDateTime2;
    }(Temporal);
    ZonedDateTime = function(_ChronoZonedDateTime) {
      _inheritsLoose(ZonedDateTime2, _ChronoZonedDateTime);
      ZonedDateTime2.now = function now(clockOrZone) {
        var clock;
        if (clockOrZone instanceof ZoneId) {
          clock = Clock.system(clockOrZone);
        } else {
          clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;
        }
        return ZonedDateTime2.ofInstant(clock.instant(), clock.zone());
      };
      ZonedDateTime2.of = function of() {
        if (arguments.length <= 2) {
          return ZonedDateTime2.of2.apply(this, arguments);
        } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {
          return ZonedDateTime2.of3.apply(this, arguments);
        } else {
          return ZonedDateTime2.of8.apply(this, arguments);
        }
      };
      ZonedDateTime2.of3 = function of3(date, time, zone) {
        return ZonedDateTime2.of2(LocalDateTime.of(date, time), zone);
      };
      ZonedDateTime2.of2 = function of2(localDateTime, zone) {
        return ZonedDateTime2.ofLocal(localDateTime, zone, null);
      };
      ZonedDateTime2.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {
        var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
        return ZonedDateTime2.ofLocal(dt, zone, null);
      };
      ZonedDateTime2.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(zone, "zone");
        if (zone instanceof ZoneOffset) {
          return new ZonedDateTime2(localDateTime, zone, zone);
        }
        var offset = null;
        var rules = zone.rules();
        var validOffsets = rules.validOffsets(localDateTime);
        if (validOffsets.length === 1) {
          offset = validOffsets[0];
        } else if (validOffsets.length === 0) {
          var trans = rules.transition(localDateTime);
          localDateTime = localDateTime.plusSeconds(trans.duration().seconds());
          offset = trans.offsetAfter();
        } else {
          if (preferredOffset != null && validOffsets.some(function(validOffset) {
            return validOffset.equals(preferredOffset);
          })) {
            offset = preferredOffset;
          } else {
            offset = requireNonNull(validOffsets[0], "offset");
          }
        }
        return new ZonedDateTime2(localDateTime, offset, zone);
      };
      ZonedDateTime2.ofInstant = function ofInstant() {
        if (arguments.length === 2) {
          return ZonedDateTime2.ofInstant2.apply(this, arguments);
        } else {
          return ZonedDateTime2.ofInstant3.apply(this, arguments);
        }
      };
      ZonedDateTime2.ofInstant2 = function ofInstant2(instant, zone) {
        requireNonNull(instant, "instant");
        requireNonNull(zone, "zone");
        return ZonedDateTime2._create(instant.epochSecond(), instant.nano(), zone);
      };
      ZonedDateTime2.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        return ZonedDateTime2._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);
      };
      ZonedDateTime2._create = function _create(epochSecond, nanoOfSecond, zone) {
        var rules = zone.rules();
        var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);
        var offset = rules.offset(instant);
        var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);
        return new ZonedDateTime2(ldt, offset, zone);
      };
      ZonedDateTime2.ofStrict = function ofStrict(localDateTime, offset, zone) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        var rules = zone.rules();
        if (rules.isValidOffset(localDateTime, offset) === false) {
          var trans = rules.transition(localDateTime);
          if (trans != null && trans.isGap()) {
            throw new DateTimeException("LocalDateTime " + localDateTime + " does not exist in zone " + zone + " due to a gap in the local time-line, typically caused by daylight savings");
          }
          throw new DateTimeException('ZoneOffset "' + offset + '" is not valid for LocalDateTime "' + localDateTime + '" in zone "' + zone + '"');
        }
        return new ZonedDateTime2(localDateTime, offset, zone);
      };
      ZonedDateTime2.ofLenient = function ofLenient(localDateTime, offset, zone) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        if (zone instanceof ZoneOffset && offset.equals(zone) === false) {
          throw new IllegalArgumentException("ZoneId must match ZoneOffset");
        }
        return new ZonedDateTime2(localDateTime, offset, zone);
      };
      ZonedDateTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof ZonedDateTime2) {
          return temporal;
        }
        var zone = ZoneId.from(temporal);
        if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {
          var zdt = ZonedDateTime2._from(temporal, zone);
          if (zdt != null)
            return zdt;
        }
        var ldt = LocalDateTime.from(temporal);
        return ZonedDateTime2.of2(ldt, zone);
      };
      ZonedDateTime2._from = function _from(temporal, zone) {
        try {
          return ZonedDateTime2.__from(temporal, zone);
        } catch (ex) {
          if (!(ex instanceof DateTimeException))
            throw ex;
        }
      };
      ZonedDateTime2.__from = function __from(temporal, zone) {
        var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);
        var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
        return ZonedDateTime2._create(epochSecond, nanoOfSecond, zone);
      };
      ZonedDateTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, ZonedDateTime2.FROM);
      };
      function ZonedDateTime2(dateTime, offset, zone) {
        var _this;
        requireNonNull(dateTime, "dateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        _this = _ChronoZonedDateTime.call(this) || this;
        _this._dateTime = dateTime;
        _this._offset = offset;
        _this._zone = zone;
        return _this;
      }
      var _proto = ZonedDateTime2.prototype;
      _proto._resolveLocal = function _resolveLocal(newDateTime) {
        requireNonNull(newDateTime, "newDateTime");
        return ZonedDateTime2.ofLocal(newDateTime, this._zone, this._offset);
      };
      _proto._resolveInstant = function _resolveInstant(newDateTime) {
        return ZonedDateTime2.ofInstant3(newDateTime, this._offset, this._zone);
      };
      _proto._resolveOffset = function _resolveOffset(offset) {
        if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {
          return new ZonedDateTime2(this._dateTime, offset, this._zone);
        }
        return this;
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return true;
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
            return field.range();
          }
          return this._dateTime.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              return this.toEpochSecond();
            case ChronoField.OFFSET_SECONDS:
              return this._offset.totalSeconds();
          }
          return this._dateTime.getLong(field);
        }
        requireNonNull(field, "field");
        return field.getFrom(this);
      };
      _proto.offset = function offset() {
        return this._offset;
      };
      _proto.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {
        var trans = this._zone.rules().transition(this._dateTime);
        if (trans != null && trans.isOverlap()) {
          var earlierOffset = trans.offsetBefore();
          if (earlierOffset.equals(this._offset) === false) {
            return new ZonedDateTime2(this._dateTime, earlierOffset, this._zone);
          }
        }
        return this;
      };
      _proto.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {
        var trans = this._zone.rules().transition(this.toLocalDateTime());
        if (trans != null) {
          var laterOffset = trans.offsetAfter();
          if (laterOffset.equals(this._offset) === false) {
            return new ZonedDateTime2(this._dateTime, laterOffset, this._zone);
          }
        }
        return this;
      };
      _proto.zone = function zone() {
        return this._zone;
      };
      _proto.withZoneSameLocal = function withZoneSameLocal(zone) {
        requireNonNull(zone, "zone");
        return this._zone.equals(zone) ? this : ZonedDateTime2.ofLocal(this._dateTime, zone, this._offset);
      };
      _proto.withZoneSameInstant = function withZoneSameInstant(zone) {
        requireNonNull(zone, "zone");
        return this._zone.equals(zone) ? this : ZonedDateTime2._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);
      };
      _proto.withFixedOffsetZone = function withFixedOffsetZone() {
        return this._zone.equals(this._offset) ? this : new ZonedDateTime2(this._dateTime, this._offset, this._offset);
      };
      _proto.year = function year() {
        return this._dateTime.year();
      };
      _proto.monthValue = function monthValue() {
        return this._dateTime.monthValue();
      };
      _proto.month = function month() {
        return this._dateTime.month();
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._dateTime.dayOfMonth();
      };
      _proto.dayOfYear = function dayOfYear() {
        return this._dateTime.dayOfYear();
      };
      _proto.dayOfWeek = function dayOfWeek() {
        return this._dateTime.dayOfWeek();
      };
      _proto.hour = function hour() {
        return this._dateTime.hour();
      };
      _proto.minute = function minute() {
        return this._dateTime.minute();
      };
      _proto.second = function second() {
        return this._dateTime.second();
      };
      _proto.nano = function nano() {
        return this._dateTime.nano();
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        if (adjuster instanceof LocalDate) {
          return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));
        } else if (adjuster instanceof LocalTime) {
          return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));
        } else if (adjuster instanceof LocalDateTime) {
          return this._resolveLocal(adjuster);
        } else if (adjuster instanceof Instant) {
          var instant = adjuster;
          return ZonedDateTime2._create(instant.epochSecond(), instant.nano(), this._zone);
        } else if (adjuster instanceof ZoneOffset) {
          return this._resolveOffset(adjuster);
        }
        return _ChronoZonedDateTime.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              return ZonedDateTime2._create(newValue, this.nano(), this._zone);
            case ChronoField.OFFSET_SECONDS: {
              var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));
              return this._resolveOffset(offset);
            }
          }
          return this._resolveLocal(this._dateTime.with(field, newValue));
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        return this._resolveLocal(this._dateTime.withYear(year));
      };
      _proto.withMonth = function withMonth(month) {
        return this._resolveLocal(this._dateTime.withMonth(month));
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));
      };
      _proto.withHour = function withHour(hour) {
        return this._resolveLocal(this._dateTime.withHour(hour));
      };
      _proto.withMinute = function withMinute(minute) {
        return this._resolveLocal(this._dateTime.withMinute(minute));
      };
      _proto.withSecond = function withSecond(second) {
        return this._resolveLocal(this._dateTime.withSecond(second));
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._resolveLocal(this._dateTime.truncatedTo(unit));
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        if (unit instanceof ChronoUnit) {
          if (unit.isDateBased()) {
            return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));
          } else {
            return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));
          }
        }
        requireNonNull(unit, "unit");
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(years) {
        return this._resolveLocal(this._dateTime.plusYears(years));
      };
      _proto.plusMonths = function plusMonths(months) {
        return this._resolveLocal(this._dateTime.plusMonths(months));
      };
      _proto.plusWeeks = function plusWeeks(weeks) {
        return this._resolveLocal(this._dateTime.plusWeeks(weeks));
      };
      _proto.plusDays = function plusDays(days) {
        return this._resolveLocal(this._dateTime.plusDays(days));
      };
      _proto.plusHours = function plusHours(hours) {
        return this._resolveInstant(this._dateTime.plusHours(hours));
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._resolveInstant(this._dateTime.plusMinutes(minutes));
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._resolveInstant(this._dateTime.plusSeconds(seconds));
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._resolveInstant(this._dateTime.plusNanos(nanos));
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(years) {
        return this.plusYears(-1 * years);
      };
      _proto.minusMonths = function minusMonths(months) {
        return this.plusMonths(-1 * months);
      };
      _proto.minusWeeks = function minusWeeks(weeks) {
        return this.plusWeeks(-1 * weeks);
      };
      _proto.minusDays = function minusDays(days) {
        return this.plusDays(-1 * days);
      };
      _proto.minusHours = function minusHours(hours) {
        return this.plusHours(-1 * hours);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this.plusMinutes(-1 * minutes);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this.plusSeconds(-1 * seconds);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this.plusNanos(-1 * nanos);
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.localDate()) {
          return this.toLocalDate();
        }
        requireNonNull(_query, "query");
        return _ChronoZonedDateTime.prototype.query.call(this, _query);
      };
      _proto.until = function until(endExclusive, unit) {
        var end = ZonedDateTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          end = end.withZoneSameInstant(this._zone);
          if (unit.isDateBased()) {
            return this._dateTime.until(end._dateTime, unit);
          } else {
            var difference = this._offset.totalSeconds() - end._offset.totalSeconds();
            var adjustedEnd = end._dateTime.plusSeconds(difference);
            return this._dateTime.until(adjustedEnd, unit);
          }
        }
        return unit.between(this, end);
      };
      _proto.toLocalDateTime = function toLocalDateTime() {
        return this._dateTime;
      };
      _proto.toLocalDate = function toLocalDate() {
        return this._dateTime.toLocalDate();
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._dateTime.toLocalTime();
      };
      _proto.toOffsetDateTime = function toOffsetDateTime() {
        return OffsetDateTime.of(this._dateTime, this._offset);
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ZonedDateTime2) {
          return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());
      };
      _proto.toString = function toString() {
        var str = this._dateTime.toString() + this._offset.toString();
        if (this._offset !== this._zone) {
          str += "[" + this._zone.toString() + "]";
        }
        return str;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        return _ChronoZonedDateTime.prototype.format.call(this, formatter);
      };
      return ZonedDateTime2;
    }(ChronoZonedDateTime);
    OffsetDateTime = function(_Temporal) {
      _inheritsLoose(OffsetDateTime2, _Temporal);
      OffsetDateTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof OffsetDateTime2) {
          return temporal;
        }
        try {
          var offset = ZoneOffset.from(temporal);
          try {
            var ldt = LocalDateTime.from(temporal);
            return OffsetDateTime2.of(ldt, offset);
          } catch (_2) {
            var instant = Instant.from(temporal);
            return OffsetDateTime2.ofInstant(instant, offset);
          }
        } catch (ex) {
          throw new DateTimeException("Unable to obtain OffsetDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      OffsetDateTime2.now = function now(clockOrZone) {
        if (arguments.length === 0) {
          return OffsetDateTime2.now(Clock.systemDefaultZone());
        } else {
          requireNonNull(clockOrZone, "clockOrZone");
          if (clockOrZone instanceof ZoneId) {
            return OffsetDateTime2.now(Clock.system(clockOrZone));
          } else if (clockOrZone instanceof Clock) {
            var now2 = clockOrZone.instant();
            return OffsetDateTime2.ofInstant(now2, clockOrZone.zone().rules().offset(now2));
          } else {
            throw new IllegalArgumentException("clockOrZone must be an instance of ZoneId or Clock");
          }
        }
      };
      OffsetDateTime2.of = function of() {
        if (arguments.length <= 2) {
          return OffsetDateTime2.ofDateTime.apply(this, arguments);
        } else if (arguments.length === 3) {
          return OffsetDateTime2.ofDateAndTime.apply(this, arguments);
        } else {
          return OffsetDateTime2.ofNumbers.apply(this, arguments);
        }
      };
      OffsetDateTime2.ofDateTime = function ofDateTime(dateTime, offset) {
        return new OffsetDateTime2(dateTime, offset);
      };
      OffsetDateTime2.ofDateAndTime = function ofDateAndTime(date, time, offset) {
        var dt = LocalDateTime.of(date, time);
        return new OffsetDateTime2(dt, offset);
      };
      OffsetDateTime2.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, offset) {
        if (hour === void 0) {
          hour = 0;
        }
        if (minute === void 0) {
          minute = 0;
        }
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
        return new OffsetDateTime2(dt, offset);
      };
      OffsetDateTime2.ofInstant = function ofInstant(instant, zone) {
        requireNonNull(instant, "instant");
        requireNonNull(zone, "zone");
        var rules = zone.rules();
        var offset = rules.offset(instant);
        var ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
        return new OffsetDateTime2(ldt, offset);
      };
      OffsetDateTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, OffsetDateTime2.FROM);
      };
      function OffsetDateTime2(dateTime, offset) {
        var _this;
        _this = _Temporal.call(this) || this;
        requireNonNull(dateTime, "dateTime");
        requireInstance(dateTime, LocalDateTime, "dateTime");
        requireNonNull(offset, "offset");
        requireInstance(offset, ZoneOffset, "offset");
        _this._dateTime = dateTime;
        _this._offset = offset;
        return _this;
      }
      var _proto = OffsetDateTime2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
      };
      _proto.until = function until(endExclusive, unit) {
        var end = OffsetDateTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          end = end.withOffsetSameInstant(this._offset);
          return this._dateTime.until(end._dateTime, unit);
        }
        return unit.between(this, end);
      };
      _proto.atZoneSameInstant = function atZoneSameInstant(zone) {
        return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);
      };
      _proto.atZoneSimilarLocal = function atZoneSimilarLocal(zone) {
        return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
          return this.offset();
        } else if (_query === TemporalQueries.localDate()) {
          return this.toLocalDate();
        } else if (_query === TemporalQueries.localTime()) {
          return this.toLocalTime();
        } else if (_query === TemporalQueries.zoneId()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.get = function get(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              throw new DateTimeException("Field too large for an int: " + field);
            case ChronoField.OFFSET_SECONDS:
              return this.offset().totalSeconds();
          }
          return this._dateTime.get(field);
        }
        return _Temporal.prototype.get.call(this, field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              return this.toEpochSecond();
            case ChronoField.OFFSET_SECONDS:
              return this.offset().totalSeconds();
          }
          return this._dateTime.getLong(field);
        }
        return field.getFrom(this);
      };
      _proto.offset = function offset() {
        return this._offset;
      };
      _proto.year = function year() {
        return this._dateTime.year();
      };
      _proto.monthValue = function monthValue() {
        return this._dateTime.monthValue();
      };
      _proto.month = function month() {
        return this._dateTime.month();
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._dateTime.dayOfMonth();
      };
      _proto.dayOfYear = function dayOfYear() {
        return this._dateTime.dayOfYear();
      };
      _proto.dayOfWeek = function dayOfWeek() {
        return this._dateTime.dayOfWeek();
      };
      _proto.hour = function hour() {
        return this._dateTime.hour();
      };
      _proto.minute = function minute() {
        return this._dateTime.minute();
      };
      _proto.second = function second() {
        return this._dateTime.second();
      };
      _proto.nano = function nano() {
        return this._dateTime.nano();
      };
      _proto.toLocalDateTime = function toLocalDateTime() {
        return this._dateTime;
      };
      _proto.toLocalDate = function toLocalDate() {
        return this._dateTime.toLocalDate();
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._dateTime.toLocalTime();
      };
      _proto.toOffsetTime = function toOffsetTime() {
        return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);
      };
      _proto.toZonedDateTime = function toZonedDateTime() {
        return ZonedDateTime.of(this._dateTime, this._offset);
      };
      _proto.toInstant = function toInstant() {
        return this._dateTime.toInstant(this._offset);
      };
      _proto.toEpochSecond = function toEpochSecond() {
        return this._dateTime.toEpochSecond(this._offset);
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
            return field.range();
          }
          return this._dateTime.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster);
        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {
          return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);
        } else if (adjuster instanceof Instant) {
          return OffsetDateTime2.ofInstant(adjuster, this._offset);
        } else if (adjuster instanceof ZoneOffset) {
          return this._withDateTimeOffset(this._dateTime, adjuster);
        } else if (adjuster instanceof OffsetDateTime2) {
          return adjuster;
        }
        return adjuster.adjustInto(this);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field);
        if (field instanceof ChronoField) {
          var f = field;
          switch (f) {
            case ChronoField.INSTANT_SECONDS:
              return OffsetDateTime2.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);
            case ChronoField.OFFSET_SECONDS: {
              return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));
            }
          }
          return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);
        }
        return field.adjustInto(this, newValue);
      };
      _proto._withDateTimeOffset = function _withDateTimeOffset(dateTime, offset) {
        if (this._dateTime === dateTime && this._offset.equals(offset)) {
          return this;
        }
        return new OffsetDateTime2(dateTime, offset);
      };
      _proto.withYear = function withYear(year) {
        return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);
      };
      _proto.withMonth = function withMonth(month) {
        return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);
      };
      _proto.withHour = function withHour(hour) {
        return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);
      };
      _proto.withMinute = function withMinute(minute) {
        return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);
      };
      _proto.withSecond = function withSecond(second) {
        return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);
      };
      _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
        requireNonNull(offset, "offset");
        return this._withDateTimeOffset(this._dateTime, offset);
      };
      _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
        requireNonNull(offset, "offset");
        if (offset.equals(this._offset)) {
          return this;
        }
        var difference = offset.totalSeconds() - this._offset.totalSeconds();
        var adjusted = this._dateTime.plusSeconds(difference);
        return new OffsetDateTime2(adjusted, offset);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);
      };
      _proto._plusAmount = function _plusAmount(amount) {
        requireNonNull(amount, "amount");
        return amount.addTo(this);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        if (unit instanceof ChronoUnit) {
          return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(years) {
        return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);
      };
      _proto.plusMonths = function plusMonths(months) {
        return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);
      };
      _proto.plusWeeks = function plusWeeks(weeks) {
        return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);
      };
      _proto.plusDays = function plusDays(days) {
        return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);
      };
      _proto.plusHours = function plusHours(hours) {
        return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);
      };
      _proto._minusAmount = function _minusAmount(amount) {
        requireNonNull(amount);
        return amount.subtractFrom(this);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this.plus(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(years) {
        return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);
      };
      _proto.minusMonths = function minusMonths(months) {
        return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);
      };
      _proto.minusWeeks = function minusWeeks(weeks) {
        return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);
      };
      _proto.minusDays = function minusDays(days) {
        return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);
      };
      _proto.minusHours = function minusHours(hours) {
        return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, OffsetDateTime2, "other");
        if (this.offset().equals(other.offset())) {
          return this.toLocalDateTime().compareTo(other.toLocalDateTime());
        }
        var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
        if (cmp === 0) {
          cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
          if (cmp === 0) {
            cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
      };
      _proto.isEqual = function isEqual(other) {
        requireNonNull(other, "other");
        return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof OffsetDateTime2) {
          return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._dateTime.hashCode() ^ this._offset.hashCode();
      };
      _proto.toString = function toString() {
        return this._dateTime.toString() + this._offset.toString();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return OffsetDateTime2;
    }(Temporal);
    DAYS_PER_CYCLE = 146097;
    DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);
    LocalDate = function(_ChronoLocalDate) {
      _inheritsLoose(LocalDate2, _ChronoLocalDate);
      LocalDate2.now = function now(clockOrZone) {
        var clock;
        if (clockOrZone == null) {
          clock = Clock.systemDefaultZone();
        } else if (clockOrZone instanceof ZoneId) {
          clock = Clock.system(clockOrZone);
        } else {
          clock = clockOrZone;
        }
        return LocalDate2.ofInstant(clock.instant(), clock.zone());
      };
      LocalDate2.ofInstant = function ofInstant(instant, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        requireNonNull(instant, "instant");
        var offset = zone.rules().offset(instant);
        var epochSec = instant.epochSecond() + offset.totalSeconds();
        var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);
        return LocalDate2.ofEpochDay(epochDay);
      };
      LocalDate2.of = function of(year, month, dayOfMonth) {
        return new LocalDate2(year, month, dayOfMonth);
      };
      LocalDate2.ofYearDay = function ofYearDay(year, dayOfYear) {
        ChronoField.YEAR.checkValidValue(year);
        var leap = IsoChronology.isLeapYear(year);
        if (dayOfYear === 366 && leap === false) {
          assert(false, "Invalid date 'DayOfYear 366' as '" + year + "' is not a leap year", DateTimeException);
        }
        var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));
        var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;
        if (dayOfYear > monthEnd) {
          moy = moy.plus(1);
        }
        var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;
        return new LocalDate2(year, moy.value(), dom);
      };
      LocalDate2.ofEpochDay = function ofEpochDay(epochDay) {
        if (epochDay === void 0) {
          epochDay = 0;
        }
        var adjust, adjustCycles, doyEst, yearEst, zeroDay;
        zeroDay = epochDay + DAYS_0000_TO_1970;
        zeroDay -= 60;
        adjust = 0;
        if (zeroDay < 0) {
          adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;
          adjust = adjustCycles * 400;
          zeroDay += -adjustCycles * DAYS_PER_CYCLE;
        }
        yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);
        doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
        if (doyEst < 0) {
          yearEst--;
          doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
        }
        yearEst += adjust;
        var marchDoy0 = doyEst;
        var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);
        var month = (marchMonth0 + 2) % 12 + 1;
        var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;
        yearEst += MathUtil.intDiv(marchMonth0, 10);
        var year = yearEst;
        return new LocalDate2(year, month, dom);
      };
      LocalDate2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        var date = temporal.query(TemporalQueries.localDate());
        if (date == null) {
          throw new DateTimeException("Unable to obtain LocalDate from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
        return date;
      };
      LocalDate2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_LOCAL_DATE;
        }
        assert(formatter != null, "formatter", NullPointerException);
        return formatter.parse(text, LocalDate2.FROM);
      };
      LocalDate2._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {
        switch (month) {
          case 2:
            day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);
            break;
          case 4:
          case 6:
          case 9:
          case 11:
            day = Math.min(day, 30);
            break;
        }
        return LocalDate2.of(year, month, day);
      };
      function LocalDate2(year, month, dayOfMonth) {
        var _this;
        _this = _ChronoLocalDate.call(this) || this;
        requireNonNull(year, "year");
        requireNonNull(month, "month");
        requireNonNull(dayOfMonth, "dayOfMonth");
        if (month instanceof Month) {
          month = month.value();
        }
        _this._year = MathUtil.safeToInt(year);
        _this._month = MathUtil.safeToInt(month);
        _this._day = MathUtil.safeToInt(dayOfMonth);
        LocalDate2._validate(_this._year, _this._month, _this._day);
        return _this;
      }
      LocalDate2._validate = function _validate(year, month, dayOfMonth) {
        var dom;
        ChronoField.YEAR.checkValidValue(year);
        ChronoField.MONTH_OF_YEAR.checkValidValue(month);
        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
        if (dayOfMonth > 28) {
          dom = 31;
          switch (month) {
            case 2:
              dom = IsoChronology.isLeapYear(year) ? 29 : 28;
              break;
            case 4:
            case 6:
            case 9:
            case 11:
              dom = 30;
          }
          if (dayOfMonth > dom) {
            if (dayOfMonth === 29) {
              assert(false, "Invalid date 'February 29' as '" + year + "' is not a leap year", DateTimeException);
            } else {
              assert(false, "Invalid date '" + year + "' '" + month + "' '" + dayOfMonth + "'", DateTimeException);
            }
          }
        }
      };
      var _proto = LocalDate2.prototype;
      _proto.isSupported = function isSupported(field) {
        return _ChronoLocalDate.prototype.isSupported.call(this, field);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field.isDateBased()) {
            switch (field) {
              case ChronoField.DAY_OF_MONTH:
                return ValueRange.of(1, this.lengthOfMonth());
              case ChronoField.DAY_OF_YEAR:
                return ValueRange.of(1, this.lengthOfYear());
              case ChronoField.ALIGNED_WEEK_OF_MONTH:
                return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);
              case ChronoField.YEAR_OF_ERA:
                return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
            }
            return field.range();
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        assert(field != null, "", NullPointerException);
        if (field instanceof ChronoField) {
          return this._get0(field);
        }
        return field.getFrom(this);
      };
      _proto._get0 = function _get0(field) {
        switch (field) {
          case ChronoField.DAY_OF_WEEK:
            return this.dayOfWeek().value();
          case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
            return MathUtil.intMod(this._day - 1, 7) + 1;
          case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
            return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;
          case ChronoField.DAY_OF_MONTH:
            return this._day;
          case ChronoField.DAY_OF_YEAR:
            return this.dayOfYear();
          case ChronoField.EPOCH_DAY:
            return this.toEpochDay();
          case ChronoField.ALIGNED_WEEK_OF_MONTH:
            return MathUtil.intDiv(this._day - 1, 7) + 1;
          case ChronoField.ALIGNED_WEEK_OF_YEAR:
            return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;
          case ChronoField.MONTH_OF_YEAR:
            return this._month;
          case ChronoField.PROLEPTIC_MONTH:
            return this._prolepticMonth();
          case ChronoField.YEAR_OF_ERA:
            return this._year >= 1 ? this._year : 1 - this._year;
          case ChronoField.YEAR:
            return this._year;
          case ChronoField.ERA:
            return this._year >= 1 ? 1 : 0;
        }
        throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
      };
      _proto._prolepticMonth = function _prolepticMonth() {
        return this._year * 12 + (this._month - 1);
      };
      _proto.chronology = function chronology() {
        return IsoChronology.INSTANCE;
      };
      _proto.year = function year() {
        return this._year;
      };
      _proto.monthValue = function monthValue() {
        return this._month;
      };
      _proto.month = function month() {
        return Month.of(this._month);
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._day;
      };
      _proto.dayOfYear = function dayOfYear() {
        return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;
      };
      _proto.dayOfWeek = function dayOfWeek() {
        var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);
        return DayOfWeek.of(dow0 + 1);
      };
      _proto.isLeapYear = function isLeapYear() {
        return IsoChronology.isLeapYear(this._year);
      };
      _proto.lengthOfMonth = function lengthOfMonth() {
        switch (this._month) {
          case 2:
            return this.isLeapYear() ? 29 : 28;
          case 4:
          case 6:
          case 9:
          case 11:
            return 30;
          default:
            return 31;
        }
      };
      _proto.lengthOfYear = function lengthOfYear() {
        return this.isLeapYear() ? 366 : 365;
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalDate2) {
          return adjuster;
        }
        return _ChronoLocalDate.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        assert(field != null, "field", NullPointerException);
        if (field instanceof ChronoField) {
          var f = field;
          f.checkValidValue(newValue);
          switch (f) {
            case ChronoField.DAY_OF_WEEK:
              return this.plusDays(newValue - this.dayOfWeek().value());
            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
              return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));
            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
              return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
            case ChronoField.DAY_OF_MONTH:
              return this.withDayOfMonth(newValue);
            case ChronoField.DAY_OF_YEAR:
              return this.withDayOfYear(newValue);
            case ChronoField.EPOCH_DAY:
              return LocalDate2.ofEpochDay(newValue);
            case ChronoField.ALIGNED_WEEK_OF_MONTH:
              return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));
            case ChronoField.ALIGNED_WEEK_OF_YEAR:
              return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));
            case ChronoField.MONTH_OF_YEAR:
              return this.withMonth(newValue);
            case ChronoField.PROLEPTIC_MONTH:
              return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
            case ChronoField.YEAR_OF_ERA:
              return this.withYear(this._year >= 1 ? newValue : 1 - newValue);
            case ChronoField.YEAR:
              return this.withYear(newValue);
            case ChronoField.ERA:
              return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        if (this._year === year) {
          return this;
        }
        ChronoField.YEAR.checkValidValue(year);
        return LocalDate2._resolvePreviousValid(year, this._month, this._day);
      };
      _proto.withMonth = function withMonth(month) {
        var m = month instanceof Month ? month.value() : month;
        if (this._month === m) {
          return this;
        }
        ChronoField.MONTH_OF_YEAR.checkValidValue(m);
        return LocalDate2._resolvePreviousValid(this._year, m, this._day);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        if (this._day === dayOfMonth) {
          return this;
        }
        return LocalDate2.of(this._year, this._month, dayOfMonth);
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        if (this.dayOfYear() === dayOfYear) {
          return this;
        }
        return LocalDate2.ofYearDay(this._year, dayOfYear);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.DAYS:
              return this.plusDays(amountToAdd);
            case ChronoUnit.WEEKS:
              return this.plusWeeks(amountToAdd);
            case ChronoUnit.MONTHS:
              return this.plusMonths(amountToAdd);
            case ChronoUnit.YEARS:
              return this.plusYears(amountToAdd);
            case ChronoUnit.DECADES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
            case ChronoUnit.CENTURIES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
            case ChronoUnit.MILLENNIA:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
            case ChronoUnit.ERAS:
              return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
        return LocalDate2._resolvePreviousValid(newYear, this._month, this._day);
      };
      _proto.plusMonths = function plusMonths(monthsToAdd) {
        if (monthsToAdd === 0) {
          return this;
        }
        var monthCount = this._year * 12 + (this._month - 1);
        var calcMonths = monthCount + monthsToAdd;
        var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
        var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
        return LocalDate2._resolvePreviousValid(newYear, newMonth, this._day);
      };
      _proto.plusWeeks = function plusWeeks(weeksToAdd) {
        return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));
      };
      _proto.plusDays = function plusDays(daysToAdd) {
        if (daysToAdd === 0) {
          return this;
        }
        var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);
        return LocalDate2.ofEpochDay(mjDay);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(amountToSubtract, "amountToSubtract");
        requireNonNull(unit, "unit");
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return this.plusYears(yearsToSubtract * -1);
      };
      _proto.minusMonths = function minusMonths(monthsToSubtract) {
        return this.plusMonths(monthsToSubtract * -1);
      };
      _proto.minusWeeks = function minusWeeks(weeksToSubtract) {
        return this.plusWeeks(weeksToSubtract * -1);
      };
      _proto.minusDays = function minusDays(daysToSubtract) {
        return this.plusDays(daysToSubtract * -1);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.localDate()) {
          return this;
        }
        return _ChronoLocalDate.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);
      };
      _proto.until = function until(p1, p2) {
        if (arguments.length < 2) {
          return this.until1(p1);
        } else {
          return this.until2(p1, p2);
        }
      };
      _proto.until2 = function until2(endExclusive, unit) {
        var end = LocalDate2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.DAYS:
              return this.daysUntil(end);
            case ChronoUnit.WEEKS:
              return MathUtil.intDiv(this.daysUntil(end), 7);
            case ChronoUnit.MONTHS:
              return this._monthsUntil(end);
            case ChronoUnit.YEARS:
              return MathUtil.intDiv(this._monthsUntil(end), 12);
            case ChronoUnit.DECADES:
              return MathUtil.intDiv(this._monthsUntil(end), 120);
            case ChronoUnit.CENTURIES:
              return MathUtil.intDiv(this._monthsUntil(end), 1200);
            case ChronoUnit.MILLENNIA:
              return MathUtil.intDiv(this._monthsUntil(end), 12e3);
            case ChronoUnit.ERAS:
              return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.daysUntil = function daysUntil(end) {
        return end.toEpochDay() - this.toEpochDay();
      };
      _proto._monthsUntil = function _monthsUntil(end) {
        var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();
        var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();
        return MathUtil.intDiv(packed2 - packed1, 32);
      };
      _proto.until1 = function until1(endDate) {
        var end = LocalDate2.from(endDate);
        var totalMonths = end._prolepticMonth() - this._prolepticMonth();
        var days = end._day - this._day;
        if (totalMonths > 0 && days < 0) {
          totalMonths--;
          var calcDate = this.plusMonths(totalMonths);
          days = end.toEpochDay() - calcDate.toEpochDay();
        } else if (totalMonths < 0 && days > 0) {
          totalMonths++;
          days -= end.lengthOfMonth();
        }
        var years = MathUtil.intDiv(totalMonths, 12);
        var months = MathUtil.intMod(totalMonths, 12);
        return Period.of(years, months, days);
      };
      _proto.atTime = function atTime() {
        if (arguments.length === 1) {
          return this.atTime1.apply(this, arguments);
        } else {
          return this.atTime4.apply(this, arguments);
        }
      };
      _proto.atTime1 = function atTime1(time) {
        requireNonNull(time, "time");
        if (time instanceof LocalTime) {
          return LocalDateTime.of(this, time);
        } else if (time instanceof OffsetTime) {
          return this._atTimeOffsetTime(time);
        } else {
          throw new IllegalArgumentException("time must be an instance of LocalTime or OffsetTime" + (time && time.constructor && time.constructor.name ? ", but is " + time.constructor.name : ""));
        }
      };
      _proto.atTime4 = function atTime4(hour, minute, second, nanoOfSecond) {
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));
      };
      _proto._atTimeOffsetTime = function _atTimeOffsetTime(time) {
        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.offset());
      };
      _proto.atStartOfDay = function atStartOfDay(zone) {
        if (zone != null) {
          return this._atStartOfDayWithZone(zone);
        } else {
          return LocalDateTime.of(this, LocalTime.MIDNIGHT);
        }
      };
      _proto._atStartOfDayWithZone = function _atStartOfDayWithZone(zone) {
        requireNonNull(zone, "zone");
        var ldt = this.atTime(LocalTime.MIDNIGHT);
        if (zone instanceof ZoneOffset === false) {
          var trans = zone.rules().transition(ldt);
          if (trans != null && trans.isGap()) {
            ldt = trans.dateTimeAfter();
          }
        }
        return ZonedDateTime.of(ldt, zone);
      };
      _proto.toEpochDay = function toEpochDay() {
        var y = this._year;
        var m = this._month;
        var total = 0;
        total += 365 * y;
        if (y >= 0) {
          total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);
        } else {
          total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);
        }
        total += MathUtil.intDiv(367 * m - 362, 12);
        total += this.dayOfMonth() - 1;
        if (m > 2) {
          total--;
          if (!IsoChronology.isLeapYear(y)) {
            total--;
          }
        }
        return total - DAYS_0000_TO_1970;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, LocalDate2, "other");
        return this._compareTo0(other);
      };
      _proto._compareTo0 = function _compareTo0(otherDate) {
        var cmp = this._year - otherDate._year;
        if (cmp === 0) {
          cmp = this._month - otherDate._month;
          if (cmp === 0) {
            cmp = this._day - otherDate._day;
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.isEqual = function isEqual(other) {
        return this.compareTo(other) === 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof LocalDate2) {
          return this._compareTo0(other) === 0;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        var yearValue = this._year;
        var monthValue = this._month;
        var dayValue = this._day;
        return MathUtil.hash(yearValue & 4294965248 ^ (yearValue << 11) + (monthValue << 6) + dayValue);
      };
      _proto.toString = function toString() {
        var dayString, monthString, yearString;
        var yearValue = this._year;
        var monthValue = this._month;
        var dayValue = this._day;
        var absYear = Math.abs(yearValue);
        if (absYear < 1e3) {
          if (yearValue < 0) {
            yearString = "-" + ("" + (yearValue - 1e4)).slice(-4);
          } else {
            yearString = ("" + (yearValue + 1e4)).slice(-4);
          }
        } else {
          if (yearValue > 9999) {
            yearString = "+" + yearValue;
          } else {
            yearString = "" + yearValue;
          }
        }
        if (monthValue < 10) {
          monthString = "-0" + monthValue;
        } else {
          monthString = "-" + monthValue;
        }
        if (dayValue < 10) {
          dayString = "-0" + dayValue;
        } else {
          dayString = "-" + dayValue;
        }
        return yearString + monthString + dayString;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return _ChronoLocalDate.prototype.format.call(this, formatter);
      };
      return LocalDate2;
    }(ChronoLocalDate);
    ChronoLocalDateTime = function(_Temporal) {
      _inheritsLoose(ChronoLocalDateTime2, _Temporal);
      function ChronoLocalDateTime2() {
        return _Temporal.apply(this, arguments) || this;
      }
      var _proto = ChronoLocalDateTime2.prototype;
      _proto.chronology = function chronology() {
        return this.toLocalDate().chronology();
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.chronology()) {
          return this.chronology();
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.localDate()) {
          return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
        } else if (_query === TemporalQueries.localTime()) {
          return this.toLocalTime();
        } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());
      };
      _proto.toInstant = function toInstant(offset) {
        requireInstance(offset, ZoneOffset, "zoneId");
        return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());
      };
      _proto.toEpochSecond = function toEpochSecond(offset) {
        requireNonNull(offset, "offset");
        var epochDay = this.toLocalDate().toEpochDay();
        var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
        secs -= offset.totalSeconds();
        return MathUtil.safeToInt(secs);
      };
      return ChronoLocalDateTime2;
    }(Temporal);
    LocalDateTime = function(_ChronoLocalDateTime) {
      _inheritsLoose(LocalDateTime2, _ChronoLocalDateTime);
      LocalDateTime2.now = function now(clockOrZone) {
        if (clockOrZone == null) {
          return LocalDateTime2._now(Clock.systemDefaultZone());
        } else if (clockOrZone instanceof Clock) {
          return LocalDateTime2._now(clockOrZone);
        } else {
          return LocalDateTime2._now(Clock.system(clockOrZone));
        }
      };
      LocalDateTime2._now = function _now(clock) {
        requireNonNull(clock, "clock");
        return LocalDateTime2.ofInstant(clock.instant(), clock.zone());
      };
      LocalDateTime2._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {
        var localSecond = MathUtil.floorDiv(epochMilli, 1e3) + offset.totalSeconds();
        var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
        var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
        var nanoOfSecond = MathUtil.floorMod(epochMilli, 1e3) * 1e6;
        var date = LocalDate.ofEpochDay(localEpochDay);
        var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.of = function of() {
        if (arguments.length <= 2) {
          return LocalDateTime2.ofDateAndTime.apply(this, arguments);
        } else {
          return LocalDateTime2.ofNumbers.apply(this, arguments);
        }
      };
      LocalDateTime2.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond) {
        if (hour === void 0) {
          hour = 0;
        }
        if (minute === void 0) {
          minute = 0;
        }
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        var date = LocalDate.of(year, month, dayOfMonth);
        var time = LocalTime.of(hour, minute, second, nanoOfSecond);
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.ofDateAndTime = function ofDateAndTime(date, time) {
        requireNonNull(date, "date");
        requireNonNull(time, "time");
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.ofInstant = function ofInstant(instant, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        requireNonNull(instant, "instant");
        requireInstance(instant, Instant, "instant");
        requireNonNull(zone, "zone");
        var offset = zone.rules().offset(instant);
        return LocalDateTime2.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
      };
      LocalDateTime2.ofEpochSecond = function ofEpochSecond(epochSecond, nanoOfSecond, offset) {
        if (epochSecond === void 0) {
          epochSecond = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {
          offset = nanoOfSecond;
          nanoOfSecond = 0;
        }
        requireNonNull(offset, "offset");
        var localSecond = epochSecond + offset.totalSeconds();
        var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
        var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
        var date = LocalDate.ofEpochDay(localEpochDay);
        var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof LocalDateTime2) {
          return temporal;
        } else if (temporal instanceof ZonedDateTime) {
          return temporal.toLocalDateTime();
        }
        try {
          var date = LocalDate.from(temporal);
          var time = LocalTime.from(temporal);
          return new LocalDateTime2(date, time);
        } catch (ex) {
          throw new DateTimeException("Unable to obtain LocalDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      LocalDateTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, LocalDateTime2.FROM);
      };
      function LocalDateTime2(date, time) {
        var _this;
        _this = _ChronoLocalDateTime.call(this) || this;
        requireInstance(date, LocalDate, "date");
        requireInstance(time, LocalTime, "time");
        _this._date = date;
        _this._time = time;
        return _this;
      }
      var _proto = LocalDateTime2.prototype;
      _proto._withDateTime = function _withDateTime(newDate, newTime) {
        if (this._date.equals(newDate) && this._time.equals(newTime)) {
          return this;
        }
        return new LocalDateTime2(newDate, newTime);
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          return field.isTimeBased() ? this._time.range(field) : this._date.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        if (field instanceof ChronoField) {
          return field.isTimeBased() ? this._time.get(field) : this._date.get(field);
        }
        return _ChronoLocalDateTime.prototype.get.call(this, field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);
        }
        return field.getFrom(this);
      };
      _proto.year = function year() {
        return this._date.year();
      };
      _proto.monthValue = function monthValue() {
        return this._date.monthValue();
      };
      _proto.month = function month() {
        return this._date.month();
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._date.dayOfMonth();
      };
      _proto.dayOfYear = function dayOfYear() {
        return this._date.dayOfYear();
      };
      _proto.dayOfWeek = function dayOfWeek() {
        return this._date.dayOfWeek();
      };
      _proto.hour = function hour() {
        return this._time.hour();
      };
      _proto.minute = function minute() {
        return this._time.minute();
      };
      _proto.second = function second() {
        return this._time.second();
      };
      _proto.nano = function nano() {
        return this._time.nano();
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalDate) {
          return this._withDateTime(adjuster, this._time);
        } else if (adjuster instanceof LocalTime) {
          return this._withDateTime(this._date, adjuster);
        } else if (adjuster instanceof LocalDateTime2) {
          return adjuster;
        }
        return _ChronoLocalDateTime.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          if (field.isTimeBased()) {
            return this._withDateTime(this._date, this._time.with(field, newValue));
          } else {
            return this._withDateTime(this._date.with(field, newValue), this._time);
          }
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        return this._withDateTime(this._date.withYear(year), this._time);
      };
      _proto.withMonth = function withMonth(month) {
        return this._withDateTime(this._date.withMonth(month), this._time);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);
      };
      _proto.withHour = function withHour(hour) {
        var newTime = this._time.withHour(hour);
        return this._withDateTime(this._date, newTime);
      };
      _proto.withMinute = function withMinute(minute) {
        var newTime = this._time.withMinute(minute);
        return this._withDateTime(this._date, newTime);
      };
      _proto.withSecond = function withSecond(second) {
        var newTime = this._time.withSecond(second);
        return this._withDateTime(this._date, newTime);
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        var newTime = this._time.withNano(nanoOfSecond);
        return this._withDateTime(this._date, newTime);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._withDateTime(this._date, this._time.truncatedTo(unit));
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(unit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1e3);
            case ChronoUnit.MILLIS:
              return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1e6);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
            case ChronoUnit.MINUTES:
              return this.plusMinutes(amountToAdd);
            case ChronoUnit.HOURS:
              return this.plusHours(amountToAdd);
            case ChronoUnit.HALF_DAYS:
              return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);
          }
          return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(years) {
        var newDate = this._date.plusYears(years);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusMonths = function plusMonths(months) {
        var newDate = this._date.plusMonths(months);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusWeeks = function plusWeeks(weeks) {
        var newDate = this._date.plusWeeks(weeks);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusDays = function plusDays(days) {
        var newDate = this._date.plusDays(days);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusHours = function plusHours(hours) {
        return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(unit, "unit");
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(years) {
        return this.plusYears(-1 * years);
      };
      _proto.minusMonths = function minusMonths(months) {
        return this.plusMonths(-1 * months);
      };
      _proto.minusWeeks = function minusWeeks(weeks) {
        return this.plusWeeks(-1 * weeks);
      };
      _proto.minusDays = function minusDays(days) {
        return this.plusDays(-1 * days);
      };
      _proto.minusHours = function minusHours(hours) {
        return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);
      };
      _proto._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign2) {
        if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {
          return this._withDateTime(newDate, this._time);
        }
        var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);
        totDays *= sign2;
        var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;
        var curNoD = this._time.toNanoOfDay();
        totNanos = totNanos * sign2 + curNoD;
        totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);
        var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);
        var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);
        return this._withDateTime(newDate.plusDays(totDays), newTime);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.localDate()) {
          return this.toLocalDate();
        }
        return _ChronoLocalDateTime.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = LocalDateTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          if (unit.isTimeBased()) {
            var daysUntil = this._date.daysUntil(end._date);
            var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();
            if (daysUntil > 0 && timeUntil < 0) {
              daysUntil--;
              timeUntil += LocalTime.NANOS_PER_DAY;
            } else if (daysUntil < 0 && timeUntil > 0) {
              daysUntil++;
              timeUntil -= LocalTime.NANOS_PER_DAY;
            }
            var amount = daysUntil;
            switch (unit) {
              case ChronoUnit.NANOS:
                amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);
                return MathUtil.safeAdd(amount, timeUntil);
              case ChronoUnit.MICROS:
                amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1e3));
              case ChronoUnit.MILLIS:
                amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1e6));
              case ChronoUnit.SECONDS:
                amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));
              case ChronoUnit.MINUTES:
                amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));
              case ChronoUnit.HOURS:
                amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));
              case ChronoUnit.HALF_DAYS:
                amount = MathUtil.safeMultiply(amount, 2);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          var endDate = end._date;
          var endTime = end._time;
          if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {
            endDate = endDate.minusDays(1);
          } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {
            endDate = endDate.plusDays(1);
          }
          return this._date.until(endDate, unit);
        }
        return unit.between(this, end);
      };
      _proto.atOffset = function atOffset(offset) {
        return OffsetDateTime.of(this, offset);
      };
      _proto.atZone = function atZone(zone) {
        return ZonedDateTime.of(this, zone);
      };
      _proto.toLocalDate = function toLocalDate() {
        return this._date;
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._time;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, LocalDateTime2, "other");
        return this._compareTo0(other);
      };
      _proto._compareTo0 = function _compareTo0(other) {
        var cmp = this._date.compareTo(other.toLocalDate());
        if (cmp === 0) {
          cmp = this._time.compareTo(other.toLocalTime());
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.isEqual = function isEqual(other) {
        return this.compareTo(other) === 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof LocalDateTime2) {
          return this._date.equals(other._date) && this._time.equals(other._time);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._date.hashCode() ^ this._time.hashCode();
      };
      _proto.toString = function toString() {
        return this._date.toString() + "T" + this._time.toString();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return LocalDateTime2;
    }(ChronoLocalDateTime);
    LocalTime = function(_Temporal) {
      _inheritsLoose(LocalTime2, _Temporal);
      LocalTime2.now = function now(clockOrZone) {
        if (clockOrZone == null) {
          return LocalTime2._now(Clock.systemDefaultZone());
        } else if (clockOrZone instanceof Clock) {
          return LocalTime2._now(clockOrZone);
        } else {
          return LocalTime2._now(Clock.system(clockOrZone));
        }
      };
      LocalTime2._now = function _now(clock) {
        if (clock === void 0) {
          clock = Clock.systemDefaultZone();
        }
        requireNonNull(clock, "clock");
        return LocalTime2.ofInstant(clock.instant(), clock.zone());
      };
      LocalTime2.ofInstant = function ofInstant(instant, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        var offset = zone.rules().offset(instant);
        var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime2.SECONDS_PER_DAY);
        secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime2.SECONDS_PER_DAY);
        if (secsOfDay < 0) {
          secsOfDay += LocalTime2.SECONDS_PER_DAY;
        }
        return LocalTime2.ofSecondOfDay(secsOfDay, instant.nano());
      };
      LocalTime2.of = function of(hour, minute, second, nanoOfSecond) {
        return new LocalTime2(hour, minute, second, nanoOfSecond);
      };
      LocalTime2.ofSecondOfDay = function ofSecondOfDay(secondOfDay, nanoOfSecond) {
        if (secondOfDay === void 0) {
          secondOfDay = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);
        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
        var hours = MathUtil.intDiv(secondOfDay, LocalTime2.SECONDS_PER_HOUR);
        secondOfDay -= hours * LocalTime2.SECONDS_PER_HOUR;
        var minutes = MathUtil.intDiv(secondOfDay, LocalTime2.SECONDS_PER_MINUTE);
        secondOfDay -= minutes * LocalTime2.SECONDS_PER_MINUTE;
        return new LocalTime2(hours, minutes, secondOfDay, nanoOfSecond);
      };
      LocalTime2.ofNanoOfDay = function ofNanoOfDay(nanoOfDay) {
        if (nanoOfDay === void 0) {
          nanoOfDay = 0;
        }
        ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);
        var hours = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_HOUR);
        nanoOfDay -= hours * LocalTime2.NANOS_PER_HOUR;
        var minutes = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_MINUTE);
        nanoOfDay -= minutes * LocalTime2.NANOS_PER_MINUTE;
        var seconds = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_SECOND);
        nanoOfDay -= seconds * LocalTime2.NANOS_PER_SECOND;
        return new LocalTime2(hours, minutes, seconds, nanoOfDay);
      };
      LocalTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        var time = temporal.query(TemporalQueries.localTime());
        if (time == null) {
          throw new DateTimeException("Unable to obtain LocalTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
        return time;
      };
      LocalTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_LOCAL_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, LocalTime2.FROM);
      };
      function LocalTime2(hour, minute, second, nanoOfSecond) {
        var _this;
        if (hour === void 0) {
          hour = 0;
        }
        if (minute === void 0) {
          minute = 0;
        }
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        _this = _Temporal.call(this) || this;
        var _hour = MathUtil.safeToInt(hour);
        var _minute = MathUtil.safeToInt(minute);
        var _second = MathUtil.safeToInt(second);
        var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);
        LocalTime2._validate(_hour, _minute, _second, _nanoOfSecond);
        if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {
          if (!LocalTime2.HOURS[_hour]) {
            _this._hour = _hour;
            _this._minute = _minute;
            _this._second = _second;
            _this._nano = _nanoOfSecond;
            LocalTime2.HOURS[_hour] = _assertThisInitialized(_this);
          }
          return LocalTime2.HOURS[_hour] || _assertThisInitialized(_this);
        }
        _this._hour = _hour;
        _this._minute = _minute;
        _this._second = _second;
        _this._nano = _nanoOfSecond;
        return _this;
      }
      LocalTime2._validate = function _validate(hour, minute, second, nanoOfSecond) {
        ChronoField.HOUR_OF_DAY.checkValidValue(hour);
        ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);
        ChronoField.SECOND_OF_MINUTE.checkValidValue(second);
        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
      };
      var _proto = LocalTime2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isTimeBased();
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        requireNonNull(field);
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          return this._get0(field);
        }
        return field.getFrom(this);
      };
      _proto._get0 = function _get0(field) {
        switch (field) {
          case ChronoField.NANO_OF_SECOND:
            return this._nano;
          case ChronoField.NANO_OF_DAY:
            return this.toNanoOfDay();
          case ChronoField.MICRO_OF_SECOND:
            return MathUtil.intDiv(this._nano, 1e3);
          case ChronoField.MICRO_OF_DAY:
            return MathUtil.intDiv(this.toNanoOfDay(), 1e3);
          case ChronoField.MILLI_OF_SECOND:
            return MathUtil.intDiv(this._nano, 1e6);
          case ChronoField.MILLI_OF_DAY:
            return MathUtil.intDiv(this.toNanoOfDay(), 1e6);
          case ChronoField.SECOND_OF_MINUTE:
            return this._second;
          case ChronoField.SECOND_OF_DAY:
            return this.toSecondOfDay();
          case ChronoField.MINUTE_OF_HOUR:
            return this._minute;
          case ChronoField.MINUTE_OF_DAY:
            return this._hour * 60 + this._minute;
          case ChronoField.HOUR_OF_AMPM:
            return MathUtil.intMod(this._hour, 12);
          case ChronoField.CLOCK_HOUR_OF_AMPM: {
            var ham = MathUtil.intMod(this._hour, 12);
            return ham % 12 === 0 ? 12 : ham;
          }
          case ChronoField.HOUR_OF_DAY:
            return this._hour;
          case ChronoField.CLOCK_HOUR_OF_DAY:
            return this._hour === 0 ? 24 : this._hour;
          case ChronoField.AMPM_OF_DAY:
            return MathUtil.intDiv(this._hour, 12);
        }
        throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
      };
      _proto.hour = function hour() {
        return this._hour;
      };
      _proto.minute = function minute() {
        return this._minute;
      };
      _proto.second = function second() {
        return this._second;
      };
      _proto.nano = function nano() {
        return this._nano;
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalTime2) {
          return adjuster;
        }
        return _Temporal.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          field.checkValidValue(newValue);
          switch (field) {
            case ChronoField.NANO_OF_SECOND:
              return this.withNano(newValue);
            case ChronoField.NANO_OF_DAY:
              return LocalTime2.ofNanoOfDay(newValue);
            case ChronoField.MICRO_OF_SECOND:
              return this.withNano(newValue * 1e3);
            case ChronoField.MICRO_OF_DAY:
              return LocalTime2.ofNanoOfDay(newValue * 1e3);
            case ChronoField.MILLI_OF_SECOND:
              return this.withNano(newValue * 1e6);
            case ChronoField.MILLI_OF_DAY:
              return LocalTime2.ofNanoOfDay(newValue * 1e6);
            case ChronoField.SECOND_OF_MINUTE:
              return this.withSecond(newValue);
            case ChronoField.SECOND_OF_DAY:
              return this.plusSeconds(newValue - this.toSecondOfDay());
            case ChronoField.MINUTE_OF_HOUR:
              return this.withMinute(newValue);
            case ChronoField.MINUTE_OF_DAY:
              return this.plusMinutes(newValue - (this._hour * 60 + this._minute));
            case ChronoField.HOUR_OF_AMPM:
              return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));
            case ChronoField.CLOCK_HOUR_OF_AMPM:
              return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));
            case ChronoField.HOUR_OF_DAY:
              return this.withHour(newValue);
            case ChronoField.CLOCK_HOUR_OF_DAY:
              return this.withHour(newValue === 24 ? 0 : newValue);
            case ChronoField.AMPM_OF_DAY:
              return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withHour = function withHour(hour) {
        if (hour === void 0) {
          hour = 0;
        }
        if (this._hour === hour) {
          return this;
        }
        return new LocalTime2(hour, this._minute, this._second, this._nano);
      };
      _proto.withMinute = function withMinute(minute) {
        if (minute === void 0) {
          minute = 0;
        }
        if (this._minute === minute) {
          return this;
        }
        return new LocalTime2(this._hour, minute, this._second, this._nano);
      };
      _proto.withSecond = function withSecond(second) {
        if (second === void 0) {
          second = 0;
        }
        if (this._second === second) {
          return this;
        }
        return new LocalTime2(this._hour, this._minute, second, this._nano);
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        if (this._nano === nanoOfSecond) {
          return this;
        }
        return new LocalTime2(this._hour, this._minute, this._second, nanoOfSecond);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        requireNonNull(unit, "unit");
        if (unit === ChronoUnit.NANOS) {
          return this;
        }
        var unitDur = unit.duration();
        if (unitDur.seconds() > LocalTime2.SECONDS_PER_DAY) {
          throw new DateTimeException("Unit is too large to be used for truncation");
        }
        var dur = unitDur.toNanos();
        if (MathUtil.intMod(LocalTime2.NANOS_PER_DAY, dur) !== 0) {
          throw new DateTimeException("Unit must divide into a standard day without remainder");
        }
        var nod = this.toNanoOfDay();
        return LocalTime2.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(unit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime2.MICROS_PER_DAY) * 1e3);
            case ChronoUnit.MILLIS:
              return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime2.MILLIS_PER_DAY) * 1e6);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
            case ChronoUnit.MINUTES:
              return this.plusMinutes(amountToAdd);
            case ChronoUnit.HOURS:
              return this.plusHours(amountToAdd);
            case ChronoUnit.HALF_DAYS:
              return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusHours = function plusHours(hoursToAdd) {
        if (hoursToAdd === 0) {
          return this;
        }
        var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime2.HOURS_PER_DAY) + this._hour + LocalTime2.HOURS_PER_DAY, LocalTime2.HOURS_PER_DAY);
        return new LocalTime2(newHour, this._minute, this._second, this._nano);
      };
      _proto.plusMinutes = function plusMinutes(minutesToAdd) {
        if (minutesToAdd === 0) {
          return this;
        }
        var mofd = this._hour * LocalTime2.MINUTES_PER_HOUR + this._minute;
        var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime2.MINUTES_PER_DAY) + mofd + LocalTime2.MINUTES_PER_DAY, LocalTime2.MINUTES_PER_DAY);
        if (mofd === newMofd) {
          return this;
        }
        var newHour = MathUtil.intDiv(newMofd, LocalTime2.MINUTES_PER_HOUR);
        var newMinute = MathUtil.intMod(newMofd, LocalTime2.MINUTES_PER_HOUR);
        return new LocalTime2(newHour, newMinute, this._second, this._nano);
      };
      _proto.plusSeconds = function plusSeconds(secondsToAdd) {
        if (secondsToAdd === 0) {
          return this;
        }
        var sofd = this._hour * LocalTime2.SECONDS_PER_HOUR + this._minute * LocalTime2.SECONDS_PER_MINUTE + this._second;
        var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime2.SECONDS_PER_DAY) + sofd + LocalTime2.SECONDS_PER_DAY, LocalTime2.SECONDS_PER_DAY);
        if (sofd === newSofd) {
          return this;
        }
        var newHour = MathUtil.intDiv(newSofd, LocalTime2.SECONDS_PER_HOUR);
        var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime2.SECONDS_PER_MINUTE), LocalTime2.MINUTES_PER_HOUR);
        var newSecond = MathUtil.intMod(newSofd, LocalTime2.SECONDS_PER_MINUTE);
        return new LocalTime2(newHour, newMinute, newSecond, this._nano);
      };
      _proto.plusNanos = function plusNanos(nanosToAdd) {
        if (nanosToAdd === 0) {
          return this;
        }
        var nofd = this.toNanoOfDay();
        var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime2.NANOS_PER_DAY) + nofd + LocalTime2.NANOS_PER_DAY, LocalTime2.NANOS_PER_DAY);
        if (nofd === newNofd) {
          return this;
        }
        var newHour = MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_HOUR);
        var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_MINUTE), LocalTime2.MINUTES_PER_HOUR);
        var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_SECOND), LocalTime2.SECONDS_PER_MINUTE);
        var newNano = MathUtil.intMod(newNofd, LocalTime2.NANOS_PER_SECOND);
        return new LocalTime2(newHour, newMinute, newSecond, newNano);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(unit, "unit");
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusHours = function minusHours(hoursToSubtract) {
        return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime2.HOURS_PER_DAY));
      };
      _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
        return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime2.MINUTES_PER_DAY));
      };
      _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
        return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime2.SECONDS_PER_DAY));
      };
      _proto.minusNanos = function minusNanos(nanosToSubtract) {
        return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime2.NANOS_PER_DAY));
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.localTime()) {
          return this;
        }
        if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(LocalTime2.NANO_OF_DAY, this.toNanoOfDay());
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = LocalTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();
          switch (unit) {
            case ChronoUnit.NANOS:
              return nanosUntil;
            case ChronoUnit.MICROS:
              return MathUtil.intDiv(nanosUntil, 1e3);
            case ChronoUnit.MILLIS:
              return MathUtil.intDiv(nanosUntil, 1e6);
            case ChronoUnit.SECONDS:
              return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_SECOND);
            case ChronoUnit.MINUTES:
              return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_MINUTE);
            case ChronoUnit.HOURS:
              return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_HOUR);
            case ChronoUnit.HALF_DAYS:
              return MathUtil.intDiv(nanosUntil, 12 * LocalTime2.NANOS_PER_HOUR);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.atDate = function atDate(date) {
        return LocalDateTime.of(date, this);
      };
      _proto.atOffset = function atOffset(offset) {
        return OffsetTime.of(this, offset);
      };
      _proto.toSecondOfDay = function toSecondOfDay() {
        var total = this._hour * LocalTime2.SECONDS_PER_HOUR;
        total += this._minute * LocalTime2.SECONDS_PER_MINUTE;
        total += this._second;
        return total;
      };
      _proto.toNanoOfDay = function toNanoOfDay() {
        var total = this._hour * LocalTime2.NANOS_PER_HOUR;
        total += this._minute * LocalTime2.NANOS_PER_MINUTE;
        total += this._second * LocalTime2.NANOS_PER_SECOND;
        total += this._nano;
        return total;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, LocalTime2, "other");
        var cmp = MathUtil.compareNumbers(this._hour, other._hour);
        if (cmp === 0) {
          cmp = MathUtil.compareNumbers(this._minute, other._minute);
          if (cmp === 0) {
            cmp = MathUtil.compareNumbers(this._second, other._second);
            if (cmp === 0) {
              cmp = MathUtil.compareNumbers(this._nano, other._nano);
            }
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof LocalTime2) {
          return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        var nod = this.toNanoOfDay();
        return MathUtil.hash(nod);
      };
      _proto.toString = function toString() {
        var buf = "";
        var hourValue = this._hour;
        var minuteValue = this._minute;
        var secondValue = this._second;
        var nanoValue = this._nano;
        buf += hourValue < 10 ? "0" : "";
        buf += hourValue;
        buf += minuteValue < 10 ? ":0" : ":";
        buf += minuteValue;
        if (secondValue > 0 || nanoValue > 0) {
          buf += secondValue < 10 ? ":0" : ":";
          buf += secondValue;
          if (nanoValue > 0) {
            buf += ".";
            if (MathUtil.intMod(nanoValue, 1e6) === 0) {
              buf += ("" + (MathUtil.intDiv(nanoValue, 1e6) + 1e3)).substring(1);
            } else if (MathUtil.intMod(nanoValue, 1e3) === 0) {
              buf += ("" + (MathUtil.intDiv(nanoValue, 1e3) + 1e6)).substring(1);
            } else {
              buf += ("" + (nanoValue + 1e9)).substring(1);
            }
          }
        }
        return buf;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return LocalTime2;
    }(Temporal);
    LocalTime.HOURS_PER_DAY = 24;
    LocalTime.MINUTES_PER_HOUR = 60;
    LocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;
    LocalTime.SECONDS_PER_MINUTE = 60;
    LocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
    LocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;
    LocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1e3;
    LocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1e6;
    LocalTime.NANOS_PER_SECOND = 1e9;
    LocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;
    LocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
    LocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;
    NANOS_PER_MILLI = 1e6;
    Instant = function(_Temporal) {
      _inheritsLoose(Instant2, _Temporal);
      Instant2.now = function now(clock) {
        if (clock === void 0) {
          clock = Clock.systemUTC();
        }
        return clock.instant();
      };
      Instant2.ofEpochSecond = function ofEpochSecond(epochSecond, nanoAdjustment) {
        if (nanoAdjustment === void 0) {
          nanoAdjustment = 0;
        }
        var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
        var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
        return Instant2._create(secs, nos);
      };
      Instant2.ofEpochMilli = function ofEpochMilli(epochMilli) {
        var secs = MathUtil.floorDiv(epochMilli, 1e3);
        var mos = MathUtil.floorMod(epochMilli, 1e3);
        return Instant2._create(secs, mos * 1e6);
      };
      Instant2.ofEpochMicro = function ofEpochMicro(epochMicro) {
        var secs = MathUtil.floorDiv(epochMicro, 1e6);
        var mos = MathUtil.floorMod(epochMicro, 1e6);
        return Instant2._create(secs, mos * 1e3);
      };
      Instant2.from = function from(temporal) {
        try {
          var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);
          var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
          return Instant2.ofEpochSecond(instantSecs, nanoOfSecond);
        } catch (ex) {
          throw new DateTimeException("Unable to obtain Instant from TemporalAccessor: " + temporal + ", type " + typeof temporal, ex);
        }
      };
      Instant2.parse = function parse2(text) {
        return DateTimeFormatter.ISO_INSTANT.parse(text, Instant2.FROM);
      };
      Instant2._create = function _create(seconds, nanoOfSecond) {
        if (seconds === 0 && nanoOfSecond === 0) {
          return Instant2.EPOCH;
        }
        return new Instant2(seconds, nanoOfSecond);
      };
      Instant2._validate = function _validate(seconds, nanoOfSecond) {
        if (seconds < Instant2.MIN_SECONDS || seconds > Instant2.MAX_SECONDS) {
          throw new DateTimeException("Instant exceeds minimum or maximum instant");
        }
        if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {
          throw new DateTimeException("Instant exceeds minimum or maximum instant");
        }
      };
      function Instant2(seconds, nanoOfSecond) {
        var _this;
        _this = _Temporal.call(this) || this;
        Instant2._validate(seconds, nanoOfSecond);
        _this._seconds = MathUtil.safeToInt(seconds);
        _this._nanos = MathUtil.safeToInt(nanoOfSecond);
        return _this;
      }
      var _proto = Instant2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;
        }
        if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.NANO_OF_SECOND:
              return this._nanos;
            case ChronoField.MICRO_OF_SECOND:
              return MathUtil.intDiv(this._nanos, 1e3);
            case ChronoField.MILLI_OF_SECOND:
              return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
            case ChronoField.INSTANT_SECONDS:
              return this._seconds;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.epochSecond = function epochSecond() {
        return this._seconds;
      };
      _proto.nano = function nano() {
        return this._nanos;
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          field.checkValidValue(newValue);
          switch (field) {
            case ChronoField.MILLI_OF_SECOND: {
              var nval = newValue * NANOS_PER_MILLI;
              return nval !== this._nanos ? Instant2._create(this._seconds, nval) : this;
            }
            case ChronoField.MICRO_OF_SECOND: {
              var _nval = newValue * 1e3;
              return _nval !== this._nanos ? Instant2._create(this._seconds, _nval) : this;
            }
            case ChronoField.NANO_OF_SECOND:
              return newValue !== this._nanos ? Instant2._create(this._seconds, newValue) : this;
            case ChronoField.INSTANT_SECONDS:
              return newValue !== this._seconds ? Instant2._create(newValue, this._nanos) : this;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        requireNonNull(unit, "unit");
        if (unit === ChronoUnit.NANOS) {
          return this;
        }
        var unitDur = unit.duration();
        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
          throw new DateTimeException("Unit is too large to be used for truncation");
        }
        var dur = unitDur.toNanos();
        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
          throw new DateTimeException("Unit must divide into a standard day without remainder");
        }
        var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;
        var result = MathUtil.intDiv(nod, dur) * dur;
        return this.plusNanos(result - nod);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit);
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusMicros(amountToAdd);
            case ChronoUnit.MILLIS:
              return this.plusMillis(amountToAdd);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
            case ChronoUnit.MINUTES:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));
            case ChronoUnit.HOURS:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));
            case ChronoUnit.HALF_DAYS:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));
            case ChronoUnit.DAYS:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusSeconds = function plusSeconds(secondsToAdd) {
        return this._plus(secondsToAdd, 0);
      };
      _proto.plusMillis = function plusMillis(millisToAdd) {
        return this._plus(MathUtil.intDiv(millisToAdd, 1e3), MathUtil.intMod(millisToAdd, 1e3) * NANOS_PER_MILLI);
      };
      _proto.plusNanos = function plusNanos(nanosToAdd) {
        return this._plus(0, nanosToAdd);
      };
      _proto.plusMicros = function plusMicros(microsToAdd) {
        return this._plus(MathUtil.intDiv(microsToAdd, 1e6), MathUtil.intMod(microsToAdd, 1e6) * 1e3);
      };
      _proto._plus = function _plus(secondsToAdd, nanosToAdd) {
        if (secondsToAdd === 0 && nanosToAdd === 0) {
          return this;
        }
        var epochSec = this._seconds + secondsToAdd;
        epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);
        var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;
        return Instant2.ofEpochSecond(epochSec, nanoAdjustment);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
        return this.plusSeconds(secondsToSubtract * -1);
      };
      _proto.minusMillis = function minusMillis(millisToSubtract) {
        return this.plusMillis(-1 * millisToSubtract);
      };
      _proto.minusNanos = function minusNanos(nanosToSubtract) {
        return this.plusNanos(-1 * nanosToSubtract);
      };
      _proto.minusMicros = function minusMicros(microsToSubtract) {
        return this.plusMicros(-1 * microsToSubtract);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        }
        if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = Instant2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this._nanosUntil(end);
            case ChronoUnit.MICROS:
              return this._microsUntil(end);
            case ChronoUnit.MILLIS:
              return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());
            case ChronoUnit.SECONDS:
              return this._secondsUntil(end);
            case ChronoUnit.MINUTES:
              return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);
            case ChronoUnit.HOURS:
              return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);
            case ChronoUnit.HALF_DAYS:
              return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);
            case ChronoUnit.DAYS:
              return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto._microsUntil = function _microsUntil(end) {
        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
        var totalMicros = MathUtil.safeMultiply(secsDiff, 1e6);
        return MathUtil.safeAdd(totalMicros, MathUtil.intDiv(end.nano() - this.nano(), 1e3));
      };
      _proto._nanosUntil = function _nanosUntil(end) {
        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
        var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);
        return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());
      };
      _proto._secondsUntil = function _secondsUntil(end) {
        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
        var nanosDiff = end.nano() - this.nano();
        if (secsDiff > 0 && nanosDiff < 0) {
          secsDiff--;
        } else if (secsDiff < 0 && nanosDiff > 0) {
          secsDiff++;
        }
        return secsDiff;
      };
      _proto.atOffset = function atOffset(offset) {
        return OffsetDateTime.ofInstant(this, offset);
      };
      _proto.atZone = function atZone(zone) {
        return ZonedDateTime.ofInstant(this, zone);
      };
      _proto.toEpochMilli = function toEpochMilli() {
        var millis = MathUtil.safeMultiply(this._seconds, 1e3);
        return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
      };
      _proto.compareTo = function compareTo(otherInstant) {
        requireNonNull(otherInstant, "otherInstant");
        requireInstance(otherInstant, Instant2, "otherInstant");
        var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);
        if (cmp !== 0) {
          return cmp;
        }
        return this._nanos - otherInstant._nanos;
      };
      _proto.isAfter = function isAfter(otherInstant) {
        return this.compareTo(otherInstant) > 0;
      };
      _proto.isBefore = function isBefore(otherInstant) {
        return this.compareTo(otherInstant) < 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof Instant2) {
          return this.epochSecond() === other.epochSecond() && this.nano() === other.nano();
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._seconds, this._nanos);
      };
      _proto.toString = function toString() {
        return DateTimeFormatter.ISO_INSTANT.format(this);
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Instant2;
    }(Temporal);
    Clock = function() {
      function Clock2() {
      }
      Clock2.systemUTC = function systemUTC() {
        return new SystemClock(ZoneOffset.UTC);
      };
      Clock2.systemDefaultZone = function systemDefaultZone() {
        return new SystemClock(ZoneId.systemDefault());
      };
      Clock2.system = function system(zone) {
        return new SystemClock(zone);
      };
      Clock2.fixed = function fixed(fixedInstant, zoneId) {
        return new FixedClock(fixedInstant, zoneId);
      };
      Clock2.offset = function offset(baseClock, duration) {
        return new OffsetClock(baseClock, duration);
      };
      var _proto = Clock2.prototype;
      _proto.millis = function millis() {
        abstractMethodFail("Clock.millis");
      };
      _proto.instant = function instant() {
        abstractMethodFail("Clock.instant");
      };
      _proto.zone = function zone() {
        abstractMethodFail("Clock.zone");
      };
      _proto.withZone = function withZone() {
        abstractMethodFail("Clock.withZone");
      };
      return Clock2;
    }();
    SystemClock = function(_Clock) {
      _inheritsLoose(SystemClock2, _Clock);
      function SystemClock2(zone) {
        var _this;
        requireNonNull(zone, "zone");
        _this = _Clock.call(this) || this;
        _this._zone = zone;
        return _this;
      }
      var _proto2 = SystemClock2.prototype;
      _proto2.zone = function zone() {
        return this._zone;
      };
      _proto2.millis = function millis() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
      _proto2.instant = function instant() {
        return Instant.ofEpochMilli(this.millis());
      };
      _proto2.equals = function equals(obj) {
        if (obj instanceof SystemClock2) {
          return this._zone.equals(obj._zone);
        }
        return false;
      };
      _proto2.withZone = function withZone(zone) {
        if (zone.equals(this._zone)) {
          return this;
        }
        return new SystemClock2(zone);
      };
      _proto2.toString = function toString() {
        return "SystemClock[" + this._zone.toString() + "]";
      };
      return SystemClock2;
    }(Clock);
    FixedClock = function(_Clock2) {
      _inheritsLoose(FixedClock2, _Clock2);
      function FixedClock2(fixedInstant, zoneId) {
        var _this2;
        _this2 = _Clock2.call(this) || this;
        _this2._instant = fixedInstant;
        _this2._zoneId = zoneId;
        return _this2;
      }
      var _proto3 = FixedClock2.prototype;
      _proto3.instant = function instant() {
        return this._instant;
      };
      _proto3.millis = function millis() {
        return this._instant.toEpochMilli();
      };
      _proto3.zone = function zone() {
        return this._zoneId;
      };
      _proto3.toString = function toString() {
        return "FixedClock[]";
      };
      _proto3.equals = function equals(obj) {
        if (obj instanceof FixedClock2) {
          return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);
        }
        return false;
      };
      _proto3.withZone = function withZone(zone) {
        if (zone.equals(this._zoneId)) {
          return this;
        }
        return new FixedClock2(this._instant, zone);
      };
      return FixedClock2;
    }(Clock);
    OffsetClock = function(_Clock3) {
      _inheritsLoose(OffsetClock2, _Clock3);
      function OffsetClock2(baseClock, offset) {
        var _this3;
        _this3 = _Clock3.call(this) || this;
        _this3._baseClock = baseClock;
        _this3._offset = offset;
        return _this3;
      }
      var _proto4 = OffsetClock2.prototype;
      _proto4.zone = function zone() {
        return this._baseClock.zone();
      };
      _proto4.withZone = function withZone(zone) {
        if (zone.equals(this._baseClock.zone())) {
          return this;
        }
        return new OffsetClock2(this._baseClock.withZone(zone), this._offset);
      };
      _proto4.millis = function millis() {
        return this._baseClock.millis() + this._offset.toMillis();
      };
      _proto4.instant = function instant() {
        return this._baseClock.instant().plus(this._offset);
      };
      _proto4.equals = function equals(obj) {
        if (obj instanceof OffsetClock2) {
          return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);
        }
        return false;
      };
      _proto4.toString = function toString() {
        return "OffsetClock[" + this._baseClock + "," + this._offset + "]";
      };
      return OffsetClock2;
    }(Clock);
    ZoneOffsetTransition = function() {
      ZoneOffsetTransition2.of = function of(transition, offsetBefore, offsetAfter) {
        return new ZoneOffsetTransition2(transition, offsetBefore, offsetAfter);
      };
      function ZoneOffsetTransition2(transition, offsetBefore, offsetAfter) {
        requireNonNull(transition, "transition");
        requireNonNull(offsetBefore, "offsetBefore");
        requireNonNull(offsetAfter, "offsetAfter");
        if (offsetBefore.equals(offsetAfter)) {
          throw new IllegalArgumentException("Offsets must not be equal");
        }
        if (transition.nano() !== 0) {
          throw new IllegalArgumentException("Nano-of-second must be zero");
        }
        if (transition instanceof LocalDateTime) {
          this._transition = transition;
        } else {
          this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);
        }
        this._offsetBefore = offsetBefore;
        this._offsetAfter = offsetAfter;
      }
      var _proto = ZoneOffsetTransition2.prototype;
      _proto.instant = function instant() {
        return this._transition.toInstant(this._offsetBefore);
      };
      _proto.toEpochSecond = function toEpochSecond() {
        return this._transition.toEpochSecond(this._offsetBefore);
      };
      _proto.dateTimeBefore = function dateTimeBefore() {
        return this._transition;
      };
      _proto.dateTimeAfter = function dateTimeAfter() {
        return this._transition.plusSeconds(this.durationSeconds());
      };
      _proto.offsetBefore = function offsetBefore() {
        return this._offsetBefore;
      };
      _proto.offsetAfter = function offsetAfter() {
        return this._offsetAfter;
      };
      _proto.duration = function duration() {
        return Duration.ofSeconds(this.durationSeconds());
      };
      _proto.durationSeconds = function durationSeconds() {
        return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();
      };
      _proto.isGap = function isGap() {
        return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();
      };
      _proto.isOverlap = function isOverlap() {
        return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();
      };
      _proto.isValidOffset = function isValidOffset(offset) {
        return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);
      };
      _proto.validOffsets = function validOffsets() {
        if (this.isGap()) {
          return [];
        } else {
          return [this._offsetBefore, this._offsetAfter];
        }
      };
      _proto.compareTo = function compareTo(transition) {
        return this.instant().compareTo(transition.instant());
      };
      _proto.equals = function equals(other) {
        if (other === this) {
          return true;
        }
        if (other instanceof ZoneOffsetTransition2) {
          var d = other;
          return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;
      };
      _proto.toString = function toString() {
        return "Transition[" + (this.isGap() ? "Gap" : "Overlap") + " at " + this._transition.toString() + this._offsetBefore.toString() + " to " + this._offsetAfter + "]";
      };
      return ZoneOffsetTransition2;
    }();
    SystemDefaultZoneRules = function(_ZoneRules) {
      _inheritsLoose(SystemDefaultZoneRules2, _ZoneRules);
      function SystemDefaultZoneRules2() {
        return _ZoneRules.apply(this, arguments) || this;
      }
      var _proto = SystemDefaultZoneRules2.prototype;
      _proto.isFixedOffset = function isFixedOffset() {
        return false;
      };
      _proto.offsetOfInstant = function offsetOfInstant(instant) {
        var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();
        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
      };
      _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
        var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();
        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
      };
      _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
        var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1e3;
        var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();
        var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 6e4;
        var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();
        return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);
      };
      _proto.validOffsets = function validOffsets(localDateTime) {
        return [this.offsetOfLocalDateTime(localDateTime)];
      };
      _proto.transition = function transition() {
        return null;
      };
      _proto.standardOffset = function standardOffset(instant) {
        return this.offsetOfInstant(instant);
      };
      _proto.daylightSavings = function daylightSavings() {
        this._throwNotSupported();
      };
      _proto.isDaylightSavings = function isDaylightSavings() {
        this._throwNotSupported();
      };
      _proto.isValidOffset = function isValidOffset(dateTime, offset) {
        return this.offsetOfLocalDateTime(dateTime).equals(offset);
      };
      _proto.nextTransition = function nextTransition() {
        this._throwNotSupported();
      };
      _proto.previousTransition = function previousTransition() {
        this._throwNotSupported();
      };
      _proto.transitions = function transitions() {
        this._throwNotSupported();
      };
      _proto.transitionRules = function transitionRules() {
        this._throwNotSupported();
      };
      _proto._throwNotSupported = function _throwNotSupported() {
        throw new DateTimeException("not supported operation");
      };
      _proto.equals = function equals(other) {
        if (this === other || other instanceof SystemDefaultZoneRules2) {
          return true;
        } else {
          return false;
        }
      };
      _proto.toString = function toString() {
        return "SYSTEM";
      };
      return SystemDefaultZoneRules2;
    }(ZoneRules);
    SystemDefaultZoneId = function(_ZoneId) {
      _inheritsLoose(SystemDefaultZoneId2, _ZoneId);
      function SystemDefaultZoneId2() {
        var _this;
        _this = _ZoneId.call(this) || this;
        _this._rules = new SystemDefaultZoneRules();
        return _this;
      }
      var _proto = SystemDefaultZoneId2.prototype;
      _proto.rules = function rules() {
        return this._rules;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        return false;
      };
      _proto.id = function id() {
        return "SYSTEM";
      };
      return SystemDefaultZoneId2;
    }(ZoneId);
    ZoneIdFactory = function() {
      function ZoneIdFactory2() {
      }
      ZoneIdFactory2.systemDefault = function systemDefault() {
        return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
      };
      ZoneIdFactory2.getAvailableZoneIds = function getAvailableZoneIds() {
        return ZoneRulesProvider.getAvailableZoneIds();
      };
      ZoneIdFactory2.of = function of(zoneId) {
        requireNonNull(zoneId, "zoneId");
        if (zoneId === "Z") {
          return ZoneOffset.UTC;
        }
        if (zoneId.length === 1) {
          throw new DateTimeException("Invalid zone: " + zoneId);
        }
        if (StringUtil.startsWith(zoneId, "+") || StringUtil.startsWith(zoneId, "-")) {
          return ZoneOffset.of(zoneId);
        }
        if (zoneId === "UTC" || zoneId === "GMT" || zoneId === "GMT0" || zoneId === "UT") {
          return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());
        }
        if (StringUtil.startsWith(zoneId, "UTC+") || StringUtil.startsWith(zoneId, "GMT+") || StringUtil.startsWith(zoneId, "UTC-") || StringUtil.startsWith(zoneId, "GMT-")) {
          var offset = ZoneOffset.of(zoneId.substring(3));
          if (offset.totalSeconds() === 0) {
            return new ZoneRegion(zoneId.substring(0, 3), offset.rules());
          }
          return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());
        }
        if (StringUtil.startsWith(zoneId, "UT+") || StringUtil.startsWith(zoneId, "UT-")) {
          var _offset = ZoneOffset.of(zoneId.substring(2));
          if (_offset.totalSeconds() === 0) {
            return new ZoneRegion("UT", _offset.rules());
          }
          return new ZoneRegion("UT" + _offset.id(), _offset.rules());
        }
        if (zoneId === "SYSTEM") {
          return ZoneId.systemDefault();
        }
        return ZoneRegion.ofId(zoneId);
      };
      ZoneIdFactory2.ofOffset = function ofOffset(prefix, offset) {
        requireNonNull(prefix, "prefix");
        requireNonNull(offset, "offset");
        if (prefix.length === 0) {
          return offset;
        }
        if (prefix === "GMT" || prefix === "UTC" || prefix === "UT") {
          if (offset.totalSeconds() === 0) {
            return new ZoneRegion(prefix, offset.rules());
          }
          return new ZoneRegion(prefix + offset.id(), offset.rules());
        }
        throw new IllegalArgumentException("Invalid prefix, must be GMT, UTC or UT: " + prefix);
      };
      ZoneIdFactory2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        var obj = temporal.query(TemporalQueries.zone());
        if (obj == null) {
          throw new DateTimeException("Unable to obtain ZoneId from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
        return obj;
      };
      return ZoneIdFactory2;
    }();
    SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;
    isInit = false;
    init();
    ToNativeJsConverter = function() {
      function ToNativeJsConverter2(temporal, zone) {
        var zonedDateTime;
        if (temporal instanceof Instant) {
          this.instant = temporal;
          return;
        } else if (temporal instanceof LocalDate) {
          zone = zone == null ? ZoneId.systemDefault() : zone;
          zonedDateTime = temporal.atStartOfDay(zone);
        } else if (temporal instanceof LocalDateTime) {
          zone = zone == null ? ZoneId.systemDefault() : zone;
          zonedDateTime = temporal.atZone(zone);
        } else if (temporal instanceof ZonedDateTime) {
          if (zone == null) {
            zonedDateTime = temporal;
          } else {
            zonedDateTime = temporal.withZoneSameInstant(zone);
          }
        } else {
          throw new IllegalArgumentException("unsupported instance for convert operation:" + temporal);
        }
        this.instant = zonedDateTime.toInstant();
      }
      var _proto = ToNativeJsConverter2.prototype;
      _proto.toDate = function toDate() {
        return new Date(this.instant.toEpochMilli());
      };
      _proto.toEpochMilli = function toEpochMilli() {
        return this.instant.toEpochMilli();
      };
      return ToNativeJsConverter2;
    }();
    _ = {
      assert: assert$1,
      DateTimeBuilder,
      DateTimeParseContext,
      DateTimePrintContext,
      MathUtil,
      StringUtil,
      StringBuilder
    };
    jsJodaExports = {
      _,
      convert,
      nativeJs,
      ArithmeticException,
      DateTimeException,
      DateTimeParseException,
      IllegalArgumentException,
      IllegalStateException,
      UnsupportedTemporalTypeException,
      NullPointerException,
      Clock,
      DayOfWeek,
      Duration,
      Instant,
      LocalDate,
      LocalTime,
      LocalDateTime,
      OffsetTime,
      OffsetDateTime,
      Month,
      MonthDay,
      ParsePosition,
      Period,
      Year,
      YearConstants,
      YearMonth,
      ZonedDateTime,
      ZoneOffset,
      ZoneId,
      ZoneRegion,
      ZoneOffsetTransition,
      ZoneRules,
      ZoneRulesProvider,
      ChronoLocalDate,
      ChronoLocalDateTime,
      ChronoZonedDateTime,
      IsoChronology,
      ChronoField,
      ChronoUnit,
      IsoFields,
      Temporal,
      TemporalAccessor,
      TemporalAdjuster,
      TemporalAdjusters,
      TemporalAmount,
      TemporalField,
      TemporalQueries,
      TemporalQuery,
      TemporalUnit,
      ValueRange,
      DateTimeFormatter,
      DateTimeFormatterBuilder,
      DecimalStyle,
      ResolverStyle,
      SignStyle,
      TextStyle
    };
    use = bindUse(jsJodaExports);
    jsJodaExports.use = use;
  }
});
var require_datetime = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/datetime.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _datetimen = _interopRequireDefault(require_datetimen());
    var _core = (init_js_joda_esm(), (0, import_chunk_FVJ3R4NJ.__toCommonJS)(js_joda_esm_exports));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1900, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([8]);
    var DateTime = {
      id: 61,
      type: "DATETIME",
      name: "DateTime",
      declaration: function() {
        return "datetime";
      },
      generateTypeInfo() {
        return Buffer.from([_datetimen.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        let days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        let milliseconds, threeHundredthsOfSecond;
        if (options.useUTC) {
          let seconds = value.getUTCHours() * 60 * 60;
          seconds += value.getUTCMinutes() * 60;
          seconds += value.getUTCSeconds();
          milliseconds = seconds * 1e3 + value.getUTCMilliseconds();
        } else {
          let seconds = value.getHours() * 60 * 60;
          seconds += value.getMinutes() * 60;
          seconds += value.getSeconds();
          milliseconds = seconds * 1e3 + value.getMilliseconds();
        }
        threeHundredthsOfSecond = milliseconds / (3 + 1 / 3);
        threeHundredthsOfSecond = Math.round(threeHundredthsOfSecond);
        if (threeHundredthsOfSecond === 2592e4) {
          days += 1;
          threeHundredthsOfSecond = 0;
        }
        const buffer = Buffer.alloc(8);
        buffer.writeInt32LE(days, 0);
        buffer.writeUInt32LE(threeHundredthsOfSecond, 4);
        yield buffer;
      },
      // TODO: type 'any' needs to be revisited.
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = DateTime;
    exports.default = _default;
    module2.exports = DateTime;
  }
});
var require_float = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/float.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _floatn = _interopRequireDefault(require_floatn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Float = {
      id: 62,
      type: "FLT8",
      name: "Float",
      declaration: function() {
        return "float";
      },
      generateTypeInfo() {
        return Buffer.from([_floatn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return Buffer.from([8]);
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(8);
        buffer.writeDoubleLE(parseFloat(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = Float;
    exports.default = _default;
    module2.exports = Float;
  }
});
var require_decimaln = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/decimaln.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DecimalN = {
      id: 106,
      type: "DECIMALN",
      name: "DecimalN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = DecimalN;
    exports.default = _default;
    module2.exports = DecimalN;
  }
});
var require_decimal = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/decimal.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _decimaln = _interopRequireDefault(require_decimaln());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Decimal = {
      id: 55,
      type: "DECIMAL",
      name: "Decimal",
      declaration: function(parameter) {
        return "decimal(" + this.resolvePrecision(parameter) + ", " + this.resolveScale(parameter) + ")";
      },
      resolvePrecision: function(parameter) {
        if (parameter.precision != null) {
          return parameter.precision;
        } else if (parameter.value === null) {
          return 1;
        } else {
          return 18;
        }
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else {
          return 0;
        }
      },
      generateTypeInfo(parameter, _options) {
        let precision;
        if (parameter.precision <= 9) {
          precision = 5;
        } else if (parameter.precision <= 19) {
          precision = 9;
        } else if (parameter.precision <= 28) {
          precision = 13;
        } else {
          precision = 17;
        }
        return Buffer.from([_decimaln.default.id, precision, parameter.precision, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const precision = parameter.precision;
        if (precision <= 9) {
          return Buffer.from([5]);
        } else if (precision <= 19) {
          return Buffer.from([9]);
        } else if (precision <= 28) {
          return Buffer.from([13]);
        } else {
          return Buffer.from([17]);
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const sign2 = parameter.value < 0 ? 0 : 1;
        const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
        const precision = parameter.precision;
        if (precision <= 9) {
          const buffer = Buffer.alloc(5);
          buffer.writeUInt8(sign2, 0);
          buffer.writeUInt32LE(value, 1);
          yield buffer;
        } else if (precision <= 19) {
          const buffer = new _writableTrackingBuffer.default(9);
          buffer.writeUInt8(sign2);
          buffer.writeUInt64LE(value);
          yield buffer.data;
        } else if (precision <= 28) {
          const buffer = new _writableTrackingBuffer.default(13);
          buffer.writeUInt8(sign2);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        } else {
          const buffer = new _writableTrackingBuffer.default(17);
          buffer.writeUInt8(sign2);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = Decimal;
    exports.default = _default;
    module2.exports = Decimal;
  }
});
var require_numericn = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/numericn.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NumericN = {
      id: 108,
      type: "NUMERICN",
      name: "NumericN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = NumericN;
    exports.default = _default;
    module2.exports = NumericN;
  }
});
var require_numeric = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/numeric.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _numericn = _interopRequireDefault(require_numericn());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Numeric = {
      id: 63,
      type: "NUMERIC",
      name: "Numeric",
      declaration: function(parameter) {
        return "numeric(" + this.resolvePrecision(parameter) + ", " + this.resolveScale(parameter) + ")";
      },
      resolvePrecision: function(parameter) {
        if (parameter.precision != null) {
          return parameter.precision;
        } else if (parameter.value === null) {
          return 1;
        } else {
          return 18;
        }
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else {
          return 0;
        }
      },
      generateTypeInfo(parameter) {
        let precision;
        if (parameter.precision <= 9) {
          precision = 5;
        } else if (parameter.precision <= 19) {
          precision = 9;
        } else if (parameter.precision <= 28) {
          precision = 13;
        } else {
          precision = 17;
        }
        return Buffer.from([_numericn.default.id, precision, parameter.precision, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const precision = parameter.precision;
        if (precision <= 9) {
          return Buffer.from([5]);
        } else if (precision <= 19) {
          return Buffer.from([9]);
        } else if (precision <= 28) {
          return Buffer.from([13]);
        } else {
          return Buffer.from([17]);
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const sign2 = parameter.value < 0 ? 0 : 1;
        const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
        if (parameter.precision <= 9) {
          const buffer = Buffer.alloc(5);
          buffer.writeUInt8(sign2, 0);
          buffer.writeUInt32LE(value, 1);
          yield buffer;
        } else if (parameter.precision <= 19) {
          const buffer = new _writableTrackingBuffer.default(10);
          buffer.writeUInt8(sign2);
          buffer.writeUInt64LE(value);
          yield buffer.data;
        } else if (parameter.precision <= 28) {
          const buffer = new _writableTrackingBuffer.default(14);
          buffer.writeUInt8(sign2);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        } else {
          const buffer = new _writableTrackingBuffer.default(18);
          buffer.writeUInt8(sign2);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = Numeric;
    exports.default = _default;
    module2.exports = Numeric;
  }
});
var require_smallmoney = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/smallmoney.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _moneyn = _interopRequireDefault(require_moneyn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([4]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallMoney = {
      id: 122,
      type: "MONEY4",
      name: "SmallMoney",
      declaration: function() {
        return "smallmoney";
      },
      generateTypeInfo: function() {
        return Buffer.from([_moneyn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(parameter.value * 1e4, 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -214748.3648 || value > 214748.3647) {
          throw new TypeError("Value must be between -214748.3648 and 214748.3647.");
        }
        return value;
      }
    };
    var _default = SmallMoney;
    exports.default = _default;
    module2.exports = SmallMoney;
  }
});
var require_bigint = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/bigint.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([8]);
    var NULL_LENGTH = Buffer.from([0]);
    var BigInt2 = {
      id: 127,
      type: "INT8",
      name: "BigInt",
      declaration: function() {
        return "bigint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = new _writableTrackingBuffer.default(8);
        buffer.writeInt64LE(Number(parameter.value));
        yield buffer.data;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {
          throw new TypeError(`Value must be between ${Number.MIN_SAFE_INTEGER} and ${Number.MAX_SAFE_INTEGER}, inclusive.  For smaller or bigger numbers, use VarChar type.`);
        }
        return value;
      }
    };
    var _default = BigInt2;
    exports.default = _default;
    module2.exports = BigInt2;
  }
});
var require_image = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/image.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var Image = {
      id: 34,
      type: "IMAGE",
      name: "Image",
      hasTableName: true,
      declaration: function() {
        return "image";
      },
      resolveLength: function(parameter) {
        if (parameter.value != null) {
          const value = parameter.value;
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(5);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(parameter.value.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = Image;
    exports.default = _default;
    module2.exports = Image;
  }
});
var require_text = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/text.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iconvLite = _interopRequireDefault((0, import_chunk_NTREA7ZR.require_lib)());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var Text = {
      id: 35,
      type: "TEXT",
      name: "Text",
      hasTableName: true,
      declaration: function() {
        return "text";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter, _options) {
        const buffer = Buffer.alloc(10);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(value.length, 0);
        return buffer;
      },
      generateParameterData: function* (parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return;
        }
        yield value;
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = Text;
    exports.default = _default;
    module2.exports = Text;
  }
});
var require_guid_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/guid-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bufferToLowerCaseGuid = bufferToLowerCaseGuid;
    exports.bufferToUpperCaseGuid = bufferToUpperCaseGuid;
    exports.guidToArray = guidToArray;
    var UPPER_CASE_MAP = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF", "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF", "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF", "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF", "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"];
    var LOWER_CASE_MAP = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    function bufferToUpperCaseGuid(buffer) {
      return UPPER_CASE_MAP[buffer[3]] + UPPER_CASE_MAP[buffer[2]] + UPPER_CASE_MAP[buffer[1]] + UPPER_CASE_MAP[buffer[0]] + "-" + UPPER_CASE_MAP[buffer[5]] + UPPER_CASE_MAP[buffer[4]] + "-" + UPPER_CASE_MAP[buffer[7]] + UPPER_CASE_MAP[buffer[6]] + "-" + UPPER_CASE_MAP[buffer[8]] + UPPER_CASE_MAP[buffer[9]] + "-" + UPPER_CASE_MAP[buffer[10]] + UPPER_CASE_MAP[buffer[11]] + UPPER_CASE_MAP[buffer[12]] + UPPER_CASE_MAP[buffer[13]] + UPPER_CASE_MAP[buffer[14]] + UPPER_CASE_MAP[buffer[15]];
    }
    function bufferToLowerCaseGuid(buffer) {
      return LOWER_CASE_MAP[buffer[3]] + LOWER_CASE_MAP[buffer[2]] + LOWER_CASE_MAP[buffer[1]] + LOWER_CASE_MAP[buffer[0]] + "-" + LOWER_CASE_MAP[buffer[5]] + LOWER_CASE_MAP[buffer[4]] + "-" + LOWER_CASE_MAP[buffer[7]] + LOWER_CASE_MAP[buffer[6]] + "-" + LOWER_CASE_MAP[buffer[8]] + LOWER_CASE_MAP[buffer[9]] + "-" + LOWER_CASE_MAP[buffer[10]] + LOWER_CASE_MAP[buffer[11]] + LOWER_CASE_MAP[buffer[12]] + LOWER_CASE_MAP[buffer[13]] + LOWER_CASE_MAP[buffer[14]] + LOWER_CASE_MAP[buffer[15]];
    }
    var CHARCODEMAP = {};
    var hexDigits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"].map((d) => d.charCodeAt(0));
    for (let i = 0; i < hexDigits.length; i++) {
      const map = CHARCODEMAP[hexDigits[i]] = {};
      for (let j = 0; j < hexDigits.length; j++) {
        const hex = String.fromCharCode(hexDigits[i], hexDigits[j]);
        const value = parseInt(hex, 16);
        map[hexDigits[j]] = value;
      }
    }
    function guidToArray(guid) {
      return [CHARCODEMAP[guid.charCodeAt(6)][guid.charCodeAt(7)], CHARCODEMAP[guid.charCodeAt(4)][guid.charCodeAt(5)], CHARCODEMAP[guid.charCodeAt(2)][guid.charCodeAt(3)], CHARCODEMAP[guid.charCodeAt(0)][guid.charCodeAt(1)], CHARCODEMAP[guid.charCodeAt(11)][guid.charCodeAt(12)], CHARCODEMAP[guid.charCodeAt(9)][guid.charCodeAt(10)], CHARCODEMAP[guid.charCodeAt(16)][guid.charCodeAt(17)], CHARCODEMAP[guid.charCodeAt(14)][guid.charCodeAt(15)], CHARCODEMAP[guid.charCodeAt(19)][guid.charCodeAt(20)], CHARCODEMAP[guid.charCodeAt(21)][guid.charCodeAt(22)], CHARCODEMAP[guid.charCodeAt(24)][guid.charCodeAt(25)], CHARCODEMAP[guid.charCodeAt(26)][guid.charCodeAt(27)], CHARCODEMAP[guid.charCodeAt(28)][guid.charCodeAt(29)], CHARCODEMAP[guid.charCodeAt(30)][guid.charCodeAt(31)], CHARCODEMAP[guid.charCodeAt(32)][guid.charCodeAt(33)], CHARCODEMAP[guid.charCodeAt(34)][guid.charCodeAt(35)]];
    }
  }
});
var require_uniqueidentifier = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/uniqueidentifier.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _guidParser = require_guid_parser();
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([16]);
    var UniqueIdentifier = {
      id: 36,
      type: "GUIDN",
      name: "UniqueIdentifier",
      declaration: function() {
        return "uniqueidentifier";
      },
      resolveLength: function() {
        return 16;
      },
      generateTypeInfo() {
        return Buffer.from([this.id, 16]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from((0, _guidParser.guidToArray)(parameter.value));
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
          throw new TypeError("Invalid GUID.");
        }
        return value;
      }
    };
    var _default = UniqueIdentifier;
    exports.default = _default;
    module2.exports = UniqueIdentifier;
  }
});
var require_ntext = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/ntext.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var NText = {
      id: 99,
      type: "NTEXT",
      name: "NText",
      hasTableName: true,
      declaration: function() {
        return "ntext";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter, _options) {
        const buffer = Buffer.alloc(10);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(Buffer.byteLength(parameter.value, "ucs2"), 0);
        return buffer;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from(parameter.value.toString(), "ucs2");
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = NText;
    exports.default = _default;
    module2.exports = NText;
  }
});
var require_varbinary = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/varbinary.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var VarBinary = {
      id: 165,
      type: "BIGVARBIN",
      name: "VarBinary",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "varbinary(" + length + ")";
        } else {
          return "varbinary(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo: function(parameter) {
        const buffer = Buffer.alloc(3);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        let value = parameter.value;
        if (!Buffer.isBuffer(value)) {
          value = value.toString();
        }
        const length = Buffer.byteLength(value, "ucs2");
        if (parameter.length <= this.maximumLength) {
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          if (Buffer.isBuffer(value)) {
            yield value;
          } else {
            yield Buffer.from(value.toString(), "ucs2");
          }
        } else {
          if (!Buffer.isBuffer(value)) {
            value = value.toString();
          }
          const length = Buffer.byteLength(value, "ucs2");
          if (length > 0) {
            const buffer = Buffer.alloc(4);
            buffer.writeUInt32LE(length, 0);
            yield buffer;
            if (Buffer.isBuffer(value)) {
              yield value;
            } else {
              yield Buffer.from(value, "ucs2");
            }
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = VarBinary;
    exports.default = _default;
    module2.exports = VarBinary;
  }
});
var require_varchar = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/varchar.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iconvLite = _interopRequireDefault((0, import_chunk_NTREA7ZR.require_lib)());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var VarChar = {
      id: 167,
      type: "BIGVARCHR",
      name: "VarChar",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "varchar(" + length + ")";
        } else {
          return "varchar(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length || 1;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        if (parameter.length <= this.maximumLength) {
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(value.length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return;
        }
        if (parameter.length <= this.maximumLength) {
          yield value;
        } else {
          if (value.length > 0) {
            const buffer = Buffer.alloc(4);
            buffer.writeUInt32LE(value.length, 0);
            yield buffer;
            yield value;
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = VarChar;
    exports.default = _default;
    module2.exports = VarChar;
  }
});
var require_binary = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/binary.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255]);
    var Binary = {
      id: 173,
      type: "BIGBinary",
      name: "Binary",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        return "binary(" + length + ")";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(3);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length, 1);
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(parameter.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value.slice(0, parameter.length !== void 0 ? Math.min(parameter.length, this.maximumLength) : this.maximumLength);
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = Binary;
    exports.default = _default;
    module2.exports = Binary;
  }
});
var require_char = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/char.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iconvLite = _interopRequireDefault((0, import_chunk_NTREA7ZR.require_lib)());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([255, 255]);
    var Char = {
      id: 175,
      type: "BIGCHAR",
      name: "Char",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length < this.maximumLength) {
          return "char(" + length + ")";
        } else {
          return "char(" + this.maximumLength + ")";
        }
      },
      // ParameterData<any> is temporary solution. TODO: need to understand what type ParameterData<...> can be.
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length || 1;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(value.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from(parameter.value, "ascii");
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = Char;
    exports.default = _default;
    module2.exports = Char;
  }
});
var require_nvarchar = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/nvarchar.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var NVarChar = {
      id: 231,
      type: "NVARCHAR",
      name: "NVarChar",
      maximumLength: 4e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.toString().length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "nvarchar(" + length + ")";
        } else {
          return "nvarchar(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          if (Buffer.isBuffer(value)) {
            return value.length / 2 || 1;
          } else {
            return value.toString().length || 1;
          }
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length * 2, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          let length;
          if (value instanceof Buffer) {
            length = value.length;
          } else {
            value = value.toString();
            length = Buffer.byteLength(value, "ucs2");
          }
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          if (value instanceof Buffer) {
            yield value;
          } else {
            value = value.toString();
            yield Buffer.from(value, "ucs2");
          }
        } else {
          if (value instanceof Buffer) {
            const length = value.length;
            if (length > 0) {
              const buffer = Buffer.alloc(4);
              buffer.writeUInt32LE(length, 0);
              yield buffer;
              yield value;
            }
          } else {
            value = value.toString();
            const length = Buffer.byteLength(value, "ucs2");
            if (length > 0) {
              const buffer = Buffer.alloc(4);
              buffer.writeUInt32LE(length, 0);
              yield buffer;
              yield Buffer.from(value, "ucs2");
            }
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = NVarChar;
    exports.default = _default;
    module2.exports = NVarChar;
  }
});
var require_nchar = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/nchar.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255]);
    var NChar = {
      id: 239,
      type: "NCHAR",
      name: "NChar",
      maximumLength: 4e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (parameter.value != null) {
          length = value.toString().length || 1;
        } else if (parameter.value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length < this.maximumLength) {
          return "nchar(" + length + ")";
        } else {
          return "nchar(" + this.maximumLength + ")";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (parameter.value != null) {
          if (Buffer.isBuffer(parameter.value)) {
            return parameter.value.length / 2 || 1;
          } else {
            return value.toString().length || 1;
          }
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo: function(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length * 2, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const {
          value
        } = parameter;
        if (value instanceof Buffer) {
          const length = value.length;
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          const length = Buffer.byteLength(value.toString(), "ucs2");
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        if (value instanceof Buffer) {
          yield value;
        } else {
          yield Buffer.from(value, "ucs2");
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = NChar;
    exports.default = _default;
    module2.exports = NChar;
  }
});
var require_xml = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/xml.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var XML = {
      id: 241,
      type: "XML",
      name: "Xml",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = XML;
    exports.default = _default;
    module2.exports = XML;
  }
});
var require_time = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/time.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Time = {
      id: 41,
      type: "TIMEN",
      name: "Time",
      declaration: function(parameter) {
        return "time(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([3]);
          case 3:
          case 4:
            return Buffer.from([4]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([5]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = new _writableTrackingBuffer.default(16);
        const time = parameter.value;
        let timestamp;
        if (options.useUTC) {
          timestamp = ((time.getUTCHours() * 60 + time.getUTCMinutes()) * 60 + time.getUTCSeconds()) * 1e3 + time.getUTCMilliseconds();
        } else {
          timestamp = ((time.getHours() * 60 + time.getMinutes()) * 60 + time.getSeconds()) * 1e3 + time.getMilliseconds();
        }
        timestamp = timestamp * Math.pow(10, parameter.scale - 3);
        timestamp += (parameter.value.nanosecondDelta != null ? parameter.value.nanosecondDelta : 0) * Math.pow(10, parameter.scale);
        timestamp = Math.round(timestamp);
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        yield buffer.data;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid time.");
        }
        return value;
      }
    };
    var _default = Time;
    exports.default = _default;
    module2.exports = Time;
  }
});
var require_date = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/date.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = (init_js_joda_esm(), (0, import_chunk_FVJ3R4NJ.__toCommonJS)(js_joda_esm_exports));
    var globalDate = global.Date;
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([3]);
    var Date2 = {
      id: 40,
      type: "DATEN",
      name: "Date",
      declaration: function() {
        return "date";
      },
      generateTypeInfo: function() {
        return Buffer.from([this.id]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        const buffer = Buffer.alloc(3);
        buffer.writeUIntLE(days, 0, 3);
        yield buffer;
      },
      // TODO: value is techincally of type 'unknown'.
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof globalDate)) {
          value = new globalDate(globalDate.parse(value));
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = Date2;
    exports.default = _default;
    module2.exports = Date2;
  }
});
var require_datetime2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/datetime2.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = (init_js_joda_esm(), (0, import_chunk_FVJ3R4NJ.__toCommonJS)(js_joda_esm_exports));
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DateTime2 = {
      id: 42,
      type: "DATETIME2N",
      name: "DateTime2",
      declaration: function(parameter) {
        return "datetime2(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter, _options) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([6]);
          case 3:
          case 4:
            return Buffer.from([7]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([8]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let scale = parameter.scale;
        const buffer = new _writableTrackingBuffer.default(16);
        scale = scale;
        let timestamp;
        if (options.useUTC) {
          timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1e3 + value.getUTCMilliseconds();
        } else {
          timestamp = ((value.getHours() * 60 + value.getMinutes()) * 60 + value.getSeconds()) * 1e3 + value.getMilliseconds();
        }
        timestamp = timestamp * Math.pow(10, scale - 3);
        timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
        timestamp = Math.round(timestamp);
        switch (scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        buffer.writeUInt24LE(days);
        yield buffer.data;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = DateTime2;
    exports.default = _default;
    module2.exports = DateTime2;
  }
});
var require_datetimeoffset = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/datetimeoffset.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = (init_js_joda_esm(), (0, import_chunk_FVJ3R4NJ.__toCommonJS)(js_joda_esm_exports));
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DateTimeOffset = {
      id: 43,
      type: "DATETIMEOFFSETN",
      name: "DateTimeOffset",
      declaration: function(parameter) {
        return "datetimeoffset(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([8]);
          case 3:
          case 4:
            return Buffer.from([9]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([10]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let scale = parameter.scale;
        const buffer = new _writableTrackingBuffer.default(16);
        scale = scale;
        let timestamp;
        timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1e3 + value.getMilliseconds();
        timestamp = timestamp * Math.pow(10, scale - 3);
        timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
        timestamp = Math.round(timestamp);
        switch (scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        const date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        buffer.writeUInt24LE(days);
        const offset = -value.getTimezoneOffset();
        buffer.writeInt16LE(offset);
        yield buffer.data;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = DateTimeOffset;
    exports.default = _default;
    module2.exports = DateTimeOffset;
  }
});
var require_udt = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/udt.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var UDT = {
      id: 240,
      type: "UDTTYPE",
      name: "UDT",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = UDT;
    exports.default = _default;
    module2.exports = UDT;
  }
});
var require_tvp = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/tvp.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TVP_ROW_TOKEN = Buffer.from([1]);
    var TVP_END_TOKEN = Buffer.from([0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var TVP = {
      id: 243,
      type: "TVPTYPE",
      name: "TVP",
      declaration: function(parameter) {
        const value = parameter.value;
        return value.name + " readonly";
      },
      generateTypeInfo(parameter) {
        var _parameter$value, _parameter$value2;
        const databaseName = "";
        const schema = ((_parameter$value = parameter.value) === null || _parameter$value === void 0 ? void 0 : _parameter$value.schema) ?? "";
        const typeName = ((_parameter$value2 = parameter.value) === null || _parameter$value2 === void 0 ? void 0 : _parameter$value2.name) ?? "";
        const bufferLength = 1 + 1 + Buffer.byteLength(databaseName, "ucs2") + 1 + Buffer.byteLength(schema, "ucs2") + 1 + Buffer.byteLength(typeName, "ucs2");
        const buffer = new _writableTrackingBuffer.default(bufferLength, "ucs2");
        buffer.writeUInt8(this.id);
        buffer.writeBVarchar(databaseName);
        buffer.writeBVarchar(schema);
        buffer.writeBVarchar(typeName);
        return buffer.data;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const {
          columns
        } = parameter.value;
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(columns.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          yield TVP_END_TOKEN;
          yield TVP_END_TOKEN;
          return;
        }
        const {
          columns,
          rows
        } = parameter.value;
        for (let i = 0, len = columns.length; i < len; i++) {
          const column = columns[i];
          const buff = Buffer.alloc(6);
          buff.writeUInt32LE(0, 0);
          buff.writeUInt16LE(0, 4);
          yield buff;
          yield column.type.generateTypeInfo(column);
          yield Buffer.from([0]);
        }
        yield TVP_END_TOKEN;
        for (let i = 0, length = rows.length; i < length; i++) {
          yield TVP_ROW_TOKEN;
          const row = rows[i];
          for (let k = 0, len2 = row.length; k < len2; k++) {
            const column = columns[k];
            const value = row[k];
            const param = {
              value: column.type.validate(value, parameter.collation),
              length: column.length,
              scale: column.scale,
              precision: column.precision
            };
            yield column.type.generateParameterLength(param, options);
            yield* column.type.generateParameterData(param, options);
          }
        }
        yield TVP_END_TOKEN;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "object") {
          throw new TypeError("Invalid table.");
        }
        if (!Array.isArray(value.columns)) {
          throw new TypeError("Invalid table.");
        }
        if (!Array.isArray(value.rows)) {
          throw new TypeError("Invalid table.");
        }
        return value;
      }
    };
    var _default = TVP;
    exports.default = _default;
    module2.exports = TVP;
  }
});
var require_sql_variant = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-types/sql-variant.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Variant = {
      id: 98,
      type: "SSVARIANTTYPE",
      name: "Variant",
      declaration: function() {
        return "sql_variant";
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = Variant;
    exports.default = _default;
    module2.exports = Variant;
  }
});
var require_data_type = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/data-type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.typeByName = exports.TYPES = exports.TYPE = void 0;
    var _null = _interopRequireDefault(require_null());
    var _tinyint = _interopRequireDefault(require_tinyint());
    var _bit = _interopRequireDefault(require_bit());
    var _smallint = _interopRequireDefault(require_smallint());
    var _int = _interopRequireDefault(require_int());
    var _smalldatetime = _interopRequireDefault(require_smalldatetime());
    var _real = _interopRequireDefault(require_real());
    var _money = _interopRequireDefault(require_money());
    var _datetime = _interopRequireDefault(require_datetime());
    var _float = _interopRequireDefault(require_float());
    var _decimal = _interopRequireDefault(require_decimal());
    var _numeric = _interopRequireDefault(require_numeric());
    var _smallmoney = _interopRequireDefault(require_smallmoney());
    var _bigint = _interopRequireDefault(require_bigint());
    var _image = _interopRequireDefault(require_image());
    var _text = _interopRequireDefault(require_text());
    var _uniqueidentifier = _interopRequireDefault(require_uniqueidentifier());
    var _intn = _interopRequireDefault(require_intn());
    var _ntext = _interopRequireDefault(require_ntext());
    var _bitn = _interopRequireDefault(require_bitn());
    var _decimaln = _interopRequireDefault(require_decimaln());
    var _numericn = _interopRequireDefault(require_numericn());
    var _floatn = _interopRequireDefault(require_floatn());
    var _moneyn = _interopRequireDefault(require_moneyn());
    var _datetimen = _interopRequireDefault(require_datetimen());
    var _varbinary = _interopRequireDefault(require_varbinary());
    var _varchar = _interopRequireDefault(require_varchar());
    var _binary = _interopRequireDefault(require_binary());
    var _char = _interopRequireDefault(require_char());
    var _nvarchar = _interopRequireDefault(require_nvarchar());
    var _nchar = _interopRequireDefault(require_nchar());
    var _xml = _interopRequireDefault(require_xml());
    var _time = _interopRequireDefault(require_time());
    var _date = _interopRequireDefault(require_date());
    var _datetime2 = _interopRequireDefault(require_datetime2());
    var _datetimeoffset = _interopRequireDefault(require_datetimeoffset());
    var _udt = _interopRequireDefault(require_udt());
    var _tvp = _interopRequireDefault(require_tvp());
    var _sqlVariant = _interopRequireDefault(require_sql_variant());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TYPE = {
      [_null.default.id]: _null.default,
      [_tinyint.default.id]: _tinyint.default,
      [_bit.default.id]: _bit.default,
      [_smallint.default.id]: _smallint.default,
      [_int.default.id]: _int.default,
      [_smalldatetime.default.id]: _smalldatetime.default,
      [_real.default.id]: _real.default,
      [_money.default.id]: _money.default,
      [_datetime.default.id]: _datetime.default,
      [_float.default.id]: _float.default,
      [_decimal.default.id]: _decimal.default,
      [_numeric.default.id]: _numeric.default,
      [_smallmoney.default.id]: _smallmoney.default,
      [_bigint.default.id]: _bigint.default,
      [_image.default.id]: _image.default,
      [_text.default.id]: _text.default,
      [_uniqueidentifier.default.id]: _uniqueidentifier.default,
      [_intn.default.id]: _intn.default,
      [_ntext.default.id]: _ntext.default,
      [_bitn.default.id]: _bitn.default,
      [_decimaln.default.id]: _decimaln.default,
      [_numericn.default.id]: _numericn.default,
      [_floatn.default.id]: _floatn.default,
      [_moneyn.default.id]: _moneyn.default,
      [_datetimen.default.id]: _datetimen.default,
      [_varbinary.default.id]: _varbinary.default,
      [_varchar.default.id]: _varchar.default,
      [_binary.default.id]: _binary.default,
      [_char.default.id]: _char.default,
      [_nvarchar.default.id]: _nvarchar.default,
      [_nchar.default.id]: _nchar.default,
      [_xml.default.id]: _xml.default,
      [_time.default.id]: _time.default,
      [_date.default.id]: _date.default,
      [_datetime2.default.id]: _datetime2.default,
      [_datetimeoffset.default.id]: _datetimeoffset.default,
      [_udt.default.id]: _udt.default,
      [_tvp.default.id]: _tvp.default,
      [_sqlVariant.default.id]: _sqlVariant.default
    };
    exports.TYPE = TYPE;
    var TYPES = {
      TinyInt: _tinyint.default,
      Bit: _bit.default,
      SmallInt: _smallint.default,
      Int: _int.default,
      SmallDateTime: _smalldatetime.default,
      Real: _real.default,
      Money: _money.default,
      DateTime: _datetime.default,
      Float: _float.default,
      Decimal: _decimal.default,
      Numeric: _numeric.default,
      SmallMoney: _smallmoney.default,
      BigInt: _bigint.default,
      Image: _image.default,
      Text: _text.default,
      UniqueIdentifier: _uniqueidentifier.default,
      NText: _ntext.default,
      VarBinary: _varbinary.default,
      VarChar: _varchar.default,
      Binary: _binary.default,
      Char: _char.default,
      NVarChar: _nvarchar.default,
      NChar: _nchar.default,
      Xml: _xml.default,
      Time: _time.default,
      Date: _date.default,
      DateTime2: _datetime2.default,
      DateTimeOffset: _datetimeoffset.default,
      UDT: _udt.default,
      TVP: _tvp.default,
      Variant: _sqlVariant.default
    };
    exports.TYPES = TYPES;
    var typeByName = TYPES;
    exports.typeByName = typeByName;
  }
});
var require_metadata_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/metadata-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.readCollation = readCollation;
    var _collation = require_collation();
    var _dataType = require_data_type();
    var _sprintfJs = require_sprintf();
    function readCollation(parser, callback) {
      parser.readBuffer(5, (collationData) => {
        callback(_collation.Collation.fromBuffer(collationData));
      });
    }
    function readSchema(parser, callback) {
      parser.readUInt8((schemaPresent) => {
        if (schemaPresent === 1) {
          parser.readBVarChar((dbname) => {
            parser.readBVarChar((owningSchema) => {
              parser.readUsVarChar((xmlSchemaCollection) => {
                callback({
                  dbname,
                  owningSchema,
                  xmlSchemaCollection
                });
              });
            });
          });
        } else {
          callback(void 0);
        }
      });
    }
    function readUDTInfo(parser, callback) {
      parser.readUInt16LE((maxByteSize) => {
        parser.readBVarChar((dbname) => {
          parser.readBVarChar((owningSchema) => {
            parser.readBVarChar((typeName) => {
              parser.readUsVarChar((assemblyName) => {
                callback({
                  maxByteSize,
                  dbname,
                  owningSchema,
                  typeName,
                  assemblyName
                });
              });
            });
          });
        });
      });
    }
    function metadataParse(parser, options, callback) {
      (options.tdsVersion < "7_2" ? parser.readUInt16LE : parser.readUInt32LE).call(parser, (userType) => {
        parser.readUInt16LE((flags) => {
          parser.readUInt8((typeNumber) => {
            const type2 = _dataType.TYPE[typeNumber];
            if (!type2) {
              throw new Error((0, _sprintfJs.sprintf)("Unrecognised data type 0x%02X", typeNumber));
            }
            switch (type2.name) {
              case "Null":
              case "TinyInt":
              case "SmallInt":
              case "Int":
              case "BigInt":
              case "Real":
              case "Float":
              case "SmallMoney":
              case "Money":
              case "Bit":
              case "SmallDateTime":
              case "DateTime":
              case "Date":
                return callback({
                  userType,
                  flags,
                  type: type2,
                  collation: void 0,
                  precision: void 0,
                  scale: void 0,
                  dataLength: void 0,
                  schema: void 0,
                  udtInfo: void 0
                });
              case "IntN":
              case "FloatN":
              case "MoneyN":
              case "BitN":
              case "UniqueIdentifier":
              case "DateTimeN":
                return parser.readUInt8((dataLength) => {
                  callback({
                    userType,
                    flags,
                    type: type2,
                    collation: void 0,
                    precision: void 0,
                    scale: void 0,
                    dataLength,
                    schema: void 0,
                    udtInfo: void 0
                  });
                });
              case "Variant":
                return parser.readUInt32LE((dataLength) => {
                  callback({
                    userType,
                    flags,
                    type: type2,
                    collation: void 0,
                    precision: void 0,
                    scale: void 0,
                    dataLength,
                    schema: void 0,
                    udtInfo: void 0
                  });
                });
              case "VarChar":
              case "Char":
              case "NVarChar":
              case "NChar":
                return parser.readUInt16LE((dataLength) => {
                  readCollation(parser, (collation) => {
                    callback({
                      userType,
                      flags,
                      type: type2,
                      collation,
                      precision: void 0,
                      scale: void 0,
                      dataLength,
                      schema: void 0,
                      udtInfo: void 0
                    });
                  });
                });
              case "Text":
              case "NText":
                return parser.readUInt32LE((dataLength) => {
                  readCollation(parser, (collation) => {
                    callback({
                      userType,
                      flags,
                      type: type2,
                      collation,
                      precision: void 0,
                      scale: void 0,
                      dataLength,
                      schema: void 0,
                      udtInfo: void 0
                    });
                  });
                });
              case "VarBinary":
              case "Binary":
                return parser.readUInt16LE((dataLength) => {
                  callback({
                    userType,
                    flags,
                    type: type2,
                    collation: void 0,
                    precision: void 0,
                    scale: void 0,
                    dataLength,
                    schema: void 0,
                    udtInfo: void 0
                  });
                });
              case "Image":
                return parser.readUInt32LE((dataLength) => {
                  callback({
                    userType,
                    flags,
                    type: type2,
                    collation: void 0,
                    precision: void 0,
                    scale: void 0,
                    dataLength,
                    schema: void 0,
                    udtInfo: void 0
                  });
                });
              case "Xml":
                return readSchema(parser, (schema) => {
                  callback({
                    userType,
                    flags,
                    type: type2,
                    collation: void 0,
                    precision: void 0,
                    scale: void 0,
                    dataLength: void 0,
                    schema,
                    udtInfo: void 0
                  });
                });
              case "Time":
              case "DateTime2":
              case "DateTimeOffset":
                return parser.readUInt8((scale) => {
                  callback({
                    userType,
                    flags,
                    type: type2,
                    collation: void 0,
                    precision: void 0,
                    scale,
                    dataLength: void 0,
                    schema: void 0,
                    udtInfo: void 0
                  });
                });
              case "NumericN":
              case "DecimalN":
                return parser.readUInt8((dataLength) => {
                  parser.readUInt8((precision) => {
                    parser.readUInt8((scale) => {
                      callback({
                        userType,
                        flags,
                        type: type2,
                        collation: void 0,
                        precision,
                        scale,
                        dataLength,
                        schema: void 0,
                        udtInfo: void 0
                      });
                    });
                  });
                });
              case "UDT":
                return readUDTInfo(parser, (udtInfo) => {
                  callback({
                    userType,
                    flags,
                    type: type2,
                    collation: void 0,
                    precision: void 0,
                    scale: void 0,
                    dataLength: void 0,
                    schema: void 0,
                    udtInfo
                  });
                });
              default:
                throw new Error((0, _sprintfJs.sprintf)("Unrecognised type %s", type2.name));
            }
          });
        });
      });
    }
    var _default = metadataParse;
    exports.default = _default;
    module2.exports = metadataParse;
    module2.exports.readCollation = readCollation;
  }
});
var require_colmetadata_token_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/colmetadata-token-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _metadataParser = _interopRequireDefault(require_metadata_parser());
    var _token = require_token();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function readTableName(parser, options, metadata, callback) {
      if (metadata.type.hasTableName) {
        if (options.tdsVersion >= "7_2") {
          parser.readUInt8((numberOfTableNameParts) => {
            const tableName = [];
            let i = 0;
            function next(done) {
              if (numberOfTableNameParts === i) {
                return done();
              }
              parser.readUsVarChar((part) => {
                tableName.push(part);
                i++;
                next(done);
              });
            }
            next(() => {
              callback(tableName);
            });
          });
        } else {
          parser.readUsVarChar(callback);
        }
      } else {
        callback(void 0);
      }
    }
    function readColumnName(parser, options, index, metadata, callback) {
      parser.readBVarChar((colName) => {
        if (options.columnNameReplacer) {
          callback(options.columnNameReplacer(colName, index, metadata));
        } else if (options.camelCaseColumns) {
          callback(colName.replace(/^[A-Z]/, function(s) {
            return s.toLowerCase();
          }));
        } else {
          callback(colName);
        }
      });
    }
    function readColumn(parser, options, index, callback) {
      (0, _metadataParser.default)(parser, options, (metadata) => {
        readTableName(parser, options, metadata, (tableName) => {
          readColumnName(parser, options, index, metadata, (colName) => {
            callback({
              userType: metadata.userType,
              flags: metadata.flags,
              type: metadata.type,
              collation: metadata.collation,
              precision: metadata.precision,
              scale: metadata.scale,
              udtInfo: metadata.udtInfo,
              dataLength: metadata.dataLength,
              schema: metadata.schema,
              colName,
              tableName
            });
          });
        });
      });
    }
    async function colMetadataParser(parser) {
      while (parser.buffer.length - parser.position < 2) {
        await parser.streamBuffer.waitForChunk();
      }
      const columnCount = parser.buffer.readUInt16LE(parser.position);
      parser.position += 2;
      const columns = [];
      for (let i = 0; i < columnCount; i++) {
        let column;
        readColumn(parser, parser.options, i, (c) => {
          column = c;
        });
        while (parser.suspended) {
          await parser.streamBuffer.waitForChunk();
          parser.suspended = false;
          const next = parser.next;
          next();
        }
        columns.push(column);
      }
      return new _token.ColMetadataToken(columns);
    }
    var _default = colMetadataParser;
    exports.default = _default;
    module2.exports = colMetadataParser;
  }
});
var require_done_token_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/done-token-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.doneInProcParser = doneInProcParser;
    exports.doneParser = doneParser;
    exports.doneProcParser = doneProcParser;
    var _token = require_token();
    var STATUS = {
      MORE: 1,
      ERROR: 2,
      // This bit is not yet in use by SQL Server, so is not exposed in the returned token
      INXACT: 4,
      COUNT: 16,
      ATTN: 32,
      SRVERROR: 256
    };
    function parseToken(parser, options, callback) {
      parser.readUInt16LE((status) => {
        const more = !!(status & STATUS.MORE);
        const sqlError = !!(status & STATUS.ERROR);
        const rowCountValid = !!(status & STATUS.COUNT);
        const attention = !!(status & STATUS.ATTN);
        const serverError = !!(status & STATUS.SRVERROR);
        parser.readUInt16LE((curCmd) => {
          const next = (rowCount) => {
            callback({
              more,
              sqlError,
              attention,
              serverError,
              rowCount: rowCountValid ? rowCount : void 0,
              curCmd
            });
          };
          if (options.tdsVersion < "7_2") {
            parser.readUInt32LE(next);
          } else {
            parser.readBigUInt64LE((rowCount) => {
              next(Number(rowCount));
            });
          }
        });
      });
    }
    function doneParser(parser, options, callback) {
      parseToken(parser, options, (data) => {
        callback(new _token.DoneToken(data));
      });
    }
    function doneInProcParser(parser, options, callback) {
      parseToken(parser, options, (data) => {
        callback(new _token.DoneInProcToken(data));
      });
    }
    function doneProcParser(parser, options, callback) {
      parseToken(parser, options, (data) => {
        callback(new _token.DoneProcToken(data));
      });
    }
  }
});
var require_env_change_token_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/env-change-token-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _collation = require_collation();
    var _token = require_token();
    var types = {
      1: {
        name: "DATABASE",
        event: "databaseChange"
      },
      2: {
        name: "LANGUAGE",
        event: "languageChange"
      },
      3: {
        name: "CHARSET",
        event: "charsetChange"
      },
      4: {
        name: "PACKET_SIZE",
        event: "packetSizeChange"
      },
      7: {
        name: "SQL_COLLATION",
        event: "sqlCollationChange"
      },
      8: {
        name: "BEGIN_TXN",
        event: "beginTransaction"
      },
      9: {
        name: "COMMIT_TXN",
        event: "commitTransaction"
      },
      10: {
        name: "ROLLBACK_TXN",
        event: "rollbackTransaction"
      },
      13: {
        name: "DATABASE_MIRRORING_PARTNER",
        event: "partnerNode"
      },
      17: {
        name: "TXN_ENDED"
      },
      18: {
        name: "RESET_CONNECTION",
        event: "resetConnection"
      },
      20: {
        name: "ROUTING_CHANGE",
        event: "routingChange"
      }
    };
    function readNewAndOldValue(parser, length, type2, callback) {
      switch (type2.name) {
        case "DATABASE":
        case "LANGUAGE":
        case "CHARSET":
        case "PACKET_SIZE":
        case "DATABASE_MIRRORING_PARTNER":
          return parser.readBVarChar((newValue) => {
            parser.readBVarChar((oldValue) => {
              switch (type2.name) {
                case "PACKET_SIZE":
                  return callback(new _token.PacketSizeEnvChangeToken(parseInt(newValue), parseInt(oldValue)));
                case "DATABASE":
                  return callback(new _token.DatabaseEnvChangeToken(newValue, oldValue));
                case "LANGUAGE":
                  return callback(new _token.LanguageEnvChangeToken(newValue, oldValue));
                case "CHARSET":
                  return callback(new _token.CharsetEnvChangeToken(newValue, oldValue));
                case "DATABASE_MIRRORING_PARTNER":
                  return callback(new _token.DatabaseMirroringPartnerEnvChangeToken(newValue, oldValue));
              }
            });
          });
        case "SQL_COLLATION":
        case "BEGIN_TXN":
        case "COMMIT_TXN":
        case "ROLLBACK_TXN":
        case "RESET_CONNECTION":
          return parser.readBVarByte((newValue) => {
            parser.readBVarByte((oldValue) => {
              switch (type2.name) {
                case "SQL_COLLATION": {
                  const newCollation = newValue.length ? _collation.Collation.fromBuffer(newValue) : void 0;
                  const oldCollation = oldValue.length ? _collation.Collation.fromBuffer(oldValue) : void 0;
                  return callback(new _token.CollationChangeToken(newCollation, oldCollation));
                }
                case "BEGIN_TXN":
                  return callback(new _token.BeginTransactionEnvChangeToken(newValue, oldValue));
                case "COMMIT_TXN":
                  return callback(new _token.CommitTransactionEnvChangeToken(newValue, oldValue));
                case "ROLLBACK_TXN":
                  return callback(new _token.RollbackTransactionEnvChangeToken(newValue, oldValue));
                case "RESET_CONNECTION":
                  return callback(new _token.ResetConnectionEnvChangeToken(newValue, oldValue));
              }
            });
          });
        case "ROUTING_CHANGE":
          return parser.readUInt16LE((valueLength) => {
            parser.readBuffer(valueLength, (routePacket) => {
              const protocol = routePacket.readUInt8(0);
              if (protocol !== 0) {
                throw new Error("Unknown protocol byte in routing change event");
              }
              const port = routePacket.readUInt16LE(1);
              const serverLen = routePacket.readUInt16LE(3);
              const server = routePacket.toString("ucs2", 5, 5 + serverLen * 2);
              const newValue = {
                protocol,
                port,
                server
              };
              parser.readUInt16LE((oldValueLength) => {
                parser.readBuffer(oldValueLength, (oldValue) => {
                  callback(new _token.RoutingEnvChangeToken(newValue, oldValue));
                });
              });
            });
          });
        default:
          console.error("Tedious > Unsupported ENVCHANGE type " + type2.name);
          parser.readBuffer(length - 1, () => {
            callback(void 0);
          });
      }
    }
    function envChangeParser(parser, _options, callback) {
      parser.readUInt16LE((length) => {
        parser.readUInt8((typeNumber) => {
          const type2 = types[typeNumber];
          if (!type2) {
            console.error("Tedious > Unsupported ENVCHANGE type " + typeNumber);
            return parser.readBuffer(length - 1, () => {
              callback(void 0);
            });
          }
          readNewAndOldValue(parser, length, type2, (token) => {
            callback(token);
          });
        });
      });
    }
    var _default = envChangeParser;
    exports.default = _default;
    module2.exports = envChangeParser;
  }
});
var require_infoerror_token_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/infoerror-token-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.errorParser = errorParser;
    exports.infoParser = infoParser;
    var _token = require_token();
    function parseToken(parser, options, callback) {
      parser.readUInt16LE(() => {
        parser.readUInt32LE((number) => {
          parser.readUInt8((state) => {
            parser.readUInt8((clazz) => {
              parser.readUsVarChar((message) => {
                parser.readBVarChar((serverName) => {
                  parser.readBVarChar((procName) => {
                    (options.tdsVersion < "7_2" ? parser.readUInt16LE : parser.readUInt32LE).call(parser, (lineNumber) => {
                      callback({
                        "number": number,
                        "state": state,
                        "class": clazz,
                        "message": message,
                        "serverName": serverName,
                        "procName": procName,
                        "lineNumber": lineNumber
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    }
    function infoParser(parser, options, callback) {
      parseToken(parser, options, (data) => {
        callback(new _token.InfoMessageToken(data));
      });
    }
    function errorParser(parser, options, callback) {
      parseToken(parser, options, (data) => {
        callback(new _token.ErrorMessageToken(data));
      });
    }
  }
});
var require_fedauth_info_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/fedauth-info-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var FEDAUTHINFOID = {
      STSURL: 1,
      SPN: 2
    };
    function fedAuthInfoParser(parser, _options, callback) {
      parser.readUInt32LE((tokenLength) => {
        parser.readBuffer(tokenLength, (data) => {
          let spn, stsurl;
          let offset = 0;
          const countOfInfoIDs = data.readUInt32LE(offset);
          offset += 4;
          for (let i = 0; i < countOfInfoIDs; i++) {
            const fedauthInfoID = data.readUInt8(offset);
            offset += 1;
            const fedAuthInfoDataLen = data.readUInt32LE(offset);
            offset += 4;
            const fedAuthInfoDataOffset = data.readUInt32LE(offset);
            offset += 4;
            switch (fedauthInfoID) {
              case FEDAUTHINFOID.SPN:
                spn = data.toString("ucs2", fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
                break;
              case FEDAUTHINFOID.STSURL:
                stsurl = data.toString("ucs2", fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
                break;
              default:
                break;
            }
          }
          callback(new _token.FedAuthInfoToken(spn, stsurl));
        });
      });
    }
    var _default = fedAuthInfoParser;
    exports.default = _default;
    module2.exports = fedAuthInfoParser;
  }
});
var require_feature_ext_ack_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/feature-ext-ack-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var FEATURE_ID = {
      SESSIONRECOVERY: 1,
      FEDAUTH: 2,
      COLUMNENCRYPTION: 4,
      GLOBALTRANSACTIONS: 5,
      AZURESQLSUPPORT: 8,
      UTF8_SUPPORT: 10,
      TERMINATOR: 255
    };
    function featureExtAckParser(parser, _options, callback) {
      let fedAuth;
      let utf8Support;
      function next() {
        parser.readUInt8((featureId) => {
          if (featureId === FEATURE_ID.TERMINATOR) {
            return callback(new _token.FeatureExtAckToken(fedAuth, utf8Support));
          }
          parser.readUInt32LE((featureAckDataLen) => {
            parser.readBuffer(featureAckDataLen, (featureData) => {
              switch (featureId) {
                case FEATURE_ID.FEDAUTH:
                  fedAuth = featureData;
                  break;
                case FEATURE_ID.UTF8_SUPPORT:
                  utf8Support = !!featureData[0];
                  break;
              }
              next();
            });
          });
        });
      }
      next();
    }
    var _default = featureExtAckParser;
    exports.default = _default;
    module2.exports = featureExtAckParser;
  }
});
var require_loginack_token_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/loginack-token-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _tdsVersions = require_tds_versions();
    var interfaceTypes = {
      0: "SQL_DFLT",
      1: "SQL_TSQL"
    };
    function loginAckParser(parser, _options, callback) {
      parser.readUInt16LE(() => {
        parser.readUInt8((interfaceNumber) => {
          const interfaceType = interfaceTypes[interfaceNumber];
          parser.readUInt32BE((tdsVersionNumber) => {
            const tdsVersion = _tdsVersions.versionsByValue[tdsVersionNumber];
            parser.readBVarChar((progName) => {
              parser.readUInt8((major) => {
                parser.readUInt8((minor) => {
                  parser.readUInt8((buildNumHi) => {
                    parser.readUInt8((buildNumLow) => {
                      callback(new _token.LoginAckToken({
                        interface: interfaceType,
                        tdsVersion,
                        progName,
                        progVersion: {
                          major,
                          minor,
                          buildNumHi,
                          buildNumLow
                        }
                      }));
                    });
                  });
                });
              });
            });
          });
        });
      });
    }
    var _default = loginAckParser;
    exports.default = _default;
    module2.exports = loginAckParser;
  }
});
var require_order_token_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/order-token-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    function orderParser(parser, _options, callback) {
      parser.readUInt16LE((length) => {
        const columnCount = length / 2;
        const orderColumns = [];
        let i = 0;
        function next(done) {
          if (i === columnCount) {
            return done();
          }
          parser.readUInt16LE((column) => {
            orderColumns.push(column);
            i++;
            next(done);
          });
        }
        next(() => {
          callback(new _token.OrderToken(orderColumns));
        });
      });
    }
    var _default = orderParser;
    exports.default = _default;
    module2.exports = orderParser;
  }
});
var require_returnstatus_token_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/returnstatus-token-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    function returnStatusParser(parser, _options, callback) {
      parser.readInt32LE((value) => {
        callback(new _token.ReturnStatusToken(value));
      });
    }
    var _default = returnStatusParser;
    exports.default = _default;
    module2.exports = returnStatusParser;
  }
});
var require_value_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/value-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _metadataParser = require_metadata_parser();
    var _dataType = require_data_type();
    var _iconvLite = _interopRequireDefault((0, import_chunk_NTREA7ZR.require_lib)());
    var _sprintfJs = require_sprintf();
    var _guidParser = require_guid_parser();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL = (1 << 16) - 1;
    var MAX = (1 << 16) - 1;
    var THREE_AND_A_THIRD = 3 + 1 / 3;
    var MONEY_DIVISOR = 1e4;
    var PLP_NULL = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var DEFAULT_ENCODING = "utf8";
    function readTinyInt(parser, callback) {
      parser.readUInt8(callback);
    }
    function readSmallInt(parser, callback) {
      parser.readInt16LE(callback);
    }
    function readInt(parser, callback) {
      parser.readInt32LE(callback);
    }
    function readBigInt(parser, callback) {
      parser.readBigInt64LE((value) => {
        callback(value.toString());
      });
    }
    function readReal(parser, callback) {
      parser.readFloatLE(callback);
    }
    function readFloat(parser, callback) {
      parser.readDoubleLE(callback);
    }
    function readSmallMoney(parser, callback) {
      parser.readInt32LE((value) => {
        callback(value / MONEY_DIVISOR);
      });
    }
    function readMoney(parser, callback) {
      parser.readInt32LE((high) => {
        parser.readUInt32LE((low) => {
          callback((low + 4294967296 * high) / MONEY_DIVISOR);
        });
      });
    }
    function readBit(parser, callback) {
      parser.readUInt8((value) => {
        callback(!!value);
      });
    }
    function valueParse(parser, metadata, options, callback) {
      const type2 = metadata.type;
      switch (type2.name) {
        case "Null":
          return callback(null);
        case "TinyInt":
          return readTinyInt(parser, callback);
        case "SmallInt":
          return readSmallInt(parser, callback);
        case "Int":
          return readInt(parser, callback);
        case "BigInt":
          return readBigInt(parser, callback);
        case "IntN":
          return parser.readUInt8((dataLength) => {
            switch (dataLength) {
              case 0:
                return callback(null);
              case 1:
                return readTinyInt(parser, callback);
              case 2:
                return readSmallInt(parser, callback);
              case 4:
                return readInt(parser, callback);
              case 8:
                return readBigInt(parser, callback);
              default:
                throw new Error("Unsupported dataLength " + dataLength + " for IntN");
            }
          });
        case "Real":
          return readReal(parser, callback);
        case "Float":
          return readFloat(parser, callback);
        case "FloatN":
          return parser.readUInt8((dataLength) => {
            switch (dataLength) {
              case 0:
                return callback(null);
              case 4:
                return readReal(parser, callback);
              case 8:
                return readFloat(parser, callback);
              default:
                throw new Error("Unsupported dataLength " + dataLength + " for FloatN");
            }
          });
        case "SmallMoney":
          return readSmallMoney(parser, callback);
        case "Money":
          return readMoney(parser, callback);
        case "MoneyN":
          return parser.readUInt8((dataLength) => {
            switch (dataLength) {
              case 0:
                return callback(null);
              case 4:
                return readSmallMoney(parser, callback);
              case 8:
                return readMoney(parser, callback);
              default:
                throw new Error("Unsupported dataLength " + dataLength + " for MoneyN");
            }
          });
        case "Bit":
          return readBit(parser, callback);
        case "BitN":
          return parser.readUInt8((dataLength) => {
            switch (dataLength) {
              case 0:
                return callback(null);
              case 1:
                return readBit(parser, callback);
              default:
                throw new Error("Unsupported dataLength " + dataLength + " for BitN");
            }
          });
        case "VarChar":
        case "Char":
          const codepage = metadata.collation.codepage;
          if (metadata.dataLength === MAX) {
            return readMaxChars(parser, codepage, callback);
          } else {
            return parser.readUInt16LE((dataLength) => {
              if (dataLength === NULL) {
                return callback(null);
              }
              readChars(parser, dataLength, codepage, callback);
            });
          }
        case "NVarChar":
        case "NChar":
          if (metadata.dataLength === MAX) {
            return readMaxNChars(parser, callback);
          } else {
            return parser.readUInt16LE((dataLength) => {
              if (dataLength === NULL) {
                return callback(null);
              }
              readNChars(parser, dataLength, callback);
            });
          }
        case "VarBinary":
        case "Binary":
          if (metadata.dataLength === MAX) {
            return readMaxBinary(parser, callback);
          } else {
            return parser.readUInt16LE((dataLength) => {
              if (dataLength === NULL) {
                return callback(null);
              }
              readBinary(parser, dataLength, callback);
            });
          }
        case "Text":
          return parser.readUInt8((textPointerLength) => {
            if (textPointerLength === 0) {
              return callback(null);
            }
            parser.readBuffer(textPointerLength, (_textPointer) => {
              parser.readBuffer(8, (_timestamp) => {
                parser.readUInt32LE((dataLength) => {
                  readChars(parser, dataLength, metadata.collation.codepage, callback);
                });
              });
            });
          });
        case "NText":
          return parser.readUInt8((textPointerLength) => {
            if (textPointerLength === 0) {
              return callback(null);
            }
            parser.readBuffer(textPointerLength, (_textPointer) => {
              parser.readBuffer(8, (_timestamp) => {
                parser.readUInt32LE((dataLength) => {
                  readNChars(parser, dataLength, callback);
                });
              });
            });
          });
        case "Image":
          return parser.readUInt8((textPointerLength) => {
            if (textPointerLength === 0) {
              return callback(null);
            }
            parser.readBuffer(textPointerLength, (_textPointer) => {
              parser.readBuffer(8, (_timestamp) => {
                parser.readUInt32LE((dataLength) => {
                  readBinary(parser, dataLength, callback);
                });
              });
            });
          });
        case "Xml":
          return readMaxNChars(parser, callback);
        case "SmallDateTime":
          return readSmallDateTime(parser, options.useUTC, callback);
        case "DateTime":
          return readDateTime(parser, options.useUTC, callback);
        case "DateTimeN":
          return parser.readUInt8((dataLength) => {
            switch (dataLength) {
              case 0:
                return callback(null);
              case 4:
                return readSmallDateTime(parser, options.useUTC, callback);
              case 8:
                return readDateTime(parser, options.useUTC, callback);
              default:
                throw new Error("Unsupported dataLength " + dataLength + " for DateTimeN");
            }
          });
        case "Time":
          return parser.readUInt8((dataLength) => {
            if (dataLength === 0) {
              return callback(null);
            } else {
              return readTime(parser, dataLength, metadata.scale, options.useUTC, callback);
            }
          });
        case "Date":
          return parser.readUInt8((dataLength) => {
            if (dataLength === 0) {
              return callback(null);
            } else {
              return readDate(parser, options.useUTC, callback);
            }
          });
        case "DateTime2":
          return parser.readUInt8((dataLength) => {
            if (dataLength === 0) {
              return callback(null);
            } else {
              return readDateTime2(parser, dataLength, metadata.scale, options.useUTC, callback);
            }
          });
        case "DateTimeOffset":
          return parser.readUInt8((dataLength) => {
            if (dataLength === 0) {
              return callback(null);
            } else {
              return readDateTimeOffset(parser, dataLength, metadata.scale, callback);
            }
          });
        case "NumericN":
        case "DecimalN":
          return parser.readUInt8((dataLength) => {
            if (dataLength === 0) {
              return callback(null);
            } else {
              return readNumeric(parser, dataLength, metadata.precision, metadata.scale, callback);
            }
          });
        case "UniqueIdentifier":
          return parser.readUInt8((dataLength) => {
            switch (dataLength) {
              case 0:
                return callback(null);
              case 16:
                return readUniqueIdentifier(parser, options, callback);
              default:
                throw new Error((0, _sprintfJs.sprintf)("Unsupported guid size %d", dataLength - 1));
            }
          });
        case "UDT":
          return readMaxBinary(parser, callback);
        case "Variant":
          return parser.readUInt32LE((dataLength) => {
            if (dataLength === 0) {
              return callback(null);
            }
            readVariant(parser, options, dataLength, callback);
          });
        default:
          throw new Error((0, _sprintfJs.sprintf)("Unrecognised type %s", type2.name));
      }
    }
    function readUniqueIdentifier(parser, options, callback) {
      parser.readBuffer(16, (data) => {
        callback(options.lowerCaseGuids ? (0, _guidParser.bufferToLowerCaseGuid)(data) : (0, _guidParser.bufferToUpperCaseGuid)(data));
      });
    }
    function readNumeric(parser, dataLength, _precision, scale, callback) {
      parser.readUInt8((sign2) => {
        sign2 = sign2 === 1 ? 1 : -1;
        let readValue;
        if (dataLength === 5) {
          readValue = parser.readUInt32LE;
        } else if (dataLength === 9) {
          readValue = parser.readUNumeric64LE;
        } else if (dataLength === 13) {
          readValue = parser.readUNumeric96LE;
        } else if (dataLength === 17) {
          readValue = parser.readUNumeric128LE;
        } else {
          throw new Error((0, _sprintfJs.sprintf)("Unsupported numeric dataLength %d", dataLength));
        }
        readValue.call(parser, (value) => {
          callback(value * sign2 / Math.pow(10, scale));
        });
      });
    }
    function readVariant(parser, options, dataLength, callback) {
      return parser.readUInt8((baseType) => {
        const type2 = _dataType.TYPE[baseType];
        return parser.readUInt8((propBytes) => {
          dataLength = dataLength - propBytes - 2;
          switch (type2.name) {
            case "UniqueIdentifier":
              return readUniqueIdentifier(parser, options, callback);
            case "Bit":
              return readBit(parser, callback);
            case "TinyInt":
              return readTinyInt(parser, callback);
            case "SmallInt":
              return readSmallInt(parser, callback);
            case "Int":
              return readInt(parser, callback);
            case "BigInt":
              return readBigInt(parser, callback);
            case "SmallDateTime":
              return readSmallDateTime(parser, options.useUTC, callback);
            case "DateTime":
              return readDateTime(parser, options.useUTC, callback);
            case "Real":
              return readReal(parser, callback);
            case "Float":
              return readFloat(parser, callback);
            case "SmallMoney":
              return readSmallMoney(parser, callback);
            case "Money":
              return readMoney(parser, callback);
            case "Date":
              return readDate(parser, options.useUTC, callback);
            case "Time":
              return parser.readUInt8((scale) => {
                return readTime(parser, dataLength, scale, options.useUTC, callback);
              });
            case "DateTime2":
              return parser.readUInt8((scale) => {
                return readDateTime2(parser, dataLength, scale, options.useUTC, callback);
              });
            case "DateTimeOffset":
              return parser.readUInt8((scale) => {
                return readDateTimeOffset(parser, dataLength, scale, callback);
              });
            case "VarBinary":
            case "Binary":
              return parser.readUInt16LE((_maxLength) => {
                readBinary(parser, dataLength, callback);
              });
            case "NumericN":
            case "DecimalN":
              return parser.readUInt8((precision) => {
                parser.readUInt8((scale) => {
                  readNumeric(parser, dataLength, precision, scale, callback);
                });
              });
            case "VarChar":
            case "Char":
              return parser.readUInt16LE((_maxLength) => {
                (0, _metadataParser.readCollation)(parser, (collation) => {
                  readChars(parser, dataLength, collation.codepage, callback);
                });
              });
            case "NVarChar":
            case "NChar":
              return parser.readUInt16LE((_maxLength) => {
                (0, _metadataParser.readCollation)(parser, (_collation) => {
                  readNChars(parser, dataLength, callback);
                });
              });
            default:
              throw new Error("Invalid type!");
          }
        });
      });
    }
    function readBinary(parser, dataLength, callback) {
      return parser.readBuffer(dataLength, callback);
    }
    function readChars(parser, dataLength, codepage, callback) {
      if (codepage == null) {
        codepage = DEFAULT_ENCODING;
      }
      return parser.readBuffer(dataLength, (data) => {
        callback(_iconvLite.default.decode(data, codepage));
      });
    }
    function readNChars(parser, dataLength, callback) {
      parser.readBuffer(dataLength, (data) => {
        callback(data.toString("ucs2"));
      });
    }
    function readMaxBinary(parser, callback) {
      return readMax(parser, callback);
    }
    function readMaxChars(parser, codepage, callback) {
      if (codepage == null) {
        codepage = DEFAULT_ENCODING;
      }
      readMax(parser, (data) => {
        if (data) {
          callback(_iconvLite.default.decode(data, codepage));
        } else {
          callback(null);
        }
      });
    }
    function readMaxNChars(parser, callback) {
      readMax(parser, (data) => {
        if (data) {
          callback(data.toString("ucs2"));
        } else {
          callback(null);
        }
      });
    }
    function readMax(parser, callback) {
      parser.readBuffer(8, (type2) => {
        if (type2.equals(PLP_NULL)) {
          return callback(null);
        } else if (type2.equals(UNKNOWN_PLP_LEN)) {
          return readMaxUnknownLength(parser, callback);
        } else {
          const low = type2.readUInt32LE(0);
          const high = type2.readUInt32LE(4);
          if (high >= 2 << 53 - 32) {
            console.warn("Read UInt64LE > 53 bits : high=" + high + ", low=" + low);
          }
          const expectedLength = low + 4294967296 * high;
          return readMaxKnownLength(parser, expectedLength, callback);
        }
      });
    }
    function readMaxKnownLength(parser, totalLength, callback) {
      const data = Buffer.alloc(totalLength, 0);
      let offset = 0;
      function next(done) {
        parser.readUInt32LE((chunkLength) => {
          if (!chunkLength) {
            return done();
          }
          parser.readBuffer(chunkLength, (chunk) => {
            chunk.copy(data, offset);
            offset += chunkLength;
            next(done);
          });
        });
      }
      next(() => {
        if (offset !== totalLength) {
          throw new Error("Partially Length-prefixed Bytes unmatched lengths : expected " + totalLength + ", but got " + offset + " bytes");
        }
        callback(data);
      });
    }
    function readMaxUnknownLength(parser, callback) {
      const chunks = [];
      let length = 0;
      function next(done) {
        parser.readUInt32LE((chunkLength) => {
          if (!chunkLength) {
            return done();
          }
          parser.readBuffer(chunkLength, (chunk) => {
            chunks.push(chunk);
            length += chunkLength;
            next(done);
          });
        });
      }
      next(() => {
        callback(Buffer.concat(chunks, length));
      });
    }
    function readSmallDateTime(parser, useUTC, callback) {
      parser.readUInt16LE((days) => {
        parser.readUInt16LE((minutes) => {
          let value;
          if (useUTC) {
            value = new Date(Date.UTC(1900, 0, 1 + days, 0, minutes));
          } else {
            value = new Date(1900, 0, 1 + days, 0, minutes);
          }
          callback(value);
        });
      });
    }
    function readDateTime(parser, useUTC, callback) {
      parser.readInt32LE((days) => {
        parser.readUInt32LE((threeHundredthsOfSecond) => {
          const milliseconds = Math.round(threeHundredthsOfSecond * THREE_AND_A_THIRD);
          let value;
          if (useUTC) {
            value = new Date(Date.UTC(1900, 0, 1 + days, 0, 0, 0, milliseconds));
          } else {
            value = new Date(1900, 0, 1 + days, 0, 0, 0, milliseconds);
          }
          callback(value);
        });
      });
    }
    function readTime(parser, dataLength, scale, useUTC, callback) {
      let readValue;
      switch (dataLength) {
        case 3:
          readValue = parser.readUInt24LE;
          break;
        case 4:
          readValue = parser.readUInt32LE;
          break;
        case 5:
          readValue = parser.readUInt40LE;
      }
      readValue.call(parser, (value) => {
        if (scale < 7) {
          for (let i = scale; i < 7; i++) {
            value *= 10;
          }
        }
        let date;
        if (useUTC) {
          date = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, value / 1e4));
        } else {
          date = new Date(1970, 0, 1, 0, 0, 0, value / 1e4);
        }
        Object.defineProperty(date, "nanosecondsDelta", {
          enumerable: false,
          value: value % 1e4 / Math.pow(10, 7)
        });
        callback(date);
      });
    }
    function readDate(parser, useUTC, callback) {
      parser.readUInt24LE((days) => {
        if (useUTC) {
          callback(new Date(Date.UTC(2e3, 0, days - 730118)));
        } else {
          callback(new Date(2e3, 0, days - 730118));
        }
      });
    }
    function readDateTime2(parser, dataLength, scale, useUTC, callback) {
      readTime(parser, dataLength - 3, scale, useUTC, (time) => {
        parser.readUInt24LE((days) => {
          let date;
          if (useUTC) {
            date = new Date(Date.UTC(2e3, 0, days - 730118, 0, 0, 0, +time));
          } else {
            date = new Date(2e3, 0, days - 730118, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
          }
          Object.defineProperty(date, "nanosecondsDelta", {
            enumerable: false,
            value: time.nanosecondsDelta
          });
          callback(date);
        });
      });
    }
    function readDateTimeOffset(parser, dataLength, scale, callback) {
      readTime(parser, dataLength - 5, scale, true, (time) => {
        parser.readUInt24LE((days) => {
          parser.readInt16LE(() => {
            const date = new Date(Date.UTC(2e3, 0, days - 730118, 0, 0, 0, +time));
            Object.defineProperty(date, "nanosecondsDelta", {
              enumerable: false,
              value: time.nanosecondsDelta
            });
            callback(date);
          });
        });
      });
    }
    var _default = valueParse;
    exports.default = _default;
    module2.exports = valueParse;
  }
});
var require_returnvalue_token_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/returnvalue-token-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _metadataParser = _interopRequireDefault(require_metadata_parser());
    var _valueParser = _interopRequireDefault(require_value_parser());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function returnParser(parser, options, callback) {
      parser.readUInt16LE((paramOrdinal) => {
        parser.readBVarChar((paramName) => {
          if (paramName.charAt(0) === "@") {
            paramName = paramName.slice(1);
          }
          parser.readUInt8(() => {
            (0, _metadataParser.default)(parser, options, (metadata) => {
              (0, _valueParser.default)(parser, metadata, options, (value) => {
                callback(new _token.ReturnValueToken({
                  paramOrdinal,
                  paramName,
                  metadata,
                  value
                }));
              });
            });
          });
        });
      });
    }
    var _default = returnParser;
    exports.default = _default;
    module2.exports = returnParser;
  }
});
var require_row_token_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/row-token-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _valueParser = _interopRequireDefault(require_value_parser());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function rowParser(parser) {
      const colMetadata = parser.colMetadata;
      const length = colMetadata.length;
      const columns = [];
      for (let i = 0; i < length; i++) {
        const currColMetadata = colMetadata[i];
        let value;
        (0, _valueParser.default)(parser, currColMetadata, parser.options, (v) => {
          value = v;
        });
        while (parser.suspended) {
          await parser.streamBuffer.waitForChunk();
          parser.suspended = false;
          const next = parser.next;
          next();
        }
        columns.push({
          value,
          metadata: currColMetadata
        });
      }
      if (parser.options.useColumnNames) {
        const columnsMap = /* @__PURE__ */ Object.create(null);
        columns.forEach((column) => {
          const colName = column.metadata.colName;
          if (columnsMap[colName] == null) {
            columnsMap[colName] = column;
          }
        });
        return new _token.RowToken(columnsMap);
      } else {
        return new _token.RowToken(columns);
      }
    }
    var _default = rowParser;
    exports.default = _default;
    module2.exports = rowParser;
  }
});
var require_nbcrow_token_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/nbcrow-token-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _valueParser = _interopRequireDefault(require_value_parser());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function nullHandler(_parser, _columnMetadata, _options, callback) {
      callback(null);
    }
    async function nbcRowParser(parser) {
      const colMetadata = parser.colMetadata;
      const bitmapByteLength = Math.ceil(colMetadata.length / 8);
      const columns = [];
      const bitmap = [];
      while (parser.buffer.length - parser.position < bitmapByteLength) {
        await parser.streamBuffer.waitForChunk();
      }
      const bytes = parser.buffer.slice(parser.position, parser.position + bitmapByteLength);
      parser.position += bitmapByteLength;
      for (let i = 0, len = bytes.length; i < len; i++) {
        const byte = bytes[i];
        bitmap.push(byte & 1 ? true : false);
        bitmap.push(byte & 2 ? true : false);
        bitmap.push(byte & 4 ? true : false);
        bitmap.push(byte & 8 ? true : false);
        bitmap.push(byte & 16 ? true : false);
        bitmap.push(byte & 32 ? true : false);
        bitmap.push(byte & 64 ? true : false);
        bitmap.push(byte & 128 ? true : false);
      }
      for (let i = 0; i < colMetadata.length; i++) {
        const currColMetadata = colMetadata[i];
        let value;
        (bitmap[i] ? nullHandler : _valueParser.default)(parser, currColMetadata, parser.options, (v) => {
          value = v;
        });
        while (parser.suspended) {
          await parser.streamBuffer.waitForChunk();
          parser.suspended = false;
          const next = parser.next;
          next();
        }
        columns.push({
          value,
          metadata: currColMetadata
        });
      }
      if (parser.options.useColumnNames) {
        const columnsMap = {};
        columns.forEach((column) => {
          const colName = column.metadata.colName;
          if (columnsMap[colName] == null) {
            columnsMap[colName] = column;
          }
        });
        return new _token.NBCRowToken(columnsMap);
      } else {
        return new _token.NBCRowToken(columns);
      }
    }
    var _default = nbcRowParser;
    exports.default = _default;
    module2.exports = nbcRowParser;
  }
});
var require_sspi_token_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/sspi-token-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    function parseChallenge(buffer) {
      const challenge = {};
      challenge.magic = buffer.slice(0, 8).toString("utf8");
      challenge.type = buffer.readInt32LE(8);
      challenge.domainLen = buffer.readInt16LE(12);
      challenge.domainMax = buffer.readInt16LE(14);
      challenge.domainOffset = buffer.readInt32LE(16);
      challenge.flags = buffer.readInt32LE(20);
      challenge.nonce = buffer.slice(24, 32);
      challenge.zeroes = buffer.slice(32, 40);
      challenge.targetLen = buffer.readInt16LE(40);
      challenge.targetMax = buffer.readInt16LE(42);
      challenge.targetOffset = buffer.readInt32LE(44);
      challenge.oddData = buffer.slice(48, 56);
      challenge.domain = buffer.slice(56, 56 + challenge.domainLen).toString("ucs2");
      challenge.target = buffer.slice(56 + challenge.domainLen, 56 + challenge.domainLen + challenge.targetLen);
      return challenge;
    }
    function sspiParser(parser, _options, callback) {
      parser.readUsVarByte((buffer) => {
        callback(new _token.SSPIToken(parseChallenge(buffer), buffer));
      });
    }
    var _default = sspiParser;
    exports.default = _default;
    module2.exports = sspiParser;
  }
});
var require_stream_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/stream-parser.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _colmetadataTokenParser = _interopRequireDefault(require_colmetadata_token_parser());
    var _doneTokenParser = require_done_token_parser();
    var _envChangeTokenParser = _interopRequireDefault(require_env_change_token_parser());
    var _infoerrorTokenParser = require_infoerror_token_parser();
    var _fedauthInfoParser = _interopRequireDefault(require_fedauth_info_parser());
    var _featureExtAckParser = _interopRequireDefault(require_feature_ext_ack_parser());
    var _loginackTokenParser = _interopRequireDefault(require_loginack_token_parser());
    var _orderTokenParser = _interopRequireDefault(require_order_token_parser());
    var _returnstatusTokenParser = _interopRequireDefault(require_returnstatus_token_parser());
    var _returnvalueTokenParser = _interopRequireDefault(require_returnvalue_token_parser());
    var _rowTokenParser = _interopRequireDefault(require_row_token_parser());
    var _nbcrowTokenParser = _interopRequireDefault(require_nbcrow_token_parser());
    var _sspiTokenParser = _interopRequireDefault(require_sspi_token_parser());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var tokenParsers = {
      [_token.TYPE.DONE]: _doneTokenParser.doneParser,
      [_token.TYPE.DONEINPROC]: _doneTokenParser.doneInProcParser,
      [_token.TYPE.DONEPROC]: _doneTokenParser.doneProcParser,
      [_token.TYPE.ENVCHANGE]: _envChangeTokenParser.default,
      [_token.TYPE.ERROR]: _infoerrorTokenParser.errorParser,
      [_token.TYPE.FEDAUTHINFO]: _fedauthInfoParser.default,
      [_token.TYPE.FEATUREEXTACK]: _featureExtAckParser.default,
      [_token.TYPE.INFO]: _infoerrorTokenParser.infoParser,
      [_token.TYPE.LOGINACK]: _loginackTokenParser.default,
      [_token.TYPE.ORDER]: _orderTokenParser.default,
      [_token.TYPE.RETURNSTATUS]: _returnstatusTokenParser.default,
      [_token.TYPE.RETURNVALUE]: _returnvalueTokenParser.default,
      [_token.TYPE.SSPI]: _sspiTokenParser.default
    };
    var StreamBuffer = class {
      constructor(iterable) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "iterator");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "buffer");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "position");
        this.iterator = (iterable[Symbol.asyncIterator] || iterable[Symbol.iterator]).call(iterable);
        this.buffer = Buffer.alloc(0);
        this.position = 0;
      }
      async waitForChunk() {
        const result = await this.iterator.next();
        if (result.done) {
          throw new Error("unexpected end of data");
        }
        if (this.position === this.buffer.length) {
          this.buffer = result.value;
        } else {
          this.buffer = Buffer.concat([this.buffer.slice(this.position), result.value]);
        }
        this.position = 0;
      }
    };
    var Parser = class _Parser {
      constructor(streamBuffer, debug, options) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "debug");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "colMetadata");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "options");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "suspended");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "next");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "streamBuffer");
        this.debug = debug;
        this.colMetadata = [];
        this.options = options;
        this.streamBuffer = streamBuffer;
        this.suspended = false;
        this.next = void 0;
      }
      static async *parseTokens(iterable, debug, options, colMetadata = []) {
        let token;
        const onDoneParsing = (t) => {
          token = t;
        };
        const streamBuffer = new StreamBuffer(iterable);
        const parser = new _Parser(streamBuffer, debug, options);
        parser.colMetadata = colMetadata;
        while (true) {
          try {
            await streamBuffer.waitForChunk();
          } catch (err) {
            if (streamBuffer.position === streamBuffer.buffer.length) {
              return;
            }
            throw err;
          }
          if (parser.suspended) {
            parser.suspended = false;
            const next = parser.next;
            next();
            if (!parser.suspended && token) {
              if (token instanceof _token.ColMetadataToken) {
                parser.colMetadata = token.columns;
              }
              yield token;
            }
          }
          while (!parser.suspended && parser.position + 1 <= parser.buffer.length) {
            const type2 = parser.buffer.readUInt8(parser.position);
            parser.position += 1;
            if (type2 === _token.TYPE.COLMETADATA) {
              const token2 = await (0, _colmetadataTokenParser.default)(parser);
              parser.colMetadata = token2.columns;
              yield token2;
            } else if (type2 === _token.TYPE.ROW) {
              yield (0, _rowTokenParser.default)(parser);
            } else if (type2 === _token.TYPE.NBCROW) {
              yield (0, _nbcrowTokenParser.default)(parser);
            } else if (tokenParsers[type2]) {
              tokenParsers[type2](parser, parser.options, onDoneParsing);
              if (!parser.suspended && token) {
                if (token instanceof _token.ColMetadataToken) {
                  parser.colMetadata = token.columns;
                }
                yield token;
              }
            } else {
              throw new Error("Unknown type: " + type2);
            }
          }
        }
      }
      get buffer() {
        return this.streamBuffer.buffer;
      }
      get position() {
        return this.streamBuffer.position;
      }
      set position(value) {
        this.streamBuffer.position = value;
      }
      suspend(next) {
        this.suspended = true;
        this.next = next;
      }
      awaitData(length, callback) {
        if (this.position + length <= this.buffer.length) {
          callback();
        } else {
          this.suspend(() => {
            this.awaitData(length, callback);
          });
        }
      }
      readInt8(callback) {
        this.awaitData(1, () => {
          const data = this.buffer.readInt8(this.position);
          this.position += 1;
          callback(data);
        });
      }
      readUInt8(callback) {
        this.awaitData(1, () => {
          const data = this.buffer.readUInt8(this.position);
          this.position += 1;
          callback(data);
        });
      }
      readInt16LE(callback) {
        this.awaitData(2, () => {
          const data = this.buffer.readInt16LE(this.position);
          this.position += 2;
          callback(data);
        });
      }
      readInt16BE(callback) {
        this.awaitData(2, () => {
          const data = this.buffer.readInt16BE(this.position);
          this.position += 2;
          callback(data);
        });
      }
      readUInt16LE(callback) {
        this.awaitData(2, () => {
          const data = this.buffer.readUInt16LE(this.position);
          this.position += 2;
          callback(data);
        });
      }
      readUInt16BE(callback) {
        this.awaitData(2, () => {
          const data = this.buffer.readUInt16BE(this.position);
          this.position += 2;
          callback(data);
        });
      }
      readInt32LE(callback) {
        this.awaitData(4, () => {
          const data = this.buffer.readInt32LE(this.position);
          this.position += 4;
          callback(data);
        });
      }
      readInt32BE(callback) {
        this.awaitData(4, () => {
          const data = this.buffer.readInt32BE(this.position);
          this.position += 4;
          callback(data);
        });
      }
      readUInt32LE(callback) {
        this.awaitData(4, () => {
          const data = this.buffer.readUInt32LE(this.position);
          this.position += 4;
          callback(data);
        });
      }
      readUInt32BE(callback) {
        this.awaitData(4, () => {
          const data = this.buffer.readUInt32BE(this.position);
          this.position += 4;
          callback(data);
        });
      }
      readBigInt64LE(callback) {
        this.awaitData(8, () => {
          const data = this.buffer.readBigInt64LE(this.position);
          this.position += 8;
          callback(data);
        });
      }
      readInt64LE(callback) {
        this.awaitData(8, () => {
          const data = Math.pow(2, 32) * this.buffer.readInt32LE(this.position + 4) + ((this.buffer[this.position + 4] & 128) === 128 ? 1 : -1) * this.buffer.readUInt32LE(this.position);
          this.position += 8;
          callback(data);
        });
      }
      readInt64BE(callback) {
        this.awaitData(8, () => {
          const data = Math.pow(2, 32) * this.buffer.readInt32BE(this.position) + ((this.buffer[this.position] & 128) === 128 ? 1 : -1) * this.buffer.readUInt32BE(this.position + 4);
          this.position += 8;
          callback(data);
        });
      }
      readBigUInt64LE(callback) {
        this.awaitData(8, () => {
          const data = this.buffer.readBigUInt64LE(this.position);
          this.position += 8;
          callback(data);
        });
      }
      readUInt64LE(callback) {
        this.awaitData(8, () => {
          const data = Math.pow(2, 32) * this.buffer.readUInt32LE(this.position + 4) + this.buffer.readUInt32LE(this.position);
          this.position += 8;
          callback(data);
        });
      }
      readUInt64BE(callback) {
        this.awaitData(8, () => {
          const data = Math.pow(2, 32) * this.buffer.readUInt32BE(this.position) + this.buffer.readUInt32BE(this.position + 4);
          this.position += 8;
          callback(data);
        });
      }
      readFloatLE(callback) {
        this.awaitData(4, () => {
          const data = this.buffer.readFloatLE(this.position);
          this.position += 4;
          callback(data);
        });
      }
      readFloatBE(callback) {
        this.awaitData(4, () => {
          const data = this.buffer.readFloatBE(this.position);
          this.position += 4;
          callback(data);
        });
      }
      readDoubleLE(callback) {
        this.awaitData(8, () => {
          const data = this.buffer.readDoubleLE(this.position);
          this.position += 8;
          callback(data);
        });
      }
      readDoubleBE(callback) {
        this.awaitData(8, () => {
          const data = this.buffer.readDoubleBE(this.position);
          this.position += 8;
          callback(data);
        });
      }
      readUInt24LE(callback) {
        this.awaitData(3, () => {
          const low = this.buffer.readUInt16LE(this.position);
          const high = this.buffer.readUInt8(this.position + 2);
          this.position += 3;
          callback(low | high << 16);
        });
      }
      readUInt40LE(callback) {
        this.awaitData(5, () => {
          const low = this.buffer.readUInt32LE(this.position);
          const high = this.buffer.readUInt8(this.position + 4);
          this.position += 5;
          callback(4294967296 * high + low);
        });
      }
      readUNumeric64LE(callback) {
        this.awaitData(8, () => {
          const low = this.buffer.readUInt32LE(this.position);
          const high = this.buffer.readUInt32LE(this.position + 4);
          this.position += 8;
          callback(4294967296 * high + low);
        });
      }
      readUNumeric96LE(callback) {
        this.awaitData(12, () => {
          const dword1 = this.buffer.readUInt32LE(this.position);
          const dword2 = this.buffer.readUInt32LE(this.position + 4);
          const dword3 = this.buffer.readUInt32LE(this.position + 8);
          this.position += 12;
          callback(dword1 + 4294967296 * dword2 + 4294967296 * 4294967296 * dword3);
        });
      }
      readUNumeric128LE(callback) {
        this.awaitData(16, () => {
          const dword1 = this.buffer.readUInt32LE(this.position);
          const dword2 = this.buffer.readUInt32LE(this.position + 4);
          const dword3 = this.buffer.readUInt32LE(this.position + 8);
          const dword4 = this.buffer.readUInt32LE(this.position + 12);
          this.position += 16;
          callback(dword1 + 4294967296 * dword2 + 4294967296 * 4294967296 * dword3 + 4294967296 * 4294967296 * 4294967296 * dword4);
        });
      }
      // Variable length data
      readBuffer(length, callback) {
        this.awaitData(length, () => {
          const data = this.buffer.slice(this.position, this.position + length);
          this.position += length;
          callback(data);
        });
      }
      // Read a Unicode String (BVARCHAR)
      readBVarChar(callback) {
        this.readUInt8((length) => {
          this.readBuffer(length * 2, (data) => {
            callback(data.toString("ucs2"));
          });
        });
      }
      // Read a Unicode String (USVARCHAR)
      readUsVarChar(callback) {
        this.readUInt16LE((length) => {
          this.readBuffer(length * 2, (data) => {
            callback(data.toString("ucs2"));
          });
        });
      }
      // Read binary data (BVARBYTE)
      readBVarByte(callback) {
        this.readUInt8((length) => {
          this.readBuffer(length, callback);
        });
      }
      // Read binary data (USVARBYTE)
      readUsVarByte(callback) {
        this.readUInt16LE((length) => {
          this.readBuffer(length, callback);
        });
      }
    };
    var _default = Parser;
    exports.default = _default;
    module2.exports = Parser;
  }
});
var require_token_stream_parser = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/token-stream-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Parser = void 0;
    var _events = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var _streamParser = _interopRequireDefault(require_stream_parser());
    var _stream = (0, import_chunk_FVJ3R4NJ.__require)("stream");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Parser = class extends _events.EventEmitter {
      constructor(message, debug, handler, options) {
        super();
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "debug");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "options");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "parser");
        this.debug = debug;
        this.options = options;
        this.parser = _stream.Readable.from(_streamParser.default.parseTokens(message, this.debug, this.options));
        this.parser.on("data", (token) => {
          handler[token.handlerName](token);
        });
        this.parser.on("drain", () => {
          this.emit("drain");
        });
        this.parser.on("end", () => {
          this.emit("end");
        });
      }
      pause() {
        return this.parser.pause();
      }
      resume() {
        return this.parser.resume();
      }
    };
    exports.Parser = Parser;
  }
});
var require_transaction2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Transaction = exports.OPERATION_TYPE = exports.ISOLATION_LEVEL = void 0;
    exports.assertValidIsolationLevel = assertValidIsolationLevel;
    exports.isolationLevelByValue = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var OPERATION_TYPE = {
      TM_GET_DTC_ADDRESS: 0,
      TM_PROPAGATE_XACT: 1,
      TM_BEGIN_XACT: 5,
      TM_PROMOTE_XACT: 6,
      TM_COMMIT_XACT: 7,
      TM_ROLLBACK_XACT: 8,
      TM_SAVE_XACT: 9
    };
    exports.OPERATION_TYPE = OPERATION_TYPE;
    var ISOLATION_LEVEL = {
      NO_CHANGE: 0,
      READ_UNCOMMITTED: 1,
      READ_COMMITTED: 2,
      REPEATABLE_READ: 3,
      SERIALIZABLE: 4,
      SNAPSHOT: 5
    };
    exports.ISOLATION_LEVEL = ISOLATION_LEVEL;
    var isolationLevelByValue = {};
    exports.isolationLevelByValue = isolationLevelByValue;
    for (const name3 in ISOLATION_LEVEL) {
      const value = ISOLATION_LEVEL[name3];
      isolationLevelByValue[value] = name3;
    }
    function assertValidIsolationLevel(isolationLevel, name3) {
      if (typeof isolationLevel !== "number") {
        throw new TypeError(`The "${name3}" ${name3.includes(".") ? "property" : "argument"} must be of type number. Received type ${typeof isolationLevel} (${isolationLevel})`);
      }
      if (!Number.isInteger(isolationLevel)) {
        throw new RangeError(`The value of "${name3}" is out of range. It must be an integer. Received: ${isolationLevel}`);
      }
      if (!(isolationLevel >= 0 && isolationLevel <= 5)) {
        throw new RangeError(`The value of "${name3}" is out of range. It must be >= 0 && <= 5. Received: ${isolationLevel}`);
      }
    }
    var Transaction = class {
      constructor(name3, isolationLevel = ISOLATION_LEVEL.NO_CHANGE) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "name");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "isolationLevel");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "outstandingRequestCount");
        this.name = name3;
        this.isolationLevel = isolationLevel;
        this.outstandingRequestCount = 1;
      }
      beginPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ucs2");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_BEGIN_XACT);
        buffer.writeUInt8(this.isolationLevel);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Begin Transaction: name=" + this.name + ", isolationLevel=" + isolationLevelByValue[this.isolationLevel];
          }
        };
      }
      commitPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_COMMIT_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        buffer.writeUInt8(0);
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Commit Transaction: name=" + this.name;
          }
        };
      }
      rollbackPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_ROLLBACK_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        buffer.writeUInt8(0);
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Rollback Transaction: name=" + this.name;
          }
        };
      }
      savePayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_SAVE_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Save Transaction: name=" + this.name;
          }
        };
      }
      isolationLevelToTSQL() {
        switch (this.isolationLevel) {
          case ISOLATION_LEVEL.READ_UNCOMMITTED:
            return "READ UNCOMMITTED";
          case ISOLATION_LEVEL.READ_COMMITTED:
            return "READ COMMITTED";
          case ISOLATION_LEVEL.REPEATABLE_READ:
            return "REPEATABLE READ";
          case ISOLATION_LEVEL.SERIALIZABLE:
            return "SERIALIZABLE";
          case ISOLATION_LEVEL.SNAPSHOT:
            return "SNAPSHOT";
        }
        return "";
      }
    };
    exports.Transaction = Transaction;
  }
});
var require_implementation = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});
var require_function_bind = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});
var require_isArguments = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js"(exports, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});
var require_implementation2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js"(exports, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject2 = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject2 && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject2 && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name3 in object) {
            if (!(skipProto && name3 === "prototype") && has.call(object, name3)) {
              theKeys.push(String(name3));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});
var require_object_keys = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js"(exports, module2) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation2();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});
var require_shams = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js"(exports, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});
var require_has_symbols = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js"(exports, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});
var require_has_proto = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/has-proto@1.0.1/node_modules/has-proto/index.js"(exports, module2) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});
var require_src3 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/has@1.0.3/node_modules/has/src/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});
var require_get_intrinsic = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/get-intrinsic@1.2.1/node_modules/get-intrinsic/index.js"(exports, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name3) {
      var value;
      if (name3 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name3 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name3 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name3 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name3 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name3] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src3();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name3, allowMissing) {
      var intrinsicName = name3;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name3 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name3 + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name3, allowMissing) {
      if (typeof name3 !== "string" || name3.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name3) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name3);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name3 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});
var require_has_property_descriptors = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/has-property-descriptors@1.0.0/node_modules/has-property-descriptors/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});
var require_gopd = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/gopd@1.0.1/node_modules/gopd/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});
var require_define_data_property = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/define-data-property@1.1.0/node_modules/define-data-property/index.js"(exports, module2) {
    "use strict";
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});
var require_define_properties = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js"(exports, module2) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name3, value, predicate) {
      if (name3 in object) {
        if (predicate === true) {
          if (object[name3] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name3, value, true);
      } else {
        defineDataProperty(object, name3, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  }
});
var require_functions_have_names = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/functions-have-names@1.2.3/node_modules/functions-have-names/index.js"(exports, module2) {
    "use strict";
    var functionsHaveNames = function functionsHaveNames2() {
      return typeof function f() {
      }.name === "string";
    };
    var gOPD = Object.getOwnPropertyDescriptor;
    if (gOPD) {
      try {
        gOPD([], "length");
      } catch (e) {
        gOPD = null;
      }
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
      if (!functionsHaveNames() || !gOPD) {
        return false;
      }
      var desc = gOPD(function() {
      }, "name");
      return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
      return functionsHaveNames() && typeof $bind === "function" && function f() {
      }.bind().name !== "";
    };
    module2.exports = functionsHaveNames;
  }
});
var require_set_function_name = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/set-function-name@2.0.1/node_modules/set-function-name/index.js"(exports, module2) {
    "use strict";
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
    var $TypeError = TypeError;
    module2.exports = function setFunctionName(fn, name3) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      if (!loose || functionsHaveConfigurableNames) {
        if (hasDescriptors) {
          define2(fn, "name", name3, true, true);
        } else {
          define2(fn, "name", name3);
        }
      }
      return fn;
    };
  }
});
var require_IsPropertyKey = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/IsPropertyKey.js"(exports, module2) {
    "use strict";
    module2.exports = function IsPropertyKey(argument) {
      return typeof argument === "string" || typeof argument === "symbol";
    };
  }
});
var require_isPropertyDescriptor = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/isPropertyDescriptor.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var has = require_src3();
    var $TypeError = GetIntrinsic("%TypeError%");
    module2.exports = function IsPropertyDescriptor(ES, Desc) {
      if (ES.Type(Desc) !== "Object") {
        return false;
      }
      var allowed = {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Get]]": true,
        "[[Set]]": true,
        "[[Value]]": true,
        "[[Writable]]": true
      };
      for (var key in Desc) {
        if (has(Desc, key) && !allowed[key]) {
          return false;
        }
      }
      if (ES.IsDataDescriptor(Desc) && ES.IsAccessorDescriptor(Desc)) {
        throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
      }
      return true;
    };
  }
});
var require_Type = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/5/Type.js"(exports, module2) {
    "use strict";
    module2.exports = function Type(x) {
      if (x === null) {
        return "Null";
      }
      if (typeof x === "undefined") {
        return "Undefined";
      }
      if (typeof x === "function" || typeof x === "object") {
        return "Object";
      }
      if (typeof x === "number") {
        return "Number";
      }
      if (typeof x === "boolean") {
        return "Boolean";
      }
      if (typeof x === "string") {
        return "String";
      }
    };
  }
});
var require_Type2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/Type.js"(exports, module2) {
    "use strict";
    var ES5Type = require_Type();
    module2.exports = function Type(x) {
      if (typeof x === "symbol") {
        return "Symbol";
      }
      if (typeof x === "bigint") {
        return "BigInt";
      }
      return ES5Type(x);
    };
  }
});
var require_isNaN = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/isNaN.js"(exports, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});
var require_isFinite = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/isFinite.js"(exports, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function(x) {
      return (typeof x === "number" || typeof x === "bigint") && !$isNaN(x) && x !== Infinity && x !== -Infinity;
    };
  }
});
var require_isInteger = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/isInteger.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $abs = GetIntrinsic("%Math.abs%");
    var $floor = GetIntrinsic("%Math.floor%");
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    module2.exports = function isInteger(argument) {
      if (typeof argument !== "number" || $isNaN(argument) || !$isFinite(argument)) {
        return false;
      }
      var absValue = $abs(argument);
      return $floor(absValue) === absValue;
    };
  }
});
var require_isMatchRecord = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/isMatchRecord.js"(exports, module2) {
    "use strict";
    var has = require_src3();
    module2.exports = function isMatchRecord(record) {
      return has(record, "[[StartIndex]]") && has(record, "[[EndIndex]]") && record["[[StartIndex]]"] >= 0 && record["[[EndIndex]]"] >= record["[[StartIndex]]"] && String(parseInt(record["[[StartIndex]]"], 10)) === String(record["[[StartIndex]]"]) && String(parseInt(record["[[EndIndex]]"], 10)) === String(record["[[EndIndex]]"]);
    };
  }
});
var require_assertRecord = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/assertRecord.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var has = require_src3();
    var isInteger = require_isInteger();
    var isMatchRecord = require_isMatchRecord();
    var predicates = {
      // https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type
      "Property Descriptor": function isPropertyDescriptor(Desc) {
        var allowed = {
          "[[Configurable]]": true,
          "[[Enumerable]]": true,
          "[[Get]]": true,
          "[[Set]]": true,
          "[[Value]]": true,
          "[[Writable]]": true
        };
        if (!Desc) {
          return false;
        }
        for (var key in Desc) {
          if (has(Desc, key) && !allowed[key]) {
            return false;
          }
        }
        var isData = has(Desc, "[[Value]]");
        var IsAccessor = has(Desc, "[[Get]]") || has(Desc, "[[Set]]");
        if (isData && IsAccessor) {
          throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
        }
        return true;
      },
      // https://262.ecma-international.org/13.0/#sec-match-records
      "Match Record": isMatchRecord,
      "Iterator Record": function isIteratorRecord(value) {
        return has(value, "[[Iterator]]") && has(value, "[[NextMethod]]") && has(value, "[[Done]]");
      },
      "PromiseCapability Record": function isPromiseCapabilityRecord(value) {
        return !!value && has(value, "[[Resolve]]") && typeof value["[[Resolve]]"] === "function" && has(value, "[[Reject]]") && typeof value["[[Reject]]"] === "function" && has(value, "[[Promise]]") && value["[[Promise]]"] && typeof value["[[Promise]]"].then === "function";
      },
      "AsyncGeneratorRequest Record": function isAsyncGeneratorRequestRecord(value) {
        return !!value && has(value, "[[Completion]]") && has(value, "[[Capability]]") && predicates["PromiseCapability Record"](value["[[Capability]]"]);
      },
      "RegExp Record": function isRegExpRecord(value) {
        return value && has(value, "[[IgnoreCase]]") && typeof value["[[IgnoreCase]]"] === "boolean" && has(value, "[[Multiline]]") && typeof value["[[Multiline]]"] === "boolean" && has(value, "[[DotAll]]") && typeof value["[[DotAll]]"] === "boolean" && has(value, "[[Unicode]]") && typeof value["[[Unicode]]"] === "boolean" && has(value, "[[CapturingGroupsCount]]") && typeof value["[[CapturingGroupsCount]]"] === "number" && isInteger(value["[[CapturingGroupsCount]]"]) && value["[[CapturingGroupsCount]]"] >= 0;
      }
    };
    module2.exports = function assertRecord(Type, recordType, argumentName, value) {
      var predicate = predicates[recordType];
      if (typeof predicate !== "function") {
        throw new $SyntaxError("unknown record type: " + recordType);
      }
      if (Type(value) !== "Object" || !predicate(value)) {
        throw new $TypeError(argumentName + " must be a " + recordType);
      }
    };
  }
});
var require_IsAccessorDescriptor = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/IsAccessorDescriptor.js"(exports, module2) {
    "use strict";
    var has = require_src3();
    var Type = require_Type2();
    var assertRecord = require_assertRecord();
    module2.exports = function IsAccessorDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!has(Desc, "[[Get]]") && !has(Desc, "[[Set]]")) {
        return false;
      }
      return true;
    };
  }
});
var require_IsDataDescriptor = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/IsDataDescriptor.js"(exports, module2) {
    "use strict";
    var has = require_src3();
    var Type = require_Type2();
    var assertRecord = require_assertRecord();
    module2.exports = function IsDataDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!has(Desc, "[[Value]]") && !has(Desc, "[[Writable]]")) {
        return false;
      }
      return true;
    };
  }
});
var require_isPrimitive = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/isPrimitive.js"(exports, module2) {
    "use strict";
    module2.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});
var require_IsExtensible = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/IsExtensible.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $preventExtensions = GetIntrinsic("%Object.preventExtensions%", true);
    var $isExtensible = GetIntrinsic("%Object.isExtensible%", true);
    var isPrimitive = require_isPrimitive();
    module2.exports = $preventExtensions ? function IsExtensible(obj) {
      return !isPrimitive(obj) && $isExtensible(obj);
    } : function IsExtensible(obj) {
      return !isPrimitive(obj);
    };
  }
});
var require_ToBoolean = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/ToBoolean.js"(exports, module2) {
    "use strict";
    module2.exports = function ToBoolean(value) {
      return !!value;
    };
  }
});
var require_is_callable = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js"(exports, module2) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_2) {
        if (_2 !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module2.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});
var require_IsCallable = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/IsCallable.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_callable();
  }
});
var require_ToPropertyDescriptor = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/ToPropertyDescriptor.js"(exports, module2) {
    "use strict";
    var has = require_src3();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Type = require_Type2();
    var ToBoolean = require_ToBoolean();
    var IsCallable = require_IsCallable();
    module2.exports = function ToPropertyDescriptor(Obj) {
      if (Type(Obj) !== "Object") {
        throw new $TypeError("ToPropertyDescriptor requires an object");
      }
      var desc = {};
      if (has(Obj, "enumerable")) {
        desc["[[Enumerable]]"] = ToBoolean(Obj.enumerable);
      }
      if (has(Obj, "configurable")) {
        desc["[[Configurable]]"] = ToBoolean(Obj.configurable);
      }
      if (has(Obj, "value")) {
        desc["[[Value]]"] = Obj.value;
      }
      if (has(Obj, "writable")) {
        desc["[[Writable]]"] = ToBoolean(Obj.writable);
      }
      if (has(Obj, "get")) {
        var getter = Obj.get;
        if (typeof getter !== "undefined" && !IsCallable(getter)) {
          throw new $TypeError("getter must be a function");
        }
        desc["[[Get]]"] = getter;
      }
      if (has(Obj, "set")) {
        var setter = Obj.set;
        if (typeof setter !== "undefined" && !IsCallable(setter)) {
          throw new $TypeError("setter must be a function");
        }
        desc["[[Set]]"] = setter;
      }
      if ((has(desc, "[[Get]]") || has(desc, "[[Set]]")) && (has(desc, "[[Value]]") || has(desc, "[[Writable]]"))) {
        throw new $TypeError("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
      }
      return desc;
    };
  }
});
var require_SameValue = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/SameValue.js"(exports, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function SameValue(x, y) {
      if (x === y) {
        if (x === 0) {
          return 1 / x === 1 / y;
        }
        return true;
      }
      return $isNaN(x) && $isNaN(y);
    };
  }
});
var require_call_bind = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});
var require_callBound = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/callBound.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name3, allowMissing) {
      var intrinsic = GetIntrinsic(name3, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name3, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});
var require_IsArray = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/IsArray.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $Array = GetIntrinsic("%Array%");
    var toStr = !$Array.isArray && require_callBound()("Object.prototype.toString");
    module2.exports = $Array.isArray || function IsArray(argument) {
      return toStr(argument) === "[object Array]";
    };
  }
});
var require_DefineOwnProperty = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/DefineOwnProperty.js"(exports, module2) {
    "use strict";
    var hasPropertyDescriptors = require_has_property_descriptors();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = hasPropertyDescriptors() && GetIntrinsic("%Object.defineProperty%", true);
    var hasArrayLengthDefineBug = hasPropertyDescriptors.hasArrayLengthDefineBug();
    var isArray = hasArrayLengthDefineBug && require_IsArray();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    module2.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, desc) {
      if (!$defineProperty) {
        if (!IsDataDescriptor(desc)) {
          return false;
        }
        if (!desc["[[Configurable]]"] || !desc["[[Writable]]"]) {
          return false;
        }
        if (P in O && $isEnumerable(O, P) !== !!desc["[[Enumerable]]"]) {
          return false;
        }
        var V = desc["[[Value]]"];
        O[P] = V;
        return SameValue(O[P], V);
      }
      if (hasArrayLengthDefineBug && P === "length" && "[[Value]]" in desc && isArray(O) && O.length !== desc["[[Value]]"]) {
        O.length = desc["[[Value]]"];
        return O.length === desc["[[Value]]"];
      }
      $defineProperty(O, P, FromPropertyDescriptor(desc));
      return true;
    };
  }
});
var require_isFullyPopulatedPropertyDescriptor = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/isFullyPopulatedPropertyDescriptor.js"(exports, module2) {
    "use strict";
    module2.exports = function isFullyPopulatedPropertyDescriptor(ES, Desc) {
      return !!Desc && typeof Desc === "object" && "[[Enumerable]]" in Desc && "[[Configurable]]" in Desc && (ES.IsAccessorDescriptor(Desc) || ES.IsDataDescriptor(Desc));
    };
  }
});
var require_fromPropertyDescriptor = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/fromPropertyDescriptor.js"(exports, module2) {
    "use strict";
    module2.exports = function fromPropertyDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return Desc;
      }
      var obj = {};
      if ("[[Value]]" in Desc) {
        obj.value = Desc["[[Value]]"];
      }
      if ("[[Writable]]" in Desc) {
        obj.writable = !!Desc["[[Writable]]"];
      }
      if ("[[Get]]" in Desc) {
        obj.get = Desc["[[Get]]"];
      }
      if ("[[Set]]" in Desc) {
        obj.set = Desc["[[Set]]"];
      }
      if ("[[Enumerable]]" in Desc) {
        obj.enumerable = !!Desc["[[Enumerable]]"];
      }
      if ("[[Configurable]]" in Desc) {
        obj.configurable = !!Desc["[[Configurable]]"];
      }
      return obj;
    };
  }
});
var require_FromPropertyDescriptor = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/FromPropertyDescriptor.js"(exports, module2) {
    "use strict";
    var assertRecord = require_assertRecord();
    var fromPropertyDescriptor = require_fromPropertyDescriptor();
    var Type = require_Type2();
    module2.exports = function FromPropertyDescriptor(Desc) {
      if (typeof Desc !== "undefined") {
        assertRecord(Type, "Property Descriptor", "Desc", Desc);
      }
      return fromPropertyDescriptor(Desc);
    };
  }
});
var require_IsGenericDescriptor = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/IsGenericDescriptor.js"(exports, module2) {
    "use strict";
    var assertRecord = require_assertRecord();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var Type = require_Type2();
    module2.exports = function IsGenericDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
        return true;
      }
      return false;
    };
  }
});
var require_ValidateAndApplyPropertyDescriptor = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/ValidateAndApplyPropertyDescriptor.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var DefineOwnProperty = require_DefineOwnProperty();
    var isFullyPopulatedPropertyDescriptor = require_isFullyPopulatedPropertyDescriptor();
    var isPropertyDescriptor = require_isPropertyDescriptor();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsGenericDescriptor = require_IsGenericDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    module2.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
      var oType = Type(O);
      if (oType !== "Undefined" && oType !== "Object") {
        throw new $TypeError("Assertion failed: O must be undefined or an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      if (Type(extensible) !== "Boolean") {
        throw new $TypeError("Assertion failed: extensible must be a Boolean");
      }
      if (!isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, Desc)) {
        throw new $TypeError("Assertion failed: Desc must be a Property Descriptor");
      }
      if (Type(current) !== "Undefined" && !isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, current)) {
        throw new $TypeError("Assertion failed: current must be a Property Descriptor, or undefined");
      }
      if (Type(current) === "Undefined") {
        if (!extensible) {
          return false;
        }
        if (oType === "Undefined") {
          return true;
        }
        if (IsAccessorDescriptor(Desc)) {
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O,
            P,
            Desc
          );
        }
        return DefineOwnProperty(
          IsDataDescriptor,
          SameValue,
          FromPropertyDescriptor,
          O,
          P,
          {
            "[[Configurable]]": !!Desc["[[Configurable]]"],
            "[[Enumerable]]": !!Desc["[[Enumerable]]"],
            "[[Value]]": Desc["[[Value]]"],
            "[[Writable]]": !!Desc["[[Writable]]"]
          }
        );
      }
      if (!isFullyPopulatedPropertyDescriptor({
        IsAccessorDescriptor,
        IsDataDescriptor
      }, current)) {
        throw new $TypeError("`current`, when present, must be a fully populated and valid Property Descriptor");
      }
      if (!current["[[Configurable]]"]) {
        if ("[[Configurable]]" in Desc && Desc["[[Configurable]]"]) {
          return false;
        }
        if ("[[Enumerable]]" in Desc && !SameValue(Desc["[[Enumerable]]"], current["[[Enumerable]]"])) {
          return false;
        }
        if (!IsGenericDescriptor(Desc) && !SameValue(IsAccessorDescriptor(Desc), IsAccessorDescriptor(current))) {
          return false;
        }
        if (IsAccessorDescriptor(current)) {
          if ("[[Get]]" in Desc && !SameValue(Desc["[[Get]]"], current["[[Get]]"])) {
            return false;
          }
          if ("[[Set]]" in Desc && !SameValue(Desc["[[Set]]"], current["[[Set]]"])) {
            return false;
          }
        } else if (!current["[[Writable]]"]) {
          if ("[[Writable]]" in Desc && Desc["[[Writable]]"]) {
            return false;
          }
          if ("[[Value]]" in Desc && !SameValue(Desc["[[Value]]"], current["[[Value]]"])) {
            return false;
          }
        }
      }
      if (oType !== "Undefined") {
        var configurable;
        var enumerable;
        if (IsDataDescriptor(current) && IsAccessorDescriptor(Desc)) {
          configurable = ("[[Configurable]]" in Desc ? Desc : current)["[[Configurable]]"];
          enumerable = ("[[Enumerable]]" in Desc ? Desc : current)["[[Enumerable]]"];
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O,
            P,
            {
              "[[Configurable]]": !!configurable,
              "[[Enumerable]]": !!enumerable,
              "[[Get]]": ("[[Get]]" in Desc ? Desc : current)["[[Get]]"],
              "[[Set]]": ("[[Set]]" in Desc ? Desc : current)["[[Set]]"]
            }
          );
        } else if (IsAccessorDescriptor(current) && IsDataDescriptor(Desc)) {
          configurable = ("[[Configurable]]" in Desc ? Desc : current)["[[Configurable]]"];
          enumerable = ("[[Enumerable]]" in Desc ? Desc : current)["[[Enumerable]]"];
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O,
            P,
            {
              "[[Configurable]]": !!configurable,
              "[[Enumerable]]": !!enumerable,
              "[[Value]]": ("[[Value]]" in Desc ? Desc : current)["[[Value]]"],
              "[[Writable]]": !!("[[Writable]]" in Desc ? Desc : current)["[[Writable]]"]
            }
          );
        }
        return DefineOwnProperty(
          IsDataDescriptor,
          SameValue,
          FromPropertyDescriptor,
          O,
          P,
          Desc
        );
      }
      return true;
    };
  }
});
var require_OrdinaryDefineOwnProperty = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/OrdinaryDefineOwnProperty.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = require_gopd();
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var isPropertyDescriptor = require_isPropertyDescriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsExtensible = require_IsExtensible();
    var IsPropertyKey = require_IsPropertyKey();
    var ToPropertyDescriptor = require_ToPropertyDescriptor();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    var ValidateAndApplyPropertyDescriptor = require_ValidateAndApplyPropertyDescriptor();
    module2.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: O must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      if (!isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, Desc)) {
        throw new $TypeError("Assertion failed: Desc must be a Property Descriptor");
      }
      if (!$gOPD) {
        if (IsAccessorDescriptor(Desc)) {
          throw new $SyntaxError("This environment does not support accessor property descriptors.");
        }
        var creatingNormalDataProperty = !(P in O) && Desc["[[Writable]]"] && Desc["[[Enumerable]]"] && Desc["[[Configurable]]"] && "[[Value]]" in Desc;
        var settingExistingDataProperty = P in O && (!("[[Configurable]]" in Desc) || Desc["[[Configurable]]"]) && (!("[[Enumerable]]" in Desc) || Desc["[[Enumerable]]"]) && (!("[[Writable]]" in Desc) || Desc["[[Writable]]"]) && "[[Value]]" in Desc;
        if (creatingNormalDataProperty || settingExistingDataProperty) {
          O[P] = Desc["[[Value]]"];
          return SameValue(O[P], Desc["[[Value]]"]);
        }
        throw new $SyntaxError("This environment does not support defining non-writable, non-enumerable, or non-configurable properties");
      }
      var desc = $gOPD(O, P);
      var current = desc && ToPropertyDescriptor(desc);
      var extensible = IsExtensible(O);
      return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
    };
  }
});
var require_CreateDataProperty = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/CreateDataProperty.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsPropertyKey = require_IsPropertyKey();
    var OrdinaryDefineOwnProperty = require_OrdinaryDefineOwnProperty();
    var Type = require_Type2();
    module2.exports = function CreateDataProperty(O, P, V) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var newDesc = {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Value]]": V,
        "[[Writable]]": true
      };
      return OrdinaryDefineOwnProperty(O, P, newDesc);
    };
  }
});
var require_CreateDataPropertyOrThrow = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/CreateDataPropertyOrThrow.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var CreateDataProperty = require_CreateDataProperty();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module2.exports = function CreateDataPropertyOrThrow(O, P, V) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var success = CreateDataProperty(O, P, V);
      if (!success) {
        throw new $TypeError("unable to create data property");
      }
    };
  }
});
var require_CreateMethodProperty = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/CreateMethodProperty.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var DefineOwnProperty = require_DefineOwnProperty();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    module2.exports = function CreateMethodProperty(O, P, V) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var newDesc = {
        "[[Configurable]]": true,
        "[[Enumerable]]": false,
        "[[Value]]": V,
        "[[Writable]]": true
      };
      return DefineOwnProperty(
        IsDataDescriptor,
        SameValue,
        FromPropertyDescriptor,
        O,
        P,
        newDesc
      );
    };
  }
});
var require_util_inspect = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/object-inspect@1.12.3/node_modules/object-inspect/util.inspect.js"(exports, module2) {
    "use strict";
    module2.exports = (0, import_chunk_FVJ3R4NJ.__require)("util").inspect;
  }
});
var require_object_inspect = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/object-inspect@1.12.3/node_modules/object-inspect/index.js"(exports, module2) {
    "use strict";
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util_inspect();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect2(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name3 = nameOf(obj);
        var keys = arrObjKeys(obj, inspect2);
        return "[Function" + (name3 ? ": " + name3 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect2);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError2(obj)) {
        var parts = arrObjKeys(obj, inspect2);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect2(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect2(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect2(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect2(String(obj)));
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect2);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError2(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type2) {
      return type2 + " { ? }";
    }
    function collectionOf(type2, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type2 + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect2) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect2(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect2(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});
var require_isLeadingSurrogate = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/isLeadingSurrogate.js"(exports, module2) {
    "use strict";
    module2.exports = function isLeadingSurrogate(charCode) {
      return typeof charCode === "number" && charCode >= 55296 && charCode <= 56319;
    };
  }
});
var require_isTrailingSurrogate = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/isTrailingSurrogate.js"(exports, module2) {
    "use strict";
    module2.exports = function isTrailingSurrogate(charCode) {
      return typeof charCode === "number" && charCode >= 56320 && charCode <= 57343;
    };
  }
});
var require_UTF16SurrogatePairToCodePoint = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/UTF16SurrogatePairToCodePoint.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $fromCharCode = GetIntrinsic("%String.fromCharCode%");
    var isLeadingSurrogate = require_isLeadingSurrogate();
    var isTrailingSurrogate = require_isTrailingSurrogate();
    module2.exports = function UTF16SurrogatePairToCodePoint(lead, trail) {
      if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
        throw new $TypeError("Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code");
      }
      return $fromCharCode(lead) + $fromCharCode(trail);
    };
  }
});
var require_CodePointAt = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/CodePointAt.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var callBound = require_callBound();
    var isLeadingSurrogate = require_isLeadingSurrogate();
    var isTrailingSurrogate = require_isTrailingSurrogate();
    var Type = require_Type2();
    var UTF16SurrogatePairToCodePoint = require_UTF16SurrogatePairToCodePoint();
    var $charAt = callBound("String.prototype.charAt");
    var $charCodeAt = callBound("String.prototype.charCodeAt");
    module2.exports = function CodePointAt(string, position) {
      if (Type(string) !== "String") {
        throw new $TypeError("Assertion failed: `string` must be a String");
      }
      var size = string.length;
      if (position < 0 || position >= size) {
        throw new $TypeError("Assertion failed: `position` must be >= 0, and < the length of `string`");
      }
      var first = $charCodeAt(string, position);
      var cp = $charAt(string, position);
      var firstIsLeading = isLeadingSurrogate(first);
      var firstIsTrailing = isTrailingSurrogate(first);
      if (!firstIsLeading && !firstIsTrailing) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": false
        };
      }
      if (firstIsTrailing || position + 1 === size) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": true
        };
      }
      var second = $charCodeAt(string, position + 1);
      if (!isTrailingSurrogate(second)) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": true
        };
      }
      return {
        "[[CodePoint]]": UTF16SurrogatePairToCodePoint(first, second),
        "[[CodeUnitCount]]": 2,
        "[[IsUnpairedSurrogate]]": false
      };
    };
  }
});
var require_maxSafeInteger = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/maxSafeInteger.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $Math = GetIntrinsic("%Math%");
    var $Number = GetIntrinsic("%Number%");
    module2.exports = $Number.MAX_SAFE_INTEGER || $Math.pow(2, 53) - 1;
  }
});
var require_AdvanceStringIndex = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/AdvanceStringIndex.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var CodePointAt = require_CodePointAt();
    var Type = require_Type2();
    var isInteger = require_isInteger();
    var MAX_SAFE_INTEGER2 = require_maxSafeInteger();
    var $TypeError = GetIntrinsic("%TypeError%");
    module2.exports = function AdvanceStringIndex(S, index, unicode) {
      if (Type(S) !== "String") {
        throw new $TypeError("Assertion failed: `S` must be a String");
      }
      if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER2) {
        throw new $TypeError("Assertion failed: `length` must be an integer >= 0 and <= 2**53");
      }
      if (Type(unicode) !== "Boolean") {
        throw new $TypeError("Assertion failed: `unicode` must be a Boolean");
      }
      if (!unicode) {
        return index + 1;
      }
      var length = S.length;
      if (index + 1 >= length) {
        return index + 1;
      }
      var cp = CodePointAt(S, index);
      return index + cp["[[CodeUnitCount]]"];
    };
  }
});
var require_CreateIterResultObject = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/CreateIterResultObject.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Type = require_Type2();
    module2.exports = function CreateIterResultObject(value, done) {
      if (Type(done) !== "Boolean") {
        throw new $TypeError("Assertion failed: Type(done) is not Boolean");
      }
      return {
        value,
        done
      };
    };
  }
});
var require_Get = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/Get.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var inspect2 = require_object_inspect();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module2.exports = function Get(O, P) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true, got " + inspect2(P));
      }
      return O[P];
    };
  }
});
var require_IteratorComplete = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/IteratorComplete.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Get = require_Get();
    var ToBoolean = require_ToBoolean();
    var Type = require_Type2();
    module2.exports = function IteratorComplete(iterResult) {
      if (Type(iterResult) !== "Object") {
        throw new $TypeError("Assertion failed: Type(iterResult) is not Object");
      }
      return ToBoolean(Get(iterResult, "done"));
    };
  }
});
var require_IteratorValue = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/IteratorValue.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Get = require_Get();
    var Type = require_Type2();
    module2.exports = function IteratorValue(iterResult) {
      if (Type(iterResult) !== "Object") {
        throw new $TypeError("Assertion failed: Type(iterResult) is not Object");
      }
      return Get(iterResult, "value");
    };
  }
});
var require_PromiseResolve = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/PromiseResolve.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $resolve = GetIntrinsic("%Promise.resolve%", true);
    var $PromiseResolve = $resolve && callBind($resolve);
    module2.exports = function PromiseResolve(C, x) {
      if (!$PromiseResolve) {
        throw new SyntaxError("This environment does not support Promises.");
      }
      return $PromiseResolve(C, x);
    };
  }
});
var require_AsyncFromSyncIteratorContinuation = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/AsyncFromSyncIteratorContinuation.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var $Promise = GetIntrinsic("%Promise%", true);
    var callBound = require_callBound();
    var CreateIterResultObject = require_CreateIterResultObject();
    var IteratorComplete = require_IteratorComplete();
    var IteratorValue = require_IteratorValue();
    var PromiseResolve = require_PromiseResolve();
    var Type = require_Type2();
    var $then = callBound("Promise.prototype.then", true);
    module2.exports = function AsyncFromSyncIteratorContinuation(result) {
      if (Type(result) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (arguments.length > 1) {
        throw new $SyntaxError("although AsyncFromSyncIteratorContinuation should take a second argument, it is not used in this implementation");
      }
      if (!$Promise) {
        throw new $SyntaxError("This environment does not support Promises.");
      }
      return new Promise(function(resolve) {
        var done = IteratorComplete(result);
        var value = IteratorValue(result);
        var valueWrapper = PromiseResolve($Promise, value);
        var onFulfilled = function(value2) {
          return CreateIterResultObject(value2, done);
        };
        resolve($then(valueWrapper, onFulfilled));
      });
    };
  }
});
var require_IsArray2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/IsArray.js"(exports, module2) {
    "use strict";
    module2.exports = require_IsArray();
  }
});
var require_Call = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/Call.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsArray = require_IsArray2();
    var $apply = GetIntrinsic("%Reflect.apply%", true) || callBound("Function.prototype.apply");
    module2.exports = function Call(F, V) {
      var argumentsList = arguments.length > 2 ? arguments[2] : [];
      if (!IsArray(argumentsList)) {
        throw new $TypeError("Assertion failed: optional `argumentsList`, if provided, must be a List");
      }
      return $apply(F, V, argumentsList);
    };
  }
});
var require_GetV = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/GetV.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var inspect2 = require_object_inspect();
    var IsPropertyKey = require_IsPropertyKey();
    module2.exports = function GetV(V, P) {
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true, got " + inspect2(P));
      }
      return V[P];
    };
  }
});
var require_GetMethod = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/GetMethod.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var GetV = require_GetV();
    var IsCallable = require_IsCallable();
    var IsPropertyKey = require_IsPropertyKey();
    var inspect2 = require_object_inspect();
    module2.exports = function GetMethod(O, P) {
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var func = GetV(O, P);
      if (func == null) {
        return void 0;
      }
      if (!IsCallable(func)) {
        throw new $TypeError(inspect2(P) + " is not a function: " + inspect2(func));
      }
      return func;
    };
  }
});
var require_IteratorNext = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/IteratorNext.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Call = require_Call();
    var Type = require_Type2();
    var assertRecord = require_assertRecord();
    module2.exports = function IteratorNext(iteratorRecord) {
      assertRecord(Type, "Iterator Record", "iteratorRecord", iteratorRecord);
      var result;
      if (arguments.length < 2) {
        result = Call(iteratorRecord["[[NextMethod]]"], iteratorRecord["[[Iterator]]"]);
      } else {
        result = Call(iteratorRecord["[[NextMethod]]"], iteratorRecord["[[Iterator]]"], [arguments[1]]);
      }
      if (Type(result) !== "Object") {
        throw new $TypeError("iterator next must return an object");
      }
      return result;
    };
  }
});
var require_forEach = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/forEach.js"(exports, module2) {
    "use strict";
    module2.exports = function forEach(array, callback) {
      for (var i = 0; i < array.length; i += 1) {
        callback(array[i], i, array);
      }
    };
  }
});
var require_side_channel = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/side-channel@1.0.4/node_modules/side-channel/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect2 = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect2(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});
var require_internal_slot = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/internal-slot@1.0.5/node_modules/internal-slot/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var has = require_src3();
    var channel = require_side_channel()();
    var $TypeError = GetIntrinsic("%TypeError%");
    var SLOT = {
      assert: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        channel.assert(O);
        if (!SLOT.has(O, slot)) {
          throw new $TypeError("`" + slot + "` is not present on `O`");
        }
      },
      get: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        return slots && slots["$" + slot];
      },
      has: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        return !!slots && has(slots, "$" + slot);
      },
      set: function(O, slot, V) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        if (!slots) {
          slots = {};
          channel.set(O, slots);
        }
        slots["$" + slot] = V;
      }
    };
    if (Object.freeze) {
      Object.freeze(SLOT);
    }
    module2.exports = SLOT;
  }
});
var require_OrdinaryObjectCreate = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/OrdinaryObjectCreate.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $ObjectCreate = GetIntrinsic("%Object.create%", true);
    var $TypeError = GetIntrinsic("%TypeError%");
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var IsArray = require_IsArray2();
    var Type = require_Type2();
    var forEach = require_forEach();
    var SLOT = require_internal_slot();
    var hasProto = require_has_proto()();
    module2.exports = function OrdinaryObjectCreate(proto) {
      if (proto !== null && Type(proto) !== "Object") {
        throw new $TypeError("Assertion failed: `proto` must be null or an object");
      }
      var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
      if (!IsArray(additionalInternalSlotsList)) {
        throw new $TypeError("Assertion failed: `additionalInternalSlotsList` must be an Array");
      }
      var O;
      if ($ObjectCreate) {
        O = $ObjectCreate(proto);
      } else if (hasProto) {
        O = { __proto__: proto };
      } else {
        if (proto === null) {
          throw new $SyntaxError("native Object.create support is required to create null objects");
        }
        var T = function T2() {
        };
        T.prototype = proto;
        O = new T();
      }
      if (additionalInternalSlotsList.length > 0) {
        forEach(additionalInternalSlotsList, function(slot) {
          SLOT.set(O, slot, void 0);
        });
      }
      return O;
    };
  }
});
var require_CreateAsyncFromSyncIterator = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/CreateAsyncFromSyncIterator.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var AsyncFromSyncIteratorContinuation = require_AsyncFromSyncIteratorContinuation();
    var Call = require_Call();
    var CreateIterResultObject = require_CreateIterResultObject();
    var Get = require_Get();
    var GetMethod = require_GetMethod();
    var IteratorNext = require_IteratorNext();
    var OrdinaryObjectCreate = require_OrdinaryObjectCreate();
    var Type = require_Type2();
    var SLOT = require_internal_slot();
    var assertRecord = require_assertRecord();
    var $AsyncFromSyncIteratorPrototype = GetIntrinsic("%AsyncFromSyncIteratorPrototype%", true) || {
      next: function next(value) {
        var O = this;
        SLOT.assert(O, "[[SyncIteratorRecord]]");
        var argsLength = arguments.length;
        return new Promise(function(resolve) {
          var syncIteratorRecord = SLOT.get(O, "[[SyncIteratorRecord]]");
          var result;
          if (argsLength > 0) {
            result = IteratorNext(syncIteratorRecord, value);
          } else {
            result = IteratorNext(syncIteratorRecord);
          }
          resolve(AsyncFromSyncIteratorContinuation(result));
        });
      },
      "return": function() {
        var O = this;
        SLOT.assert(O, "[[SyncIteratorRecord]]");
        var valueIsPresent = arguments.length > 0;
        var value = valueIsPresent ? arguments[0] : void 0;
        return new Promise(function(resolve, reject) {
          var syncIterator = SLOT.get(O, "[[SyncIteratorRecord]]")["[[Iterator]]"];
          var iteratorReturn = GetMethod(syncIterator, "return");
          if (typeof iteratorReturn === "undefined") {
            var iterResult = CreateIterResultObject(value, true);
            Call(resolve, void 0, [iterResult]);
            return;
          }
          var result;
          if (valueIsPresent) {
            result = Call(iteratorReturn, syncIterator, [value]);
          } else {
            result = Call(iteratorReturn, syncIterator);
          }
          if (Type(result) !== "Object") {
            Call(reject, void 0, [new $TypeError("Iterator `return` method returned a non-object value.")]);
            return;
          }
          resolve(AsyncFromSyncIteratorContinuation(result));
        });
      },
      "throw": function() {
        var O = this;
        SLOT.assert(O, "[[SyncIteratorRecord]]");
        var valueIsPresent = arguments.length > 0;
        var value = valueIsPresent ? arguments[0] : void 0;
        return new Promise(function(resolve, reject) {
          var syncIterator = SLOT.get(O, "[[SyncIteratorRecord]]")["[[Iterator]]"];
          var throwMethod = GetMethod(syncIterator, "throw");
          if (typeof throwMethod === "undefined") {
            Call(reject, void 0, [value]);
            return;
          }
          var result;
          if (valueIsPresent) {
            result = Call(throwMethod, syncIterator, [value]);
          } else {
            result = Call(throwMethod, syncIterator);
          }
          if (Type(result) !== "Object") {
            Call(reject, void 0, [new $TypeError("Iterator `throw` method returned a non-object value.")]);
            return;
          }
          resolve(AsyncFromSyncIteratorContinuation(
            result
            /* , promiseCapability */
          ));
        });
      }
    };
    module2.exports = function CreateAsyncFromSyncIterator(syncIteratorRecord) {
      assertRecord(Type, "Iterator Record", "syncIteratorRecord", syncIteratorRecord);
      var asyncIterator = OrdinaryObjectCreate($AsyncFromSyncIteratorPrototype);
      SLOT.set(asyncIterator, "[[SyncIteratorRecord]]", syncIteratorRecord);
      var nextMethod = Get(asyncIterator, "next");
      return {
        // steps 3-4
        "[[Iterator]]": asyncIterator,
        "[[NextMethod]]": nextMethod,
        "[[Done]]": false
      };
    };
  }
});
var require_GetIteratorFromMethod = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/GetIteratorFromMethod.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Call = require_Call();
    var GetV = require_GetV();
    var IsCallable = require_IsCallable();
    var Type = require_Type2();
    module2.exports = function GetIteratorFromMethod(obj, method) {
      if (!IsCallable(method)) {
        throw new $TypeError("method must be a function");
      }
      var iterator = Call(method, obj);
      if (Type(iterator) !== "Object") {
        throw new $TypeError("iterator must return an object");
      }
      var nextMethod = GetV(iterator, "next");
      return {
        // steps 4-5
        "[[Iterator]]": iterator,
        "[[NextMethod]]": nextMethod,
        "[[Done]]": false
      };
    };
  }
});
var require_shams2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/has-tostringtag@1.0.0/node_modules/has-tostringtag/shams.js"(exports, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});
var require_is_string = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/is-string@1.0.7/node_modules/is-string/index.js"(exports, module2) {
    "use strict";
    var strValue = String.prototype.valueOf;
    var tryStringObject = function tryStringObject2(value) {
      try {
        strValue.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var strClass = "[object String]";
    var hasToStringTag = require_shams2()();
    module2.exports = function isString(value) {
      if (typeof value === "string") {
        return true;
      }
      if (typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
    };
  }
});
var require_getIteratorMethod = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/getIteratorMethod.js"(exports, module2) {
    "use strict";
    var hasSymbols = require_has_symbols()();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var isString = require_is_string();
    var $iterator = GetIntrinsic("%Symbol.iterator%", true);
    var $stringSlice = callBound("String.prototype.slice");
    var $String = GetIntrinsic("%String%");
    module2.exports = function getIteratorMethod(ES, iterable) {
      var usingIterator;
      if (hasSymbols) {
        usingIterator = ES.GetMethod(iterable, $iterator);
      } else if (ES.IsArray(iterable)) {
        usingIterator = function() {
          var i = -1;
          var arr = this;
          return {
            next: function() {
              i += 1;
              return {
                done: i >= arr.length,
                value: arr[i]
              };
            }
          };
        };
      } else if (isString(iterable)) {
        usingIterator = function() {
          var i = 0;
          return {
            next: function() {
              var nextIndex = ES.AdvanceStringIndex($String(iterable), i, true);
              var value = $stringSlice(iterable, i, nextIndex);
              i = nextIndex;
              return {
                done: nextIndex > iterable.length,
                value
              };
            }
          };
        };
      }
      return usingIterator;
    };
  }
});
var require_GetIterator = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/GetIterator.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $asyncIterator = GetIntrinsic("%Symbol.asyncIterator%", true);
    var inspect2 = require_object_inspect();
    var hasSymbols = require_has_symbols()();
    var AdvanceStringIndex = require_AdvanceStringIndex();
    var CreateAsyncFromSyncIterator = require_CreateAsyncFromSyncIterator();
    var GetIteratorFromMethod = require_GetIteratorFromMethod();
    var GetMethod = require_GetMethod();
    var IsArray = require_IsArray2();
    var getIteratorMethod = require_getIteratorMethod();
    module2.exports = function GetIterator(obj, kind) {
      if (kind !== "sync" && kind !== "async") {
        throw new $TypeError("Assertion failed: `kind` must be one of 'sync' or 'async', got " + inspect2(kind));
      }
      var method;
      if (kind === "async") {
        if (hasSymbols && $asyncIterator) {
          method = GetMethod(obj, $asyncIterator);
        }
      }
      if (typeof method === "undefined") {
        var syncMethod = getIteratorMethod(
          {
            AdvanceStringIndex,
            GetMethod,
            IsArray
          },
          obj
        );
        if (kind === "async") {
          if (typeof syncMethod === "undefined") {
            throw new $TypeError("iterator method is `undefined`");
          }
          var syncIteratorRecord = GetIteratorFromMethod(obj, syncMethod);
          return CreateAsyncFromSyncIterator(syncIteratorRecord);
        }
        method = syncMethod;
      }
      if (typeof method === "undefined") {
        throw new $TypeError("iterator method is `undefined`");
      }
      return GetIteratorFromMethod(obj, method);
    };
  }
});
var require_IteratorStep = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/IteratorStep.js"(exports, module2) {
    "use strict";
    var IteratorComplete = require_IteratorComplete();
    var IteratorNext = require_IteratorNext();
    var Type = require_Type2();
    var assertRecord = require_assertRecord();
    module2.exports = function IteratorStep(iteratorRecord) {
      assertRecord(Type, "Iterator Record", "iteratorRecord", iteratorRecord);
      var result = IteratorNext(iteratorRecord);
      var done = IteratorComplete(result);
      return done === true ? false : result;
    };
  }
});
var require_IteratorToList = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/IteratorToList.js"(exports, module2) {
    "use strict";
    var callBound = require_callBound();
    var $arrayPush = callBound("Array.prototype.push");
    var IteratorStep = require_IteratorStep();
    var IteratorValue = require_IteratorValue();
    var Type = require_Type2();
    var assertRecord = require_assertRecord();
    module2.exports = function IteratorToList(iteratorRecord) {
      assertRecord(Type, "Iterator Record", "iteratorRecord", iteratorRecord);
      var values = [];
      var next = true;
      while (next) {
        next = IteratorStep(iteratorRecord);
        if (next) {
          var nextValue = IteratorValue(next);
          $arrayPush(values, nextValue);
        }
      }
      return values;
    };
  }
});
var require_setProto = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/setProto.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var originalSetProto = GetIntrinsic("%Object.setPrototypeOf%", true);
    var hasProto = require_has_proto()();
    module2.exports = originalSetProto || (hasProto ? function(O, proto) {
      O.__proto__ = proto;
      return O;
    } : null);
  }
});
var require_getProto = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/helpers/getProto.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var originalGetProto = GetIntrinsic("%Object.getPrototypeOf%", true);
    var hasProto = require_has_proto()();
    module2.exports = originalGetProto || (hasProto ? function(O) {
      return O.__proto__;
    } : null);
  }
});
var require_OrdinaryGetPrototypeOf = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/OrdinaryGetPrototypeOf.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $getProto = require_getProto();
    var Type = require_Type2();
    module2.exports = function OrdinaryGetPrototypeOf(O) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: O must be an Object");
      }
      if (!$getProto) {
        throw new $TypeError("This environment does not support fetching prototypes.");
      }
      return $getProto(O);
    };
  }
});
var require_OrdinarySetPrototypeOf = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-abstract@1.22.1/node_modules/es-abstract/2023/OrdinarySetPrototypeOf.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $setProto = require_setProto();
    var OrdinaryGetPrototypeOf = require_OrdinaryGetPrototypeOf();
    var Type = require_Type2();
    module2.exports = function OrdinarySetPrototypeOf(O, V) {
      if (Type(V) !== "Object" && Type(V) !== "Null") {
        throw new $TypeError("Assertion failed: V must be Object or Null");
      }
      try {
        $setProto(O, V);
      } catch (e) {
        return false;
      }
      return OrdinaryGetPrototypeOf(O) === V;
    };
  }
});
var require_implementation3 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-aggregate-error@1.0.11/node_modules/es-aggregate-error/implementation.js"(exports, module2) {
    "use strict";
    var CreateDataPropertyOrThrow = require_CreateDataPropertyOrThrow();
    var CreateMethodProperty = require_CreateMethodProperty();
    var GetIterator = require_GetIterator();
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var IteratorToList = require_IteratorToList();
    var OrdinarySetPrototypeOf = require_OrdinarySetPrototypeOf();
    var GetIntrinsic = require_get_intrinsic();
    var $Error = GetIntrinsic("%Error%");
    function AggregateError2(errors, message) {
      var error = new $Error(message);
      OrdinarySetPrototypeOf(error, proto);
      delete error.constructor;
      var errorsList = IteratorToList(GetIterator(errors, "sync"));
      CreateDataPropertyOrThrow(error, "errors", errorsList);
      return error;
    }
    if (hasPropertyDescriptors) {
      Object.defineProperty(AggregateError2, "prototype", { writable: false });
    }
    var proto = AggregateError2.prototype;
    if (!CreateMethodProperty(proto, "constructor", AggregateError2) || !CreateMethodProperty(proto, "message", "") || !CreateMethodProperty(proto, "name", "AggregateError")) {
      throw new $Error("unable to install AggregateError.prototype properties; please report this!");
    }
    OrdinarySetPrototypeOf(AggregateError2.prototype, Error.prototype);
    module2.exports = AggregateError2;
  }
});
var require_polyfill = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-aggregate-error@1.0.11/node_modules/es-aggregate-error/polyfill.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation3();
    module2.exports = function getPolyfill() {
      return typeof AggregateError === "function" ? AggregateError : implementation;
    };
  }
});
var require_implementation4 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/globalthis@1.0.3/node_modules/globalthis/implementation.js"(exports, module2) {
    "use strict";
    module2.exports = global;
  }
});
var require_polyfill2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/globalthis@1.0.3/node_modules/globalthis/polyfill.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation4();
    module2.exports = function getPolyfill() {
      if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
        return implementation;
      }
      return global;
    };
  }
});
var require_shim = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/globalthis@1.0.3/node_modules/globalthis/shim.js"(exports, module2) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill2();
    module2.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define2.supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: true
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});
var require_globalthis = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/globalthis@1.0.3/node_modules/globalthis/index.js"(exports, module2) {
    "use strict";
    var defineProperties = require_define_properties();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim();
    var polyfill = getPolyfill();
    var getGlobal = function() {
      return polyfill;
    };
    defineProperties(getGlobal, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = getGlobal;
  }
});
var require_shim2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-aggregate-error@1.0.11/node_modules/es-aggregate-error/shim.js"(exports, module2) {
    "use strict";
    var define2 = require_define_properties();
    var globalThis2 = require_globalthis()();
    var getPolyfill = require_polyfill();
    module2.exports = function shimAggregateError() {
      var polyfill = getPolyfill();
      define2(
        globalThis2,
        { AggregateError: polyfill },
        {
          AggregateError: function testAggregateError() {
            return globalThis2.AggregateError !== polyfill;
          }
        }
      );
      return polyfill;
    };
  }
});
var require_es_aggregate_error = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/es-aggregate-error@1.0.11/node_modules/es-aggregate-error/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind();
    var define2 = require_define_properties();
    var setFunctionName = require_set_function_name();
    var defineDataProperty = require_define_data_property();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim2();
    var polyfill = getPolyfill();
    var bound = setFunctionName(bind.call(polyfill), polyfill.name, true);
    defineDataProperty(bound, "prototype", polyfill.prototype, true, true, true, true);
    define2(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = bound;
  }
});
var require_connector = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/connector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.connectInParallel = connectInParallel;
    exports.connectInSequence = connectInSequence;
    exports.lookupAllAddresses = lookupAllAddresses;
    var _net = _interopRequireDefault((0, import_chunk_FVJ3R4NJ.__require)("net"));
    var punycode = _interopRequireWildcard((0, import_chunk_FVJ3R4NJ.__require)("punycode"));
    var _abortError = _interopRequireDefault(require_abort_error());
    var _esAggregateError = _interopRequireDefault(require_es_aggregate_error());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function connectInParallel(options, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      const addresses = await lookupAllAddresses(options.host, lookup, signal);
      return await new Promise((resolve, reject) => {
        const sockets = new Array(addresses.length);
        const errors = [];
        function onError(err) {
          errors.push(err);
          this.removeListener("error", onError);
          this.removeListener("connect", onConnect);
          this.destroy();
          if (errors.length === addresses.length) {
            signal.removeEventListener("abort", onAbort);
            reject(new _esAggregateError.default(errors, "Could not connect (parallel)"));
          }
        }
        function onConnect() {
          signal.removeEventListener("abort", onAbort);
          for (let j = 0; j < sockets.length; j++) {
            const socket = sockets[j];
            if (this === socket) {
              continue;
            }
            socket.removeListener("error", onError);
            socket.removeListener("connect", onConnect);
            socket.destroy();
          }
          resolve(this);
        }
        const onAbort = () => {
          for (let j = 0; j < sockets.length; j++) {
            const socket = sockets[j];
            socket.removeListener("error", onError);
            socket.removeListener("connect", onConnect);
            socket.destroy();
          }
          reject(new _abortError.default());
        };
        for (let i = 0, len = addresses.length; i < len; i++) {
          const socket = sockets[i] = _net.default.connect({
            ...options,
            host: addresses[i].address,
            family: addresses[i].family
          });
          socket.on("error", onError);
          socket.on("connect", onConnect);
        }
        signal.addEventListener("abort", onAbort, {
          once: true
        });
      });
    }
    async function connectInSequence(options, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      const errors = [];
      const addresses = await lookupAllAddresses(options.host, lookup, signal);
      for (const address of addresses) {
        try {
          return await new Promise((resolve, reject) => {
            const socket = _net.default.connect({
              ...options,
              host: address.address,
              family: address.family
            });
            const onAbort = () => {
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              socket.destroy();
              reject(new _abortError.default());
            };
            const onError = (err) => {
              signal.removeEventListener("abort", onAbort);
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              socket.destroy();
              reject(err);
            };
            const onConnect = () => {
              signal.removeEventListener("abort", onAbort);
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              resolve(socket);
            };
            signal.addEventListener("abort", onAbort, {
              once: true
            });
            socket.on("error", onError);
            socket.on("connect", onConnect);
          });
        } catch (err) {
          if (err instanceof Error && err.name === "AbortError") {
            throw err;
          }
          errors.push(err);
          continue;
        }
      }
      throw new _esAggregateError.default(errors, "Could not connect (sequence)");
    }
    async function lookupAllAddresses(host, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      if (_net.default.isIPv6(host)) {
        return [{
          address: host,
          family: 6
        }];
      } else if (_net.default.isIPv4(host)) {
        return [{
          address: host,
          family: 4
        }];
      } else {
        return await new Promise((resolve, reject) => {
          const onAbort = () => {
            reject(new _abortError.default());
          };
          signal.addEventListener("abort", onAbort);
          lookup(punycode.toASCII(host), {
            all: true
          }, (err, addresses) => {
            signal.removeEventListener("abort", onAbort);
            err ? reject(err) : resolve(addresses);
          });
        });
      }
    }
  }
});
var require_library = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/library.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.name = void 0;
    var name3 = "Tedious";
    exports.name = name3;
  }
});
var require_ntlm = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/ntlm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createNTLMRequest = createNTLMRequest;
    var NTLMFlags = {
      NTLM_NegotiateUnicode: 1,
      NTLM_NegotiateOEM: 2,
      NTLM_RequestTarget: 4,
      NTLM_Unknown9: 8,
      NTLM_NegotiateSign: 16,
      NTLM_NegotiateSeal: 32,
      NTLM_NegotiateDatagram: 64,
      NTLM_NegotiateLanManagerKey: 128,
      NTLM_Unknown8: 256,
      NTLM_NegotiateNTLM: 512,
      NTLM_NegotiateNTOnly: 1024,
      NTLM_Anonymous: 2048,
      NTLM_NegotiateOemDomainSupplied: 4096,
      NTLM_NegotiateOemWorkstationSupplied: 8192,
      NTLM_Unknown6: 16384,
      NTLM_NegotiateAlwaysSign: 32768,
      NTLM_TargetTypeDomain: 65536,
      NTLM_TargetTypeServer: 131072,
      NTLM_TargetTypeShare: 262144,
      NTLM_NegotiateExtendedSecurity: 524288,
      NTLM_NegotiateIdentify: 1048576,
      NTLM_Unknown5: 2097152,
      NTLM_RequestNonNTSessionKey: 4194304,
      NTLM_NegotiateTargetInfo: 8388608,
      NTLM_Unknown4: 16777216,
      NTLM_NegotiateVersion: 33554432,
      NTLM_Unknown3: 67108864,
      NTLM_Unknown2: 134217728,
      NTLM_Unknown1: 268435456,
      NTLM_Negotiate128: 536870912,
      NTLM_NegotiateKeyExchange: 1073741824,
      NTLM_Negotiate56: 2147483648
    };
    function createNTLMRequest(options) {
      const domain = escape(options.domain.toUpperCase());
      const workstation = options.workstation ? escape(options.workstation.toUpperCase()) : "";
      let type1flags = NTLMFlags.NTLM_NegotiateUnicode + NTLMFlags.NTLM_NegotiateOEM + NTLMFlags.NTLM_RequestTarget + NTLMFlags.NTLM_NegotiateNTLM + NTLMFlags.NTLM_NegotiateOemDomainSupplied + NTLMFlags.NTLM_NegotiateOemWorkstationSupplied + NTLMFlags.NTLM_NegotiateAlwaysSign + NTLMFlags.NTLM_NegotiateVersion + NTLMFlags.NTLM_NegotiateExtendedSecurity + NTLMFlags.NTLM_Negotiate128 + NTLMFlags.NTLM_Negotiate56;
      if (workstation === "") {
        type1flags -= NTLMFlags.NTLM_NegotiateOemWorkstationSupplied;
      }
      const fixedData = Buffer.alloc(40);
      const buffers = [fixedData];
      let offset = 0;
      offset += fixedData.write("NTLMSSP", offset, 7, "ascii");
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt32LE(1, offset);
      offset = fixedData.writeUInt32LE(type1flags, offset);
      offset = fixedData.writeUInt16LE(domain.length, offset);
      offset = fixedData.writeUInt16LE(domain.length, offset);
      offset = fixedData.writeUInt32LE(fixedData.length + workstation.length, offset);
      offset = fixedData.writeUInt16LE(workstation.length, offset);
      offset = fixedData.writeUInt16LE(workstation.length, offset);
      offset = fixedData.writeUInt32LE(fixedData.length, offset);
      offset = fixedData.writeUInt8(5, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt16LE(2195, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt8(0, offset);
      fixedData.writeUInt8(15, offset);
      buffers.push(Buffer.from(workstation, "ascii"));
      buffers.push(Buffer.from(domain, "ascii"));
      return Buffer.concat(buffers);
    }
  }
});
var require_bulk_load_payload = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/bulk-load-payload.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BulkLoadPayload = void 0;
    var BulkLoadPayload = class {
      constructor(bulkLoad) {
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "bulkLoad");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "iterator");
        this.bulkLoad = bulkLoad;
        this.iterator = this.bulkLoad.rowToPacketTransform[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterator;
      }
      toString(indent = "") {
        return indent + "BulkLoad";
      }
    };
    exports.BulkLoadPayload = BulkLoadPayload;
  }
});
var require_special_stored_procedure = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/special-stored-procedure.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var procedures = {
      Sp_Cursor: 1,
      Sp_CursorOpen: 2,
      Sp_CursorPrepare: 3,
      Sp_CursorExecute: 4,
      Sp_CursorPrepExec: 5,
      Sp_CursorUnprepare: 6,
      Sp_CursorFetch: 7,
      Sp_CursorOption: 8,
      Sp_CursorClose: 9,
      Sp_ExecuteSql: 10,
      Sp_Prepare: 11,
      Sp_Execute: 12,
      Sp_PrepExec: 13,
      Sp_PrepExecRpc: 14,
      Sp_Unprepare: 15
    };
    var _default = procedures;
    exports.default = _default;
    module2.exports = procedures;
  }
});
var require_package = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/package.json"(exports, module2) {
    module2.exports = {
      author: "Mike D Pilsbury <mike.pilsbury@gmail.com>",
      contributors: [
        "Alex Robson",
        "Arthur Schreiber",
        "Bret Copeland <bret@atlantisflight.org> (https://github.com/bretcope)",
        "Bryan Ross <bryan@rossipedia.com> (https://github.com/rossipedia)",
        "Ciaran Jessup <ciaranj@gmail.com>",
        "Cort Fritz <cfritz@caa.com>",
        "lastonesky",
        "Patrik Simek <patrik@patriksimek.cz>",
        "Phil Dodderidge <pdodde@poyntz.com>",
        "Zach Aller"
      ],
      name: "tedious",
      description: "A TDS driver, for connecting to MS SQLServer databases.",
      keywords: [
        "sql",
        "database",
        "mssql",
        "sqlserver",
        "sql-server",
        "tds",
        "msnodesql",
        "azure"
      ],
      homepage: "https://github.com/tediousjs/tedious",
      bugs: "https://github.com/tediousjs/tedious/issues",
      license: "MIT",
      version: "16.4.1",
      main: "./lib/tedious.js",
      repository: {
        type: "git",
        url: "https://github.com/tediousjs/tedious.git"
      },
      engines: {
        node: ">=16"
      },
      publishConfig: {
        tag: "next"
      },
      dependencies: {
        "@azure/identity": "^2.0.4",
        "@azure/keyvault-keys": "^4.4.0",
        "@js-joda/core": "^5.5.3",
        bl: "^6.0.3",
        "es-aggregate-error": "^1.0.9",
        "iconv-lite": "^0.6.3",
        "js-md4": "^0.3.2",
        jsbi: "^4.3.0",
        "native-duplexpair": "^1.0.0",
        "node-abort-controller": "^3.1.1",
        punycode: "^2.3.0",
        "sprintf-js": "^1.1.2"
      },
      devDependencies: {
        "@babel/cli": "^7.22.9",
        "@babel/core": "^7.22.9",
        "@babel/node": "^7.22.6",
        "@babel/preset-env": "^7.22.9",
        "@babel/preset-typescript": "^7.22.5",
        "@babel/register": "^7.22.5",
        "@types/async": "^3.2.20",
        "@types/bl": "^5.1.0",
        "@types/chai": "^4.3.5",
        "@types/depd": "^1.1.32",
        "@types/es-aggregate-error": "^1.0.2",
        "@types/lru-cache": "^5.1.1",
        "@types/mocha": "^10.0.1",
        "@types/node": "^16.18.38",
        "@types/sprintf-js": "^1.1.2",
        "@typescript-eslint/eslint-plugin": "^6.0.0",
        "@typescript-eslint/parser": "^6.0.0",
        async: "^3.2.4",
        "babel-plugin-istanbul": "^6.1.1",
        chai: "^4.3.7",
        codecov: "^3.8.3",
        eslint: "^8.45.0",
        mitm: "^1.7.2",
        mocha: "^10.2.0",
        nyc: "^15.1.0",
        rimraf: "^5.0.1",
        "semantic-release": "^19.0.3",
        sinon: "^15.2.0",
        typedoc: "^0.24.8",
        typescript: "^5.1.6"
      },
      scripts: {
        docs: "typedoc",
        lint: "eslint src test --ext .js,.ts && tsc",
        test: "mocha test/unit test/unit/token test/unit/tracking-buffer",
        "test-integration": "mocha test/integration/",
        "test-all": "mocha test/unit/ test/unit/token/ test/unit/tracking-buffer test/integration/",
        build: "rimraf lib && babel src --out-dir lib --extensions .js,.ts",
        prepublish: "npm run build",
        "semantic-release": "semantic-release"
      },
      babel: {
        sourceMaps: "both",
        ignore: [
          "./src/**/*.d.ts"
        ],
        presets: [
          [
            "@babel/preset-env",
            {
              targets: {
                node: 16
              }
            }
          ],
          [
            "@babel/preset-typescript",
            {
              allowDeclareFields: true
            }
          ]
        ],
        plugins: [
          [
            "@babel/transform-typescript",
            {
              allowDeclareFields: true
            }
          ]
        ]
      },
      mocha: {
        require: "test/setup.js",
        timeout: 5e3,
        extension: [
          "js",
          "ts"
        ]
      },
      nyc: {
        sourceMap: false,
        instrument: false,
        extension: [
          ".ts"
        ]
      }
    };
  }
});
var require_handler = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/token/handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UnexpectedTokenError = exports.TokenHandler = exports.RequestTokenHandler = exports.Login7TokenHandler = exports.InitialSqlTokenHandler = exports.AttentionTokenHandler = void 0;
    var _request = _interopRequireDefault(require_request2());
    var _errors = require_errors();
    var _esAggregateError = _interopRequireDefault(require_es_aggregate_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var UnexpectedTokenError = class extends Error {
      constructor(handler, token) {
        super("Unexpected token `" + token.name + "` in `" + handler.constructor.name + "`");
      }
    };
    exports.UnexpectedTokenError = UnexpectedTokenError;
    var TokenHandler = class {
      onInfoMessage(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onErrorMessage(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onSSPI(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDatabaseChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onLanguageChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onCharsetChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onSqlCollationChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRoutingChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onPacketSizeChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onResetConnection(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onBeginTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onCommitTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRollbackTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onFedAuthInfo(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onFeatureExtAck(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onLoginAck(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onColMetadata(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onOrder(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRow(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onReturnStatus(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onReturnValue(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDoneProc(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDoneInProc(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDone(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDatabaseMirroringPartner(token) {
        throw new UnexpectedTokenError(this, token);
      }
    };
    exports.TokenHandler = TokenHandler;
    var InitialSqlTokenHandler = class extends TokenHandler {
      constructor(connection) {
        super();
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "connection");
        this.connection = connection;
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onBeginTransaction(token) {
        this.connection.transactionDescriptors.push(token.newValue);
        this.connection.inTransaction = true;
      }
      onCommitTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
      }
      onRollbackTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
        this.connection.emit("rollbackTransaction");
      }
      onColMetadata(token) {
        this.connection.emit("error", new Error("Received 'columnMetadata' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onOrder(token) {
        this.connection.emit("error", new Error("Received 'order' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onRow(token) {
        this.connection.emit("error", new Error("Received 'row' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onReturnStatus(token) {
      }
      onReturnValue(token) {
      }
      onDoneProc(token) {
      }
      onDoneInProc(token) {
      }
      onDone(token) {
      }
      onResetConnection(token) {
        this.connection.emit("resetConnection");
      }
    };
    exports.InitialSqlTokenHandler = InitialSqlTokenHandler;
    var Login7TokenHandler = class extends TokenHandler {
      constructor(connection) {
        super();
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "connection");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "fedAuthInfoToken");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "routingData");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "loginAckReceived", false);
        this.connection = connection;
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
        const error = new _errors.ConnectionError(token.message, "ELOGIN");
        const isLoginErrorTransient = this.connection.transientErrorLookup.isTransientError(token.number);
        if (isLoginErrorTransient && this.connection.curTransientRetryCount !== this.connection.config.options.maxRetriesOnTransientErrors) {
          error.isTransient = true;
        }
        this.connection.loginError = error;
      }
      onSSPI(token) {
        if (token.ntlmpacket) {
          this.connection.ntlmpacket = token.ntlmpacket;
          this.connection.ntlmpacketBuffer = token.ntlmpacketBuffer;
        }
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onFedAuthInfo(token) {
        this.fedAuthInfoToken = token;
      }
      onFeatureExtAck(token) {
        const {
          authentication
        } = this.connection.config;
        if (authentication.type === "azure-active-directory-password" || authentication.type === "azure-active-directory-access-token" || authentication.type === "azure-active-directory-msi-vm" || authentication.type === "azure-active-directory-msi-app-service" || authentication.type === "azure-active-directory-service-principal-secret" || authentication.type === "azure-active-directory-default") {
          if (token.fedAuth === void 0) {
            this.connection.loginError = new _errors.ConnectionError("Did not receive Active Directory authentication acknowledgement");
          } else if (token.fedAuth.length !== 0) {
            this.connection.loginError = new _errors.ConnectionError(`Active Directory authentication acknowledgment for ${authentication.type} authentication method includes extra data`);
          }
        } else if (token.fedAuth === void 0 && token.utf8Support === void 0) {
          this.connection.loginError = new _errors.ConnectionError("Received acknowledgement for unknown feature");
        } else if (token.fedAuth) {
          this.connection.loginError = new _errors.ConnectionError("Did not request Active Directory authentication, but received the acknowledgment");
        }
      }
      onLoginAck(token) {
        if (!token.tdsVersion) {
          this.connection.loginError = new _errors.ConnectionError("Server responded with unknown TDS version.", "ETDS");
          return;
        }
        if (!token.interface) {
          this.connection.loginError = new _errors.ConnectionError("Server responded with unsupported interface.", "EINTERFACENOTSUPP");
          return;
        }
        this.connection.config.options.tdsVersion = token.tdsVersion;
        this.loginAckReceived = true;
      }
      onRoutingChange(token) {
        const [server] = token.newValue.server.split("\\");
        this.routingData = {
          server,
          port: token.newValue.port
        };
      }
      onDoneInProc(token) {
      }
      onDone(token) {
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onDatabaseMirroringPartner(token) {
      }
    };
    exports.Login7TokenHandler = Login7TokenHandler;
    var RequestTokenHandler = class extends TokenHandler {
      constructor(connection, request3) {
        super();
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "connection");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "request");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "errors");
        this.connection = connection;
        this.request = request3;
        this.errors = [];
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
        if (!this.request.canceled) {
          const error = new _errors.RequestError(token.message, "EREQUEST");
          error.number = token.number;
          error.state = token.state;
          error.class = token.class;
          error.serverName = token.serverName;
          error.procName = token.procName;
          error.lineNumber = token.lineNumber;
          this.errors.push(error);
          this.request.error = error;
          if (this.request instanceof _request.default && this.errors.length > 1) {
            this.request.error = new _esAggregateError.default(this.errors);
          }
        }
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onBeginTransaction(token) {
        this.connection.transactionDescriptors.push(token.newValue);
        this.connection.inTransaction = true;
      }
      onCommitTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
      }
      onRollbackTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
        this.connection.emit("rollbackTransaction");
      }
      onColMetadata(token) {
        if (!this.request.canceled) {
          if (this.connection.config.options.useColumnNames) {
            const columns = /* @__PURE__ */ Object.create(null);
            for (let j = 0, len = token.columns.length; j < len; j++) {
              const col = token.columns[j];
              if (columns[col.colName] == null) {
                columns[col.colName] = col;
              }
            }
            this.request.emit("columnMetadata", columns);
          } else {
            this.request.emit("columnMetadata", token.columns);
          }
        }
      }
      onOrder(token) {
        if (!this.request.canceled) {
          this.request.emit("order", token.orderColumns);
        }
      }
      onRow(token) {
        if (!this.request.canceled) {
          if (this.connection.config.options.rowCollectionOnRequestCompletion) {
            this.request.rows.push(token.columns);
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst.push(token.columns);
          }
          this.request.emit("row", token.columns);
        }
      }
      onReturnStatus(token) {
        if (!this.request.canceled) {
          this.connection.procReturnStatusValue = token.value;
        }
      }
      onReturnValue(token) {
        if (!this.request.canceled) {
          this.request.emit("returnValue", token.paramName, token.value, token.metadata);
        }
      }
      onDoneProc(token) {
        if (!this.request.canceled) {
          if (token.sqlError && !this.request.error) {
            this.request.error = new _errors.RequestError("An unknown error has occurred.", "UNKNOWN");
          }
          this.request.emit("doneProc", token.rowCount, token.more, this.connection.procReturnStatusValue, this.request.rst);
          this.connection.procReturnStatusValue = void 0;
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onDoneInProc(token) {
        if (!this.request.canceled) {
          this.request.emit("doneInProc", token.rowCount, token.more, this.request.rst);
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onDone(token) {
        if (!this.request.canceled) {
          if (token.sqlError && !this.request.error) {
            this.request.error = new _errors.RequestError("An unknown error has occurred.", "UNKNOWN");
          }
          this.request.emit("done", token.rowCount, token.more, this.request.rst);
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onResetConnection(token) {
        this.connection.emit("resetConnection");
      }
    };
    exports.RequestTokenHandler = RequestTokenHandler;
    var AttentionTokenHandler = class extends TokenHandler {
      constructor(connection, request3) {
        super();
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "connection");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "request");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "attentionReceived");
        this.connection = connection;
        this.request = request3;
        this.attentionReceived = false;
      }
      onDone(token) {
        if (token.attention) {
          this.attentionReceived = true;
        }
      }
    };
    exports.AttentionTokenHandler = AttentionTokenHandler;
  }
});
var require_connection = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/connection.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault((0, import_chunk_FVJ3R4NJ.__require)("crypto"));
    var _os = _interopRequireDefault((0, import_chunk_FVJ3R4NJ.__require)("os"));
    var tls = _interopRequireWildcard((0, import_chunk_FVJ3R4NJ.__require)("tls"));
    var net = _interopRequireWildcard((0, import_chunk_FVJ3R4NJ.__require)("net"));
    var _dns = _interopRequireDefault((0, import_chunk_FVJ3R4NJ.__require)("dns"));
    var _constants = _interopRequireDefault((0, import_chunk_FVJ3R4NJ.__require)("constants"));
    var _stream = (0, import_chunk_FVJ3R4NJ.__require)("stream");
    var _identity = (init_src7(), (0, import_chunk_FVJ3R4NJ.__toCommonJS)(src_exports));
    var _bulkLoad = _interopRequireDefault(require_bulk_load());
    var _debug = _interopRequireDefault(require_debug());
    var _events = (0, import_chunk_FVJ3R4NJ.__require)("events");
    var _instanceLookup = require_instance_lookup();
    var _transientErrorLookup = require_transient_error_lookup();
    var _packet = require_packet();
    var _preloginPayload = _interopRequireDefault(require_prelogin_payload());
    var _login7Payload = _interopRequireDefault(require_login7_payload());
    var _ntlmPayload = _interopRequireDefault(require_ntlm_payload());
    var _request = _interopRequireDefault(require_request2());
    var _rpcrequestPayload = _interopRequireDefault(require_rpcrequest_payload());
    var _sqlbatchPayload = _interopRequireDefault(require_sqlbatch_payload());
    var _messageIo = _interopRequireDefault(require_message_io());
    var _tokenStreamParser = require_token_stream_parser();
    var _transaction = require_transaction2();
    var _errors = require_errors();
    var _connector = require_connector();
    var _library = require_library();
    var _tdsVersions = require_tds_versions();
    var _message = _interopRequireDefault(require_message());
    var _ntlm = require_ntlm();
    var _nodeAbortController = require_node_abort_controller();
    var _dataType = require_data_type();
    var _bulkLoadPayload = require_bulk_load_payload();
    var _specialStoredProcedure = _interopRequireDefault(require_special_stored_procedure());
    var _esAggregateError = _interopRequireDefault(require_es_aggregate_error());
    var _package = require_package();
    var _url = (0, import_chunk_FVJ3R4NJ.__require)("url");
    var _handler = require_handler();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var KEEP_ALIVE_INITIAL_DELAY = 30 * 1e3;
    var DEFAULT_CONNECT_TIMEOUT = 15 * 1e3;
    var DEFAULT_CLIENT_REQUEST_TIMEOUT = 15 * 1e3;
    var DEFAULT_CANCEL_TIMEOUT = 5 * 1e3;
    var DEFAULT_CONNECT_RETRY_INTERVAL = 500;
    var DEFAULT_PACKET_SIZE = 4 * 1024;
    var DEFAULT_TEXTSIZE = 2147483647;
    var DEFAULT_DATEFIRST = 7;
    var DEFAULT_PORT = 1433;
    var DEFAULT_TDS_VERSION = "7_4";
    var DEFAULT_LANGUAGE = "us_english";
    var DEFAULT_DATEFORMAT = "mdy";
    var CLEANUP_TYPE = {
      NORMAL: 0,
      REDIRECT: 1,
      RETRY: 2
    };
    var Connection = class extends _events.EventEmitter {
      /**
       * Note: be aware of the different options field:
       * 1. config.authentication.options
       * 2. config.options
       *
       * ```js
       * const { Connection } = require('tedious');
       *
       * const config = {
       *  "authentication": {
       *    ...,
       *    "options": {...}
       *  },
       *  "options": {...}
       * };
       *
       * const connection = new Connection(config);
       * ```
       *
       * @param config
       */
      constructor(config) {
        super();
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "fedAuthRequired");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "config");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "secureContextOptions");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "inTransaction");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "transactionDescriptors");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "transactionDepth");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "isSqlBatch");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "curTransientRetryCount");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "transientErrorLookup");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "closed");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "loginError");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "debug");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "ntlmpacket");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "ntlmpacketBuffer");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "routingData");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "messageIo");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "state");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "resetConnectionOnNextRequest");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "request");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "procReturnStatusValue");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "socket");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "messageBuffer");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "connectTimer");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "cancelTimer");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "requestTimer");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "retryTimer");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "_cancelAfterRequestSent");
        (0, import_chunk_FVJ3R4NJ.__publicField)(this, "databaseCollation");
        if (typeof config !== "object" || config === null) {
          throw new TypeError('The "config" argument is required and must be of type Object.');
        }
        if (typeof config.server !== "string") {
          throw new TypeError('The "config.server" property is required and must be of type string.');
        }
        this.fedAuthRequired = false;
        let authentication;
        if (config.authentication !== void 0) {
          if (typeof config.authentication !== "object" || config.authentication === null) {
            throw new TypeError('The "config.authentication" property must be of type Object.');
          }
          const type2 = config.authentication.type;
          const options = config.authentication.options === void 0 ? {} : config.authentication.options;
          if (typeof type2 !== "string") {
            throw new TypeError('The "config.authentication.type" property must be of type string.');
          }
          if (type2 !== "default" && type2 !== "ntlm" && type2 !== "azure-active-directory-password" && type2 !== "azure-active-directory-access-token" && type2 !== "azure-active-directory-msi-vm" && type2 !== "azure-active-directory-msi-app-service" && type2 !== "azure-active-directory-service-principal-secret" && type2 !== "azure-active-directory-default") {
            throw new TypeError('The "type" property must one of "default", "ntlm", "azure-active-directory-password", "azure-active-directory-access-token", "azure-active-directory-default", "azure-active-directory-msi-vm" or "azure-active-directory-msi-app-service" or "azure-active-directory-service-principal-secret".');
          }
          if (typeof options !== "object" || options === null) {
            throw new TypeError('The "config.authentication.options" property must be of type object.');
          }
          if (type2 === "ntlm") {
            if (typeof options.domain !== "string") {
              throw new TypeError('The "config.authentication.options.domain" property must be of type string.');
            }
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            authentication = {
              type: "ntlm",
              options: {
                userName: options.userName,
                password: options.password,
                domain: options.domain && options.domain.toUpperCase()
              }
            };
          } else if (type2 === "azure-active-directory-password") {
            if (typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            if (options.tenantId !== void 0 && typeof options.tenantId !== "string") {
              throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-password",
              options: {
                userName: options.userName,
                password: options.password,
                tenantId: options.tenantId,
                clientId: options.clientId
              }
            };
          } else if (type2 === "azure-active-directory-access-token") {
            if (typeof options.token !== "string") {
              throw new TypeError('The "config.authentication.options.token" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-access-token",
              options: {
                token: options.token
              }
            };
          } else if (type2 === "azure-active-directory-msi-vm") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-msi-vm",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type2 === "azure-active-directory-default") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-default",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type2 === "azure-active-directory-msi-app-service") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-msi-app-service",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type2 === "azure-active-directory-service-principal-secret") {
            if (typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            if (typeof options.clientSecret !== "string") {
              throw new TypeError('The "config.authentication.options.clientSecret" property must be of type string.');
            }
            if (typeof options.tenantId !== "string") {
              throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-service-principal-secret",
              options: {
                clientId: options.clientId,
                clientSecret: options.clientSecret,
                tenantId: options.tenantId
              }
            };
          } else {
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            authentication = {
              type: "default",
              options: {
                userName: options.userName,
                password: options.password
              }
            };
          }
        } else {
          authentication = {
            type: "default",
            options: {
              userName: void 0,
              password: void 0
            }
          };
        }
        this.config = {
          server: config.server,
          authentication,
          options: {
            abortTransactionOnError: false,
            appName: void 0,
            camelCaseColumns: false,
            cancelTimeout: DEFAULT_CANCEL_TIMEOUT,
            columnEncryptionKeyCacheTTL: 2 * 60 * 60 * 1e3,
            // Units: miliseconds
            columnEncryptionSetting: false,
            columnNameReplacer: void 0,
            connectionRetryInterval: DEFAULT_CONNECT_RETRY_INTERVAL,
            connectTimeout: DEFAULT_CONNECT_TIMEOUT,
            connector: void 0,
            connectionIsolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
            cryptoCredentialsDetails: {},
            database: void 0,
            datefirst: DEFAULT_DATEFIRST,
            dateFormat: DEFAULT_DATEFORMAT,
            debug: {
              data: false,
              packet: false,
              payload: false,
              token: false
            },
            enableAnsiNull: true,
            enableAnsiNullDefault: true,
            enableAnsiPadding: true,
            enableAnsiWarnings: true,
            enableArithAbort: true,
            enableConcatNullYieldsNull: true,
            enableCursorCloseOnCommit: null,
            enableImplicitTransactions: false,
            enableNumericRoundabort: false,
            enableQuotedIdentifier: true,
            encrypt: true,
            fallbackToDefaultDb: false,
            encryptionKeyStoreProviders: void 0,
            instanceName: void 0,
            isolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
            language: DEFAULT_LANGUAGE,
            localAddress: void 0,
            maxRetriesOnTransientErrors: 3,
            multiSubnetFailover: false,
            packetSize: DEFAULT_PACKET_SIZE,
            port: DEFAULT_PORT,
            readOnlyIntent: false,
            requestTimeout: DEFAULT_CLIENT_REQUEST_TIMEOUT,
            rowCollectionOnDone: false,
            rowCollectionOnRequestCompletion: false,
            serverName: void 0,
            serverSupportsColumnEncryption: false,
            tdsVersion: DEFAULT_TDS_VERSION,
            textsize: DEFAULT_TEXTSIZE,
            trustedServerNameAE: void 0,
            trustServerCertificate: false,
            useColumnNames: false,
            useUTC: true,
            workstationId: void 0,
            lowerCaseGuids: false
          }
        };
        if (config.options) {
          if (config.options.port && config.options.instanceName) {
            throw new Error("Port and instanceName are mutually exclusive, but " + config.options.port + " and " + config.options.instanceName + " provided");
          }
          if (config.options.abortTransactionOnError !== void 0) {
            if (typeof config.options.abortTransactionOnError !== "boolean" && config.options.abortTransactionOnError !== null) {
              throw new TypeError('The "config.options.abortTransactionOnError" property must be of type string or null.');
            }
            this.config.options.abortTransactionOnError = config.options.abortTransactionOnError;
          }
          if (config.options.appName !== void 0) {
            if (typeof config.options.appName !== "string") {
              throw new TypeError('The "config.options.appName" property must be of type string.');
            }
            this.config.options.appName = config.options.appName;
          }
          if (config.options.camelCaseColumns !== void 0) {
            if (typeof config.options.camelCaseColumns !== "boolean") {
              throw new TypeError('The "config.options.camelCaseColumns" property must be of type boolean.');
            }
            this.config.options.camelCaseColumns = config.options.camelCaseColumns;
          }
          if (config.options.cancelTimeout !== void 0) {
            if (typeof config.options.cancelTimeout !== "number") {
              throw new TypeError('The "config.options.cancelTimeout" property must be of type number.');
            }
            this.config.options.cancelTimeout = config.options.cancelTimeout;
          }
          if (config.options.columnNameReplacer) {
            if (typeof config.options.columnNameReplacer !== "function") {
              throw new TypeError('The "config.options.cancelTimeout" property must be of type function.');
            }
            this.config.options.columnNameReplacer = config.options.columnNameReplacer;
          }
          if (config.options.connectionIsolationLevel !== void 0) {
            (0, _transaction.assertValidIsolationLevel)(config.options.connectionIsolationLevel, "config.options.connectionIsolationLevel");
            this.config.options.connectionIsolationLevel = config.options.connectionIsolationLevel;
          }
          if (config.options.connectTimeout !== void 0) {
            if (typeof config.options.connectTimeout !== "number") {
              throw new TypeError('The "config.options.connectTimeout" property must be of type number.');
            }
            this.config.options.connectTimeout = config.options.connectTimeout;
          }
          if (config.options.connector !== void 0) {
            if (typeof config.options.connector !== "function") {
              throw new TypeError('The "config.options.connector" property must be a function.');
            }
            this.config.options.connector = config.options.connector;
          }
          if (config.options.cryptoCredentialsDetails !== void 0) {
            if (typeof config.options.cryptoCredentialsDetails !== "object" || config.options.cryptoCredentialsDetails === null) {
              throw new TypeError('The "config.options.cryptoCredentialsDetails" property must be of type Object.');
            }
            this.config.options.cryptoCredentialsDetails = config.options.cryptoCredentialsDetails;
          }
          if (config.options.database !== void 0) {
            if (typeof config.options.database !== "string") {
              throw new TypeError('The "config.options.database" property must be of type string.');
            }
            this.config.options.database = config.options.database;
          }
          if (config.options.datefirst !== void 0) {
            if (typeof config.options.datefirst !== "number" && config.options.datefirst !== null) {
              throw new TypeError('The "config.options.datefirst" property must be of type number.');
            }
            if (config.options.datefirst !== null && (config.options.datefirst < 1 || config.options.datefirst > 7)) {
              throw new RangeError('The "config.options.datefirst" property must be >= 1 and <= 7');
            }
            this.config.options.datefirst = config.options.datefirst;
          }
          if (config.options.dateFormat !== void 0) {
            if (typeof config.options.dateFormat !== "string" && config.options.dateFormat !== null) {
              throw new TypeError('The "config.options.dateFormat" property must be of type string or null.');
            }
            this.config.options.dateFormat = config.options.dateFormat;
          }
          if (config.options.debug) {
            if (config.options.debug.data !== void 0) {
              if (typeof config.options.debug.data !== "boolean") {
                throw new TypeError('The "config.options.debug.data" property must be of type boolean.');
              }
              this.config.options.debug.data = config.options.debug.data;
            }
            if (config.options.debug.packet !== void 0) {
              if (typeof config.options.debug.packet !== "boolean") {
                throw new TypeError('The "config.options.debug.packet" property must be of type boolean.');
              }
              this.config.options.debug.packet = config.options.debug.packet;
            }
            if (config.options.debug.payload !== void 0) {
              if (typeof config.options.debug.payload !== "boolean") {
                throw new TypeError('The "config.options.debug.payload" property must be of type boolean.');
              }
              this.config.options.debug.payload = config.options.debug.payload;
            }
            if (config.options.debug.token !== void 0) {
              if (typeof config.options.debug.token !== "boolean") {
                throw new TypeError('The "config.options.debug.token" property must be of type boolean.');
              }
              this.config.options.debug.token = config.options.debug.token;
            }
          }
          if (config.options.enableAnsiNull !== void 0) {
            if (typeof config.options.enableAnsiNull !== "boolean" && config.options.enableAnsiNull !== null) {
              throw new TypeError('The "config.options.enableAnsiNull" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiNull = config.options.enableAnsiNull;
          }
          if (config.options.enableAnsiNullDefault !== void 0) {
            if (typeof config.options.enableAnsiNullDefault !== "boolean" && config.options.enableAnsiNullDefault !== null) {
              throw new TypeError('The "config.options.enableAnsiNullDefault" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiNullDefault = config.options.enableAnsiNullDefault;
          }
          if (config.options.enableAnsiPadding !== void 0) {
            if (typeof config.options.enableAnsiPadding !== "boolean" && config.options.enableAnsiPadding !== null) {
              throw new TypeError('The "config.options.enableAnsiPadding" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiPadding = config.options.enableAnsiPadding;
          }
          if (config.options.enableAnsiWarnings !== void 0) {
            if (typeof config.options.enableAnsiWarnings !== "boolean" && config.options.enableAnsiWarnings !== null) {
              throw new TypeError('The "config.options.enableAnsiWarnings" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiWarnings = config.options.enableAnsiWarnings;
          }
          if (config.options.enableArithAbort !== void 0) {
            if (typeof config.options.enableArithAbort !== "boolean" && config.options.enableArithAbort !== null) {
              throw new TypeError('The "config.options.enableArithAbort" property must be of type boolean or null.');
            }
            this.config.options.enableArithAbort = config.options.enableArithAbort;
          }
          if (config.options.enableConcatNullYieldsNull !== void 0) {
            if (typeof config.options.enableConcatNullYieldsNull !== "boolean" && config.options.enableConcatNullYieldsNull !== null) {
              throw new TypeError('The "config.options.enableConcatNullYieldsNull" property must be of type boolean or null.');
            }
            this.config.options.enableConcatNullYieldsNull = config.options.enableConcatNullYieldsNull;
          }
          if (config.options.enableCursorCloseOnCommit !== void 0) {
            if (typeof config.options.enableCursorCloseOnCommit !== "boolean" && config.options.enableCursorCloseOnCommit !== null) {
              throw new TypeError('The "config.options.enableCursorCloseOnCommit" property must be of type boolean or null.');
            }
            this.config.options.enableCursorCloseOnCommit = config.options.enableCursorCloseOnCommit;
          }
          if (config.options.enableImplicitTransactions !== void 0) {
            if (typeof config.options.enableImplicitTransactions !== "boolean" && config.options.enableImplicitTransactions !== null) {
              throw new TypeError('The "config.options.enableImplicitTransactions" property must be of type boolean or null.');
            }
            this.config.options.enableImplicitTransactions = config.options.enableImplicitTransactions;
          }
          if (config.options.enableNumericRoundabort !== void 0) {
            if (typeof config.options.enableNumericRoundabort !== "boolean" && config.options.enableNumericRoundabort !== null) {
              throw new TypeError('The "config.options.enableNumericRoundabort" property must be of type boolean or null.');
            }
            this.config.options.enableNumericRoundabort = config.options.enableNumericRoundabort;
          }
          if (config.options.enableQuotedIdentifier !== void 0) {
            if (typeof config.options.enableQuotedIdentifier !== "boolean" && config.options.enableQuotedIdentifier !== null) {
              throw new TypeError('The "config.options.enableQuotedIdentifier" property must be of type boolean or null.');
            }
            this.config.options.enableQuotedIdentifier = config.options.enableQuotedIdentifier;
          }
          if (config.options.encrypt !== void 0) {
            if (typeof config.options.encrypt !== "boolean") {
              if (config.options.encrypt !== "strict") {
                throw new TypeError('The "encrypt" property must be set to "strict", or of type boolean.');
              }
            }
            this.config.options.encrypt = config.options.encrypt;
          }
          if (config.options.fallbackToDefaultDb !== void 0) {
            if (typeof config.options.fallbackToDefaultDb !== "boolean") {
              throw new TypeError('The "config.options.fallbackToDefaultDb" property must be of type boolean.');
            }
            this.config.options.fallbackToDefaultDb = config.options.fallbackToDefaultDb;
          }
          if (config.options.instanceName !== void 0) {
            if (typeof config.options.instanceName !== "string") {
              throw new TypeError('The "config.options.instanceName" property must be of type string.');
            }
            this.config.options.instanceName = config.options.instanceName;
            this.config.options.port = void 0;
          }
          if (config.options.isolationLevel !== void 0) {
            (0, _transaction.assertValidIsolationLevel)(config.options.isolationLevel, "config.options.isolationLevel");
            this.config.options.isolationLevel = config.options.isolationLevel;
          }
          if (config.options.language !== void 0) {
            if (typeof config.options.language !== "string" && config.options.language !== null) {
              throw new TypeError('The "config.options.language" property must be of type string or null.');
            }
            this.config.options.language = config.options.language;
          }
          if (config.options.localAddress !== void 0) {
            if (typeof config.options.localAddress !== "string") {
              throw new TypeError('The "config.options.localAddress" property must be of type string.');
            }
            this.config.options.localAddress = config.options.localAddress;
          }
          if (config.options.multiSubnetFailover !== void 0) {
            if (typeof config.options.multiSubnetFailover !== "boolean") {
              throw new TypeError('The "config.options.multiSubnetFailover" property must be of type boolean.');
            }
            this.config.options.multiSubnetFailover = config.options.multiSubnetFailover;
          }
          if (config.options.packetSize !== void 0) {
            if (typeof config.options.packetSize !== "number") {
              throw new TypeError('The "config.options.packetSize" property must be of type number.');
            }
            this.config.options.packetSize = config.options.packetSize;
          }
          if (config.options.port !== void 0) {
            if (typeof config.options.port !== "number") {
              throw new TypeError('The "config.options.port" property must be of type number.');
            }
            if (config.options.port <= 0 || config.options.port >= 65536) {
              throw new RangeError('The "config.options.port" property must be > 0 and < 65536');
            }
            this.config.options.port = config.options.port;
            this.config.options.instanceName = void 0;
          }
          if (config.options.readOnlyIntent !== void 0) {
            if (typeof config.options.readOnlyIntent !== "boolean") {
              throw new TypeError('The "config.options.readOnlyIntent" property must be of type boolean.');
            }
            this.config.options.readOnlyIntent = config.options.readOnlyIntent;
          }
          if (config.options.requestTimeout !== void 0) {
            if (typeof config.options.requestTimeout !== "number") {
              throw new TypeError('The "config.options.requestTimeout" property must be of type number.');
            }
            this.config.options.requestTimeout = config.options.requestTimeout;
          }
          if (config.options.maxRetriesOnTransientErrors !== void 0) {
            if (typeof config.options.maxRetriesOnTransientErrors !== "number") {
              throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be of type number.');
            }
            if (config.options.maxRetriesOnTransientErrors < 0) {
              throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be equal or greater than 0.');
            }
            this.config.options.maxRetriesOnTransientErrors = config.options.maxRetriesOnTransientErrors;
          }
          if (config.options.connectionRetryInterval !== void 0) {
            if (typeof config.options.connectionRetryInterval !== "number") {
              throw new TypeError('The "config.options.connectionRetryInterval" property must be of type number.');
            }
            if (config.options.connectionRetryInterval <= 0) {
              throw new TypeError('The "config.options.connectionRetryInterval" property must be greater than 0.');
            }
            this.config.options.connectionRetryInterval = config.options.connectionRetryInterval;
          }
          if (config.options.rowCollectionOnDone !== void 0) {
            if (typeof config.options.rowCollectionOnDone !== "boolean") {
              throw new TypeError('The "config.options.rowCollectionOnDone" property must be of type boolean.');
            }
            this.config.options.rowCollectionOnDone = config.options.rowCollectionOnDone;
          }
          if (config.options.rowCollectionOnRequestCompletion !== void 0) {
            if (typeof config.options.rowCollectionOnRequestCompletion !== "boolean") {
              throw new TypeError('The "config.options.rowCollectionOnRequestCompletion" property must be of type boolean.');
            }
            this.config.options.rowCollectionOnRequestCompletion = config.options.rowCollectionOnRequestCompletion;
          }
          if (config.options.tdsVersion !== void 0) {
            if (typeof config.options.tdsVersion !== "string") {
              throw new TypeError('The "config.options.tdsVersion" property must be of type string.');
            }
            this.config.options.tdsVersion = config.options.tdsVersion;
          }
          if (config.options.textsize !== void 0) {
            if (typeof config.options.textsize !== "number" && config.options.textsize !== null) {
              throw new TypeError('The "config.options.textsize" property must be of type number or null.');
            }
            if (config.options.textsize > 2147483647) {
              throw new TypeError(`The "config.options.textsize" can't be greater than 2147483647.`);
            } else if (config.options.textsize < -1) {
              throw new TypeError(`The "config.options.textsize" can't be smaller than -1.`);
            }
            this.config.options.textsize = config.options.textsize | 0;
          }
          if (config.options.trustServerCertificate !== void 0) {
            if (typeof config.options.trustServerCertificate !== "boolean") {
              throw new TypeError('The "config.options.trustServerCertificate" property must be of type boolean.');
            }
            this.config.options.trustServerCertificate = config.options.trustServerCertificate;
          }
          if (config.options.serverName !== void 0) {
            if (typeof config.options.serverName !== "string") {
              throw new TypeError('The "config.options.serverName" property must be of type string.');
            }
            this.config.options.serverName = config.options.serverName;
          }
          if (config.options.useColumnNames !== void 0) {
            if (typeof config.options.useColumnNames !== "boolean") {
              throw new TypeError('The "config.options.useColumnNames" property must be of type boolean.');
            }
            this.config.options.useColumnNames = config.options.useColumnNames;
          }
          if (config.options.useUTC !== void 0) {
            if (typeof config.options.useUTC !== "boolean") {
              throw new TypeError('The "config.options.useUTC" property must be of type boolean.');
            }
            this.config.options.useUTC = config.options.useUTC;
          }
          if (config.options.workstationId !== void 0) {
            if (typeof config.options.workstationId !== "string") {
              throw new TypeError('The "config.options.workstationId" property must be of type string.');
            }
            this.config.options.workstationId = config.options.workstationId;
          }
          if (config.options.lowerCaseGuids !== void 0) {
            if (typeof config.options.lowerCaseGuids !== "boolean") {
              throw new TypeError('The "config.options.lowerCaseGuids" property must be of type boolean.');
            }
            this.config.options.lowerCaseGuids = config.options.lowerCaseGuids;
          }
        }
        this.secureContextOptions = this.config.options.cryptoCredentialsDetails;
        if (this.secureContextOptions.secureOptions === void 0) {
          this.secureContextOptions = Object.create(this.secureContextOptions, {
            secureOptions: {
              value: _constants.default.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
            }
          });
        }
        this.debug = this.createDebug();
        this.inTransaction = false;
        this.transactionDescriptors = [Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])];
        this.transactionDepth = 0;
        this.isSqlBatch = false;
        this.closed = false;
        this.messageBuffer = Buffer.alloc(0);
        this.curTransientRetryCount = 0;
        this.transientErrorLookup = new _transientErrorLookup.TransientErrorLookup();
        this.state = this.STATE.INITIALIZED;
        this._cancelAfterRequestSent = () => {
          this.messageIo.sendMessage(_packet.TYPE.ATTENTION);
          this.createCancelTimer();
        };
      }
      connect(connectListener) {
        if (this.state !== this.STATE.INITIALIZED) {
          throw new _errors.ConnectionError("`.connect` can not be called on a Connection in `" + this.state.name + "` state.");
        }
        if (connectListener) {
          const onConnect = (err) => {
            this.removeListener("error", onError);
            connectListener(err);
          };
          const onError = (err) => {
            this.removeListener("connect", onConnect);
            connectListener(err);
          };
          this.once("connect", onConnect);
          this.once("error", onError);
        }
        this.transitionTo(this.STATE.CONNECTING);
      }
      /**
       * The server has reported that the charset has changed.
       */
      /**
       * The attempt to connect and validate has completed.
       */
      /**
       * The server has reported that the active database has changed.
       * This may be as a result of a successful login, or a `use` statement.
       */
      /**
       * A debug message is available. It may be logged or ignored.
       */
      /**
       * Internal error occurs.
       */
      /**
       * The server has issued an error message.
       */
      /**
       * The connection has ended.
       *
       * This may be as a result of the client calling [[close]], the server
       * closing the connection, or a network error.
       */
      /**
       * The server has issued an information message.
       */
      /**
       * The server has reported that the language has changed.
       */
      /**
       * The connection was reset.
       */
      /**
       * A secure connection has been established.
       */
      on(event, listener) {
        return super.on(event, listener);
      }
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      emit(event, ...args) {
        return super.emit(event, ...args);
      }
      /**
       * Closes the connection to the database.
       *
       * The [[Event_end]] will be emitted once the connection has been closed.
       */
      close() {
        this.transitionTo(this.STATE.FINAL);
      }
      /**
       * @private
       */
      initialiseConnection() {
        const signal = this.createConnectTimer();
        if (this.config.options.port) {
          return this.connectOnPort(this.config.options.port, this.config.options.multiSubnetFailover, signal, this.config.options.connector);
        } else {
          return (0, _instanceLookup.instanceLookup)({
            server: this.config.server,
            instanceName: this.config.options.instanceName,
            timeout: this.config.options.connectTimeout,
            signal
          }).then((port) => {
            process.nextTick(() => {
              this.connectOnPort(port, this.config.options.multiSubnetFailover, signal, this.config.options.connector);
            });
          }, (err) => {
            this.clearConnectTimer();
            if (signal.aborted) {
              return;
            }
            process.nextTick(() => {
              this.emit("connect", new _errors.ConnectionError(err.message, "EINSTLOOKUP"));
            });
          });
        }
      }
      /**
       * @private
       */
      cleanupConnection(cleanupType) {
        if (!this.closed) {
          this.clearConnectTimer();
          this.clearRequestTimer();
          this.clearRetryTimer();
          this.closeConnection();
          if (cleanupType === CLEANUP_TYPE.REDIRECT) {
            this.emit("rerouting");
          } else if (cleanupType !== CLEANUP_TYPE.RETRY) {
            process.nextTick(() => {
              this.emit("end");
            });
          }
          const request3 = this.request;
          if (request3) {
            const err = new _errors.RequestError("Connection closed before request completed.", "ECLOSE");
            request3.callback(err);
            this.request = void 0;
          }
          this.closed = true;
          this.loginError = void 0;
        }
      }
      /**
       * @private
       */
      createDebug() {
        const debug = new _debug.default(this.config.options.debug);
        debug.on("debug", (message) => {
          this.emit("debug", message);
        });
        return debug;
      }
      /**
       * @private
       */
      createTokenStreamParser(message, handler) {
        return new _tokenStreamParser.Parser(message, this.debug, handler, this.config.options);
      }
      socketHandlingForSendPreLogin(socket) {
        socket.on("error", (error) => {
          this.socketError(error);
        });
        socket.on("close", () => {
          this.socketClose();
        });
        socket.on("end", () => {
          this.socketEnd();
        });
        socket.setKeepAlive(true, KEEP_ALIVE_INITIAL_DELAY);
        this.messageIo = new _messageIo.default(socket, this.config.options.packetSize, this.debug);
        this.messageIo.on("secure", (cleartext) => {
          this.emit("secure", cleartext);
        });
        this.socket = socket;
        this.closed = false;
        this.debug.log("connected to " + this.config.server + ":" + this.config.options.port);
        this.sendPreLogin();
        this.transitionTo(this.STATE.SENT_PRELOGIN);
      }
      wrapWithTls(socket, signal) {
        signal.throwIfAborted();
        return new Promise((resolve, reject) => {
          const secureContext = tls.createSecureContext(this.secureContextOptions);
          const serverName = !net.isIP(this.config.server) ? this.config.server : "";
          const encryptOptions = {
            host: this.config.server,
            socket,
            ALPNProtocols: ["tds/8.0"],
            secureContext,
            servername: this.config.options.serverName ? this.config.options.serverName : serverName
          };
          const encryptsocket = tls.connect(encryptOptions);
          const onAbort = () => {
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            encryptsocket.destroy();
            reject(signal.reason);
          };
          const onError = (err) => {
            signal.removeEventListener("abort", onAbort);
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            encryptsocket.destroy();
            reject(err);
          };
          const onConnect = () => {
            signal.removeEventListener("abort", onAbort);
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            resolve(encryptsocket);
          };
          signal.addEventListener("abort", onAbort, {
            once: true
          });
          encryptsocket.on("error", onError);
          encryptsocket.on("secureConnect", onConnect);
        });
      }
      connectOnPort(port, multiSubnetFailover, signal, customConnector) {
        const connectOpts = {
          host: this.routingData ? this.routingData.server : this.config.server,
          port: this.routingData ? this.routingData.port : port,
          localAddress: this.config.options.localAddress
        };
        const connect = customConnector || (multiSubnetFailover ? _connector.connectInParallel : _connector.connectInSequence);
        (async () => {
          let socket = await connect(connectOpts, _dns.default.lookup, signal);
          if (this.config.options.encrypt === "strict") {
            try {
              socket = await this.wrapWithTls(socket, signal);
            } catch (err) {
              socket.end();
              throw err;
            }
          }
          this.socketHandlingForSendPreLogin(socket);
        })().catch((err) => {
          this.clearConnectTimer();
          if (signal.aborted) {
            return;
          }
          process.nextTick(() => {
            this.socketError(err);
          });
        });
      }
      /**
       * @private
       */
      closeConnection() {
        if (this.socket) {
          this.socket.destroy();
        }
      }
      /**
       * @private
       */
      createConnectTimer() {
        const controller = new _nodeAbortController.AbortController();
        this.connectTimer = setTimeout(() => {
          controller.abort();
          this.connectTimeout();
        }, this.config.options.connectTimeout);
        return controller.signal;
      }
      /**
       * @private
       */
      createCancelTimer() {
        this.clearCancelTimer();
        const timeout = this.config.options.cancelTimeout;
        if (timeout > 0) {
          this.cancelTimer = setTimeout(() => {
            this.cancelTimeout();
          }, timeout);
        }
      }
      /**
       * @private
       */
      createRequestTimer() {
        this.clearRequestTimer();
        const request3 = this.request;
        const timeout = request3.timeout !== void 0 ? request3.timeout : this.config.options.requestTimeout;
        if (timeout) {
          this.requestTimer = setTimeout(() => {
            this.requestTimeout();
          }, timeout);
        }
      }
      /**
       * @private
       */
      createRetryTimer() {
        this.clearRetryTimer();
        this.retryTimer = setTimeout(() => {
          this.retryTimeout();
        }, this.config.options.connectionRetryInterval);
      }
      /**
       * @private
       */
      connectTimeout() {
        const hostPostfix = this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`;
        const server = this.routingData ? this.routingData.server : this.config.server;
        const port = this.routingData ? `:${this.routingData.port}` : hostPostfix;
        const routingMessage = this.routingData ? ` (redirected from ${this.config.server}${hostPostfix})` : "";
        const message = `Failed to connect to ${server}${port}${routingMessage} in ${this.config.options.connectTimeout}ms`;
        this.debug.log(message);
        this.emit("connect", new _errors.ConnectionError(message, "ETIMEOUT"));
        this.connectTimer = void 0;
        this.dispatchEvent("connectTimeout");
      }
      /**
       * @private
       */
      cancelTimeout() {
        const message = `Failed to cancel request in ${this.config.options.cancelTimeout}ms`;
        this.debug.log(message);
        this.dispatchEvent("socketError", new _errors.ConnectionError(message, "ETIMEOUT"));
      }
      /**
       * @private
       */
      requestTimeout() {
        this.requestTimer = void 0;
        const request3 = this.request;
        request3.cancel();
        const timeout = request3.timeout !== void 0 ? request3.timeout : this.config.options.requestTimeout;
        const message = "Timeout: Request failed to complete in " + timeout + "ms";
        request3.error = new _errors.RequestError(message, "ETIMEOUT");
      }
      /**
       * @private
       */
      retryTimeout() {
        this.retryTimer = void 0;
        this.emit("retry");
        this.transitionTo(this.STATE.CONNECTING);
      }
      /**
       * @private
       */
      clearConnectTimer() {
        if (this.connectTimer) {
          clearTimeout(this.connectTimer);
          this.connectTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearCancelTimer() {
        if (this.cancelTimer) {
          clearTimeout(this.cancelTimer);
          this.cancelTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearRequestTimer() {
        if (this.requestTimer) {
          clearTimeout(this.requestTimer);
          this.requestTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearRetryTimer() {
        if (this.retryTimer) {
          clearTimeout(this.retryTimer);
          this.retryTimer = void 0;
        }
      }
      /**
       * @private
       */
      transitionTo(newState) {
        if (this.state === newState) {
          this.debug.log("State is already " + newState.name);
          return;
        }
        if (this.state && this.state.exit) {
          this.state.exit.call(this, newState);
        }
        this.debug.log("State change: " + (this.state ? this.state.name : "undefined") + " -> " + newState.name);
        this.state = newState;
        if (this.state.enter) {
          this.state.enter.apply(this);
        }
      }
      /**
       * @private
       */
      getEventHandler(eventName) {
        const handler = this.state.events[eventName];
        if (!handler) {
          throw new Error(`No event '${eventName}' in state '${this.state.name}'`);
        }
        return handler;
      }
      /**
       * @private
       */
      dispatchEvent(eventName, ...args) {
        const handler = this.state.events[eventName];
        if (handler) {
          handler.apply(this, args);
        } else {
          this.emit("error", new Error(`No event '${eventName}' in state '${this.state.name}'`));
          this.close();
        }
      }
      /**
       * @private
       */
      socketError(error) {
        if (this.state === this.STATE.CONNECTING || this.state === this.STATE.SENT_TLSSSLNEGOTIATION) {
          const hostPostfix = this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`;
          const server = this.routingData ? this.routingData.server : this.config.server;
          const port = this.routingData ? `:${this.routingData.port}` : hostPostfix;
          const routingMessage = this.routingData ? ` (redirected from ${this.config.server}${hostPostfix})` : "";
          const message = `Failed to connect to ${server}${port}${routingMessage} - ${error.message}`;
          this.debug.log(message);
          this.emit("connect", new _errors.ConnectionError(message, "ESOCKET"));
        } else {
          const message = `Connection lost - ${error.message}`;
          this.debug.log(message);
          this.emit("error", new _errors.ConnectionError(message, "ESOCKET"));
        }
        this.dispatchEvent("socketError", error);
      }
      /**
       * @private
       */
      socketEnd() {
        this.debug.log("socket ended");
        if (this.state !== this.STATE.FINAL) {
          const error = new Error("socket hang up");
          error.code = "ECONNRESET";
          this.socketError(error);
        }
      }
      /**
       * @private
       */
      socketClose() {
        this.debug.log("connection to " + this.config.server + ":" + this.config.options.port + " closed");
        if (this.state === this.STATE.REROUTING) {
          this.debug.log("Rerouting to " + this.routingData.server + ":" + this.routingData.port);
          this.dispatchEvent("reconnect");
        } else if (this.state === this.STATE.TRANSIENT_FAILURE_RETRY) {
          const server = this.routingData ? this.routingData.server : this.config.server;
          const port = this.routingData ? this.routingData.port : this.config.options.port;
          this.debug.log("Retry after transient failure connecting to " + server + ":" + port);
          this.dispatchEvent("retry");
        } else {
          this.transitionTo(this.STATE.FINAL);
        }
      }
      /**
       * @private
       */
      sendPreLogin() {
        const [, major, minor, build] = /^(\d+)\.(\d+)\.(\d+)/.exec(_package.version) ?? ["0.0.0", "0", "0", "0"];
        const payload = new _preloginPayload.default({
          // If encrypt setting is set to 'strict', then we should have already done the encryption before calling
          // this function. Therefore, the encrypt will be set to false here.
          // Otherwise, we will set encrypt here based on the encrypt Boolean value from the configuration.
          encrypt: typeof this.config.options.encrypt === "boolean" && this.config.options.encrypt,
          version: {
            major: Number(major),
            minor: Number(minor),
            build: Number(build),
            subbuild: 0
          }
        });
        this.messageIo.sendMessage(_packet.TYPE.PRELOGIN, payload.data);
        this.debug.payload(function() {
          return payload.toString("  ");
        });
      }
      /**
       * @private
       */
      sendLogin7Packet() {
        const payload = new _login7Payload.default({
          tdsVersion: _tdsVersions.versions[this.config.options.tdsVersion],
          packetSize: this.config.options.packetSize,
          clientProgVer: 0,
          clientPid: process.pid,
          connectionId: 0,
          clientTimeZone: (/* @__PURE__ */ new Date()).getTimezoneOffset(),
          clientLcid: 1033
        });
        const {
          authentication
        } = this.config;
        switch (authentication.type) {
          case "azure-active-directory-password":
            payload.fedAuth = {
              type: "ADAL",
              echo: this.fedAuthRequired,
              workflow: "default"
            };
            break;
          case "azure-active-directory-access-token":
            payload.fedAuth = {
              type: "SECURITYTOKEN",
              echo: this.fedAuthRequired,
              fedAuthToken: authentication.options.token
            };
            break;
          case "azure-active-directory-msi-vm":
          case "azure-active-directory-default":
          case "azure-active-directory-msi-app-service":
          case "azure-active-directory-service-principal-secret":
            payload.fedAuth = {
              type: "ADAL",
              echo: this.fedAuthRequired,
              workflow: "integrated"
            };
            break;
          case "ntlm":
            payload.sspi = (0, _ntlm.createNTLMRequest)({
              domain: authentication.options.domain
            });
            break;
          default:
            payload.userName = authentication.options.userName;
            payload.password = authentication.options.password;
        }
        payload.hostname = this.config.options.workstationId || _os.default.hostname();
        payload.serverName = this.routingData ? this.routingData.server : this.config.server;
        payload.appName = this.config.options.appName || "Tedious";
        payload.libraryName = _library.name;
        payload.language = this.config.options.language;
        payload.database = this.config.options.database;
        payload.clientId = Buffer.from([1, 2, 3, 4, 5, 6]);
        payload.readOnlyIntent = this.config.options.readOnlyIntent;
        payload.initDbFatal = !this.config.options.fallbackToDefaultDb;
        this.routingData = void 0;
        this.messageIo.sendMessage(_packet.TYPE.LOGIN7, payload.toBuffer());
        this.debug.payload(function() {
          return payload.toString("  ");
        });
      }
      /**
       * @private
       */
      sendFedAuthTokenMessage(token) {
        const accessTokenLen = Buffer.byteLength(token, "ucs2");
        const data = Buffer.alloc(8 + accessTokenLen);
        let offset = 0;
        offset = data.writeUInt32LE(accessTokenLen + 4, offset);
        offset = data.writeUInt32LE(accessTokenLen, offset);
        data.write(token, offset, "ucs2");
        this.messageIo.sendMessage(_packet.TYPE.FEDAUTH_TOKEN, data);
        this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
      }
      /**
       * @private
       */
      sendInitialSql() {
        const payload = new _sqlbatchPayload.default(this.getInitialSql(), this.currentTransactionDescriptor(), this.config.options);
        const message = new _message.default({
          type: _packet.TYPE.SQL_BATCH
        });
        this.messageIo.outgoingMessageStream.write(message);
        _stream.Readable.from(payload).pipe(message);
      }
      /**
       * @private
       */
      getInitialSql() {
        const options = [];
        if (this.config.options.enableAnsiNull === true) {
          options.push("set ansi_nulls on");
        } else if (this.config.options.enableAnsiNull === false) {
          options.push("set ansi_nulls off");
        }
        if (this.config.options.enableAnsiNullDefault === true) {
          options.push("set ansi_null_dflt_on on");
        } else if (this.config.options.enableAnsiNullDefault === false) {
          options.push("set ansi_null_dflt_on off");
        }
        if (this.config.options.enableAnsiPadding === true) {
          options.push("set ansi_padding on");
        } else if (this.config.options.enableAnsiPadding === false) {
          options.push("set ansi_padding off");
        }
        if (this.config.options.enableAnsiWarnings === true) {
          options.push("set ansi_warnings on");
        } else if (this.config.options.enableAnsiWarnings === false) {
          options.push("set ansi_warnings off");
        }
        if (this.config.options.enableArithAbort === true) {
          options.push("set arithabort on");
        } else if (this.config.options.enableArithAbort === false) {
          options.push("set arithabort off");
        }
        if (this.config.options.enableConcatNullYieldsNull === true) {
          options.push("set concat_null_yields_null on");
        } else if (this.config.options.enableConcatNullYieldsNull === false) {
          options.push("set concat_null_yields_null off");
        }
        if (this.config.options.enableCursorCloseOnCommit === true) {
          options.push("set cursor_close_on_commit on");
        } else if (this.config.options.enableCursorCloseOnCommit === false) {
          options.push("set cursor_close_on_commit off");
        }
        if (this.config.options.datefirst !== null) {
          options.push(`set datefirst ${this.config.options.datefirst}`);
        }
        if (this.config.options.dateFormat !== null) {
          options.push(`set dateformat ${this.config.options.dateFormat}`);
        }
        if (this.config.options.enableImplicitTransactions === true) {
          options.push("set implicit_transactions on");
        } else if (this.config.options.enableImplicitTransactions === false) {
          options.push("set implicit_transactions off");
        }
        if (this.config.options.language !== null) {
          options.push(`set language ${this.config.options.language}`);
        }
        if (this.config.options.enableNumericRoundabort === true) {
          options.push("set numeric_roundabort on");
        } else if (this.config.options.enableNumericRoundabort === false) {
          options.push("set numeric_roundabort off");
        }
        if (this.config.options.enableQuotedIdentifier === true) {
          options.push("set quoted_identifier on");
        } else if (this.config.options.enableQuotedIdentifier === false) {
          options.push("set quoted_identifier off");
        }
        if (this.config.options.textsize !== null) {
          options.push(`set textsize ${this.config.options.textsize}`);
        }
        if (this.config.options.connectionIsolationLevel !== null) {
          options.push(`set transaction isolation level ${this.getIsolationLevelText(this.config.options.connectionIsolationLevel)}`);
        }
        if (this.config.options.abortTransactionOnError === true) {
          options.push("set xact_abort on");
        } else if (this.config.options.abortTransactionOnError === false) {
          options.push("set xact_abort off");
        }
        return options.join("\n");
      }
      /**
       * @private
       */
      processedInitialSql() {
        this.clearConnectTimer();
        this.emit("connect");
      }
      /**
       * Execute the SQL batch represented by [[Request]].
       * There is no param support, and unlike [[Request.execSql]],
       * it is not likely that SQL Server will reuse the execution plan it generates for the SQL.
       *
       * In almost all cases, [[Request.execSql]] will be a better choice.
       *
       * @param request A [[Request]] object representing the request.
       */
      execSqlBatch(request3) {
        this.makeRequest(request3, _packet.TYPE.SQL_BATCH, new _sqlbatchPayload.default(request3.sqlTextOrProcedure, this.currentTransactionDescriptor(), this.config.options));
      }
      /**
       *  Execute the SQL represented by [[Request]].
       *
       * As `sp_executesql` is used to execute the SQL, if the same SQL is executed multiples times
       * using this function, the SQL Server query optimizer is likely to reuse the execution plan it generates
       * for the first execution. This may also result in SQL server treating the request like a stored procedure
       * which can result in the [[Event_doneInProc]] or [[Event_doneProc]] events being emitted instead of the
       * [[Event_done]] event you might expect. Using [[execSqlBatch]] will prevent this from occurring but may have a negative performance impact.
       *
       * Beware of the way that scoping rules apply, and how they may [affect local temp tables](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)
       * If you're running in to scoping issues, then [[execSqlBatch]] may be a better choice.
       * See also [issue #24](https://github.com/pekim/tedious/issues/24)
       *
       * @param request A [[Request]] object representing the request.
       */
      execSql(request3) {
        try {
          request3.validateParameters(this.databaseCollation);
        } catch (error) {
          request3.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request3.callback(error);
          });
          return;
        }
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "statement",
          value: request3.sqlTextOrProcedure,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        if (request3.parameters.length) {
          parameters.push({
            type: _dataType.TYPES.NVarChar,
            name: "params",
            value: request3.makeParamsParameter(request3.parameters),
            output: false,
            length: void 0,
            precision: void 0,
            scale: void 0
          });
          parameters.push(...request3.parameters);
        }
        this.makeRequest(request3, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_ExecuteSql, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Creates a new BulkLoad instance.
       *
       * @param table The name of the table to bulk-insert into.
       * @param options A set of bulk load options.
       */
      newBulkLoad(table, callbackOrOptions, callback) {
        let options;
        if (callback === void 0) {
          callback = callbackOrOptions;
          options = {};
        } else {
          options = callbackOrOptions;
        }
        if (typeof options !== "object") {
          throw new TypeError('"options" argument must be an object');
        }
        return new _bulkLoad.default(table, this.databaseCollation, this.config.options, options, callback);
      }
      /**
       * Execute a [[BulkLoad]].
       *
       * ```js
       * // We want to perform a bulk load into a table with the following format:
       * // CREATE TABLE employees (first_name nvarchar(255), last_name nvarchar(255), day_of_birth date);
       *
       * const bulkLoad = connection.newBulkLoad('employees', (err, rowCount) => {
       *   // ...
       * });
       *
       * // First, we need to specify the columns that we want to write to,
       * // and their definitions. These definitions must match the actual table,
       * // otherwise the bulk load will fail.
       * bulkLoad.addColumn('first_name', TYPES.NVarchar, { nullable: false });
       * bulkLoad.addColumn('last_name', TYPES.NVarchar, { nullable: false });
       * bulkLoad.addColumn('date_of_birth', TYPES.Date, { nullable: false });
       *
       * // Execute a bulk load with a predefined list of rows.
       * //
       * // Note that these rows are held in memory until the
       * // bulk load was performed, so if you need to write a large
       * // number of rows (e.g. by reading from a CSV file),
       * // passing an `AsyncIterable` is advisable to keep memory usage low.
       * connection.execBulkLoad(bulkLoad, [
       *   { 'first_name': 'Steve', 'last_name': 'Jobs', 'day_of_birth': new Date('02-24-1955') },
       *   { 'first_name': 'Bill', 'last_name': 'Gates', 'day_of_birth': new Date('10-28-1955') }
       * ]);
       * ```
       *
       * @param bulkLoad A previously created [[BulkLoad]].
       * @param rows A [[Iterable]] or [[AsyncIterable]] that contains the rows that should be bulk loaded.
       */
      execBulkLoad(bulkLoad, rows) {
        bulkLoad.executionStarted = true;
        if (rows) {
          if (bulkLoad.streamingMode) {
            throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that was put in streaming mode.");
          }
          if (bulkLoad.firstRowWritten) {
            throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that already has rows written to it.");
          }
          const rowStream = _stream.Readable.from(rows);
          rowStream.on("error", (err) => {
            bulkLoad.rowToPacketTransform.destroy(err);
          });
          bulkLoad.rowToPacketTransform.on("error", (err) => {
            rowStream.destroy(err);
          });
          rowStream.pipe(bulkLoad.rowToPacketTransform);
        } else if (!bulkLoad.streamingMode) {
          bulkLoad.rowToPacketTransform.end();
        }
        const onCancel = () => {
          request3.cancel();
        };
        const payload = new _bulkLoadPayload.BulkLoadPayload(bulkLoad);
        const request3 = new _request.default(bulkLoad.getBulkInsertSql(), (error) => {
          bulkLoad.removeListener("cancel", onCancel);
          if (error) {
            if (error.code === "UNKNOWN") {
              error.message += " This is likely because the schema of the BulkLoad does not match the schema of the table you are attempting to insert into.";
            }
            bulkLoad.error = error;
            bulkLoad.callback(error);
            return;
          }
          this.makeRequest(bulkLoad, _packet.TYPE.BULK_LOAD, payload);
        });
        bulkLoad.once("cancel", onCancel);
        this.execSqlBatch(request3);
      }
      /**
       * Prepare the SQL represented by the request.
       *
       * The request can then be used in subsequent calls to
       * [[execute]] and [[unprepare]]
       *
       * @param request A [[Request]] object representing the request.
       *   Parameters only require a name and type. Parameter values are ignored.
       */
      prepare(request3) {
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.Int,
          name: "handle",
          value: void 0,
          output: true,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "params",
          value: request3.parameters.length ? request3.makeParamsParameter(request3.parameters) : null,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "stmt",
          value: request3.sqlTextOrProcedure,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        request3.preparing = true;
        request3.on("returnValue", (name3, value) => {
          if (name3 === "handle") {
            request3.handle = value;
          } else {
            request3.error = new _errors.RequestError(`Tedious > Unexpected output parameter ${name3} from sp_prepare`);
          }
        });
        this.makeRequest(request3, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Prepare, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Release the SQL Server resources associated with a previously prepared request.
       *
       * @param request A [[Request]] object representing the request.
       *   Parameters only require a name and type.
       *   Parameter values are ignored.
       */
      unprepare(request3) {
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.Int,
          name: "handle",
          // TODO: Abort if `request.handle` is not set
          value: request3.handle,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        this.makeRequest(request3, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Unprepare, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Execute previously prepared SQL, using the supplied parameters.
       *
       * @param request A previously prepared [[Request]].
       * @param parameters  An object whose names correspond to the names of
       *   parameters that were added to the [[Request]] before it was prepared.
       *   The object's values are passed as the parameters' values when the
       *   request is executed.
       */
      execute(request3, parameters) {
        const executeParameters = [];
        executeParameters.push({
          type: _dataType.TYPES.Int,
          name: "",
          // TODO: Abort if `request.handle` is not set
          value: request3.handle,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        try {
          for (let i = 0, len = request3.parameters.length; i < len; i++) {
            const parameter = request3.parameters[i];
            executeParameters.push({
              ...parameter,
              value: parameter.type.validate(parameters ? parameters[parameter.name] : null, this.databaseCollation)
            });
          }
        } catch (error) {
          request3.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request3.callback(error);
          });
          return;
        }
        this.makeRequest(request3, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Execute, executeParameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Call a stored procedure represented by [[Request]].
       *
       * @param request A [[Request]] object representing the request.
       */
      callProcedure(request3) {
        try {
          request3.validateParameters(this.databaseCollation);
        } catch (error) {
          request3.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request3.callback(error);
          });
          return;
        }
        this.makeRequest(request3, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(request3.sqlTextOrProcedure, request3.parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Start a transaction.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string. Required when `isolationLevel`
       *   is present.
       * @param isolationLevel The isolation level that the transaction is to be run with.
       *
       *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
       *   * `READ_UNCOMMITTED`
       *   * `READ_COMMITTED`
       *   * `REPEATABLE_READ`
       *   * `SERIALIZABLE`
       *   * `SNAPSHOT`
       *
       *   Optional, and defaults to the Connection's isolation level.
       */
      beginTransaction(callback, name3 = "", isolationLevel = this.config.options.isolationLevel) {
        (0, _transaction.assertValidIsolationLevel)(isolationLevel, "isolationLevel");
        const transaction = new _transaction.Transaction(name3, isolationLevel);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("SET TRANSACTION ISOLATION LEVEL " + transaction.isolationLevelToTSQL() + ";BEGIN TRAN " + transaction.name, (err) => {
            this.transactionDepth++;
            if (this.transactionDepth === 1) {
              this.inTransaction = true;
            }
            callback(err);
          }));
        }
        const request3 = new _request.default(void 0, (err) => {
          return callback(err, this.currentTransactionDescriptor());
        });
        return this.makeRequest(request3, _packet.TYPE.TRANSACTION_MANAGER, transaction.beginPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Commit a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string. Required when `isolationLevel`is present.
       */
      commitTransaction(callback, name3 = "") {
        const transaction = new _transaction.Transaction(name3);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("COMMIT TRAN " + transaction.name, (err) => {
            this.transactionDepth--;
            if (this.transactionDepth === 0) {
              this.inTransaction = false;
            }
            callback(err);
          }));
        }
        const request3 = new _request.default(void 0, callback);
        return this.makeRequest(request3, _packet.TYPE.TRANSACTION_MANAGER, transaction.commitPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Rollback a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string.
       *   Required when `isolationLevel` is present.
       */
      rollbackTransaction(callback, name3 = "") {
        const transaction = new _transaction.Transaction(name3);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("ROLLBACK TRAN " + transaction.name, (err) => {
            this.transactionDepth--;
            if (this.transactionDepth === 0) {
              this.inTransaction = false;
            }
            callback(err);
          }));
        }
        const request3 = new _request.default(void 0, callback);
        return this.makeRequest(request3, _packet.TYPE.TRANSACTION_MANAGER, transaction.rollbackPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Set a savepoint within a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.\
       *   Optional, and defaults to an empty string.
       *   Required when `isolationLevel` is present.
       */
      saveTransaction(callback, name3) {
        const transaction = new _transaction.Transaction(name3);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("SAVE TRAN " + transaction.name, (err) => {
            this.transactionDepth++;
            callback(err);
          }));
        }
        const request3 = new _request.default(void 0, callback);
        return this.makeRequest(request3, _packet.TYPE.TRANSACTION_MANAGER, transaction.savePayload(this.currentTransactionDescriptor()));
      }
      /**
       * Run the given callback after starting a transaction, and commit or
       * rollback the transaction afterwards.
       *
       * This is a helper that employs [[beginTransaction]], [[commitTransaction]],
       * [[rollbackTransaction]], and [[saveTransaction]] to greatly simplify the
       * use of database transactions and automatically handle transaction nesting.
       *
       * @param cb
       * @param isolationLevel
       *   The isolation level that the transaction is to be run with.
       *
       *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
       *   * `READ_UNCOMMITTED`
       *   * `READ_COMMITTED`
       *   * `REPEATABLE_READ`
       *   * `SERIALIZABLE`
       *   * `SNAPSHOT`
       *
       *   Optional, and defaults to the Connection's isolation level.
       */
      transaction(cb, isolationLevel) {
        if (typeof cb !== "function") {
          throw new TypeError("`cb` must be a function");
        }
        const useSavepoint = this.inTransaction;
        const name3 = "_tedious_" + _crypto.default.randomBytes(10).toString("hex");
        const txDone = (err, done, ...args) => {
          if (err) {
            if (this.inTransaction && this.state === this.STATE.LOGGED_IN) {
              this.rollbackTransaction((txErr) => {
                done(txErr || err, ...args);
              }, name3);
            } else {
              done(err, ...args);
            }
          } else if (useSavepoint) {
            if (this.config.options.tdsVersion < "7_2") {
              this.transactionDepth--;
            }
            done(null, ...args);
          } else {
            this.commitTransaction((txErr) => {
              done(txErr, ...args);
            }, name3);
          }
        };
        if (useSavepoint) {
          return this.saveTransaction((err) => {
            if (err) {
              return cb(err);
            }
            if (isolationLevel) {
              return this.execSqlBatch(new _request.default("SET transaction isolation level " + this.getIsolationLevelText(isolationLevel), (err2) => {
                return cb(err2, txDone);
              }));
            } else {
              return cb(null, txDone);
            }
          }, name3);
        } else {
          return this.beginTransaction((err) => {
            if (err) {
              return cb(err);
            }
            return cb(null, txDone);
          }, name3, isolationLevel);
        }
      }
      /**
       * @private
       */
      makeRequest(request3, packetType, payload) {
        if (this.state !== this.STATE.LOGGED_IN) {
          const message = "Requests can only be made in the " + this.STATE.LOGGED_IN.name + " state, not the " + this.state.name + " state";
          this.debug.log(message);
          request3.callback(new _errors.RequestError(message, "EINVALIDSTATE"));
        } else if (request3.canceled) {
          process.nextTick(() => {
            request3.callback(new _errors.RequestError("Canceled.", "ECANCEL"));
          });
        } else {
          if (packetType === _packet.TYPE.SQL_BATCH) {
            this.isSqlBatch = true;
          } else {
            this.isSqlBatch = false;
          }
          this.request = request3;
          request3.connection = this;
          request3.rowCount = 0;
          request3.rows = [];
          request3.rst = [];
          const onCancel = () => {
            payloadStream.unpipe(message);
            payloadStream.destroy(new _errors.RequestError("Canceled.", "ECANCEL"));
            message.ignore = true;
            message.end();
            if (request3 instanceof _request.default && request3.paused) {
              request3.resume();
            }
          };
          request3.once("cancel", onCancel);
          this.createRequestTimer();
          const message = new _message.default({
            type: packetType,
            resetConnection: this.resetConnectionOnNextRequest
          });
          this.messageIo.outgoingMessageStream.write(message);
          this.transitionTo(this.STATE.SENT_CLIENT_REQUEST);
          message.once("finish", () => {
            request3.removeListener("cancel", onCancel);
            request3.once("cancel", this._cancelAfterRequestSent);
            this.resetConnectionOnNextRequest = false;
            this.debug.payload(function() {
              return payload.toString("  ");
            });
          });
          const payloadStream = _stream.Readable.from(payload);
          payloadStream.once("error", (error) => {
            payloadStream.unpipe(message);
            request3.error ?? (request3.error = error);
            message.ignore = true;
            message.end();
          });
          payloadStream.pipe(message);
        }
      }
      /**
       * Cancel currently executed request.
       */
      cancel() {
        if (!this.request) {
          return false;
        }
        if (this.request.canceled) {
          return false;
        }
        this.request.cancel();
        return true;
      }
      /**
       * Reset the connection to its initial state.
       * Can be useful for connection pool implementations.
       *
       * @param callback
       */
      reset(callback) {
        const request3 = new _request.default(this.getInitialSql(), (err) => {
          if (this.config.options.tdsVersion < "7_2") {
            this.inTransaction = false;
          }
          callback(err);
        });
        this.resetConnectionOnNextRequest = true;
        this.execSqlBatch(request3);
      }
      /**
       * @private
       */
      currentTransactionDescriptor() {
        return this.transactionDescriptors[this.transactionDescriptors.length - 1];
      }
      /**
       * @private
       */
      getIsolationLevelText(isolationLevel) {
        switch (isolationLevel) {
          case _transaction.ISOLATION_LEVEL.READ_UNCOMMITTED:
            return "read uncommitted";
          case _transaction.ISOLATION_LEVEL.REPEATABLE_READ:
            return "repeatable read";
          case _transaction.ISOLATION_LEVEL.SERIALIZABLE:
            return "serializable";
          case _transaction.ISOLATION_LEVEL.SNAPSHOT:
            return "snapshot";
          default:
            return "read committed";
        }
      }
    };
    function isTransientError(error) {
      if (error instanceof _esAggregateError.default) {
        error = error.errors[0];
      }
      return error instanceof _errors.ConnectionError && !!error.isTransient;
    }
    var _default = Connection;
    exports.default = _default;
    module2.exports = Connection;
    Connection.prototype.STATE = {
      INITIALIZED: {
        name: "Initialized",
        events: {}
      },
      CONNECTING: {
        name: "Connecting",
        enter: function() {
          this.initialiseConnection();
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_PRELOGIN: {
        name: "SentPrelogin",
        enter: function() {
          (async () => {
            let messageBuffer = Buffer.alloc(0);
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            for await (const data of message) {
              messageBuffer = Buffer.concat([messageBuffer, data]);
            }
            const preloginPayload = new _preloginPayload.default(messageBuffer);
            this.debug.payload(function() {
              return preloginPayload.toString("  ");
            });
            if (preloginPayload.fedAuthRequired === 1) {
              this.fedAuthRequired = true;
            }
            if ("strict" !== this.config.options.encrypt && (preloginPayload.encryptionString === "ON" || preloginPayload.encryptionString === "REQ")) {
              if (!this.config.options.encrypt) {
                this.emit("connect", new _errors.ConnectionError("Server requires encryption, set 'encrypt' config option to true.", "EENCRYPT"));
                return this.close();
              }
              try {
                var _this$routingData;
                this.transitionTo(this.STATE.SENT_TLSSSLNEGOTIATION);
                await this.messageIo.startTls(this.secureContextOptions, this.config.options.serverName ? this.config.options.serverName : ((_this$routingData = this.routingData) === null || _this$routingData === void 0 ? void 0 : _this$routingData.server) ?? this.config.server, this.config.options.trustServerCertificate);
              } catch (err) {
                return this.socketError(err);
              }
            }
            this.sendLogin7Packet();
            const {
              authentication
            } = this.config;
            switch (authentication.type) {
              case "azure-active-directory-password":
              case "azure-active-directory-msi-vm":
              case "azure-active-directory-msi-app-service":
              case "azure-active-directory-service-principal-secret":
              case "azure-active-directory-default":
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_FEDAUTH);
                break;
              case "ntlm":
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);
                break;
              default:
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
                break;
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      REROUTING: {
        name: "ReRouting",
        enter: function() {
          this.cleanupConnection(CLEANUP_TYPE.REDIRECT);
        },
        events: {
          message: function() {
          },
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          reconnect: function() {
            this.transitionTo(this.STATE.CONNECTING);
          }
        }
      },
      TRANSIENT_FAILURE_RETRY: {
        name: "TRANSIENT_FAILURE_RETRY",
        enter: function() {
          this.curTransientRetryCount++;
          this.cleanupConnection(CLEANUP_TYPE.RETRY);
        },
        events: {
          message: function() {
          },
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          retry: function() {
            this.createRetryTimer();
          }
        }
      },
      SENT_TLSSSLNEGOTIATION: {
        name: "SentTLSSSLNegotiation",
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_STANDARD_LOGIN: {
        name: "SentLogin7WithStandardLogin",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.Login7TokenHandler(this);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.loginAckReceived) {
              if (handler.routingData) {
                this.routingData = handler.routingData;
                this.transitionTo(this.STATE.REROUTING);
              } else {
                this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
              }
            } else if (this.loginError) {
              if (isTransientError(this.loginError)) {
                this.debug.log("Initiating retry on transient error");
                this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
              } else {
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
              }
            } else {
              this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
              this.transitionTo(this.STATE.FINAL);
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_NTLM: {
        name: "SentLogin7WithNTLMLogin",
        enter: function() {
          (async () => {
            while (true) {
              let message;
              try {
                message = await this.messageIo.readMessage();
              } catch (err) {
                return this.socketError(err);
              }
              const handler = new _handler.Login7TokenHandler(this);
              const tokenStreamParser = this.createTokenStreamParser(message, handler);
              await (0, _events.once)(tokenStreamParser, "end");
              if (handler.loginAckReceived) {
                if (handler.routingData) {
                  this.routingData = handler.routingData;
                  return this.transitionTo(this.STATE.REROUTING);
                } else {
                  return this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
                }
              } else if (this.ntlmpacket) {
                const authentication = this.config.authentication;
                const payload = new _ntlmPayload.default({
                  domain: authentication.options.domain,
                  userName: authentication.options.userName,
                  password: authentication.options.password,
                  ntlmpacket: this.ntlmpacket
                });
                this.messageIo.sendMessage(_packet.TYPE.NTLMAUTH_PKT, payload.data);
                this.debug.payload(function() {
                  return payload.toString("  ");
                });
                this.ntlmpacket = void 0;
              } else if (this.loginError) {
                if (isTransientError(this.loginError)) {
                  this.debug.log("Initiating retry on transient error");
                  return this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
                } else {
                  this.emit("connect", this.loginError);
                  return this.transitionTo(this.STATE.FINAL);
                }
              } else {
                this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
                return this.transitionTo(this.STATE.FINAL);
              }
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_FEDAUTH: {
        name: "SentLogin7Withfedauth",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.Login7TokenHandler(this);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.loginAckReceived) {
              if (handler.routingData) {
                this.routingData = handler.routingData;
                this.transitionTo(this.STATE.REROUTING);
              } else {
                this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
              }
              return;
            }
            const fedAuthInfoToken = handler.fedAuthInfoToken;
            if (fedAuthInfoToken && fedAuthInfoToken.stsurl && fedAuthInfoToken.spn) {
              const authentication = this.config.authentication;
              const tokenScope = new _url.URL("/.default", fedAuthInfoToken.spn).toString();
              let credentials;
              switch (authentication.type) {
                case "azure-active-directory-password":
                  credentials = new _identity.UsernamePasswordCredential(authentication.options.tenantId ?? "common", authentication.options.clientId, authentication.options.userName, authentication.options.password);
                  break;
                case "azure-active-directory-msi-vm":
                case "azure-active-directory-msi-app-service":
                  const msiArgs = authentication.options.clientId ? [authentication.options.clientId, {}] : [{}];
                  credentials = new _identity.ManagedIdentityCredential(...msiArgs);
                  break;
                case "azure-active-directory-default":
                  const args = authentication.options.clientId ? {
                    managedIdentityClientId: authentication.options.clientId
                  } : {};
                  credentials = new _identity.DefaultAzureCredential(args);
                  break;
                case "azure-active-directory-service-principal-secret":
                  credentials = new _identity.ClientSecretCredential(authentication.options.tenantId, authentication.options.clientId, authentication.options.clientSecret);
                  break;
              }
              let tokenResponse;
              try {
                tokenResponse = await credentials.getToken(tokenScope);
              } catch (err) {
                this.loginError = new _esAggregateError.default([new _errors.ConnectionError("Security token could not be authenticated or authorized.", "EFEDAUTH"), err]);
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
                return;
              }
              const token = tokenResponse.token;
              this.sendFedAuthTokenMessage(token);
            } else if (this.loginError) {
              if (isTransientError(this.loginError)) {
                this.debug.log("Initiating retry on transient error");
                this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
              } else {
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
              }
            } else {
              this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
              this.transitionTo(this.STATE.FINAL);
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      LOGGED_IN_SENDING_INITIAL_SQL: {
        name: "LoggedInSendingInitialSql",
        enter: function() {
          (async () => {
            this.sendInitialSql();
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const tokenStreamParser = this.createTokenStreamParser(message, new _handler.InitialSqlTokenHandler(this));
            await (0, _events.once)(tokenStreamParser, "end");
            this.transitionTo(this.STATE.LOGGED_IN);
            this.processedInitialSql();
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function socketError() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      LOGGED_IN: {
        name: "LoggedIn",
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_CLIENT_REQUEST: {
        name: "SentClientRequest",
        enter: function() {
          (async (_this$request, _this$request3, _this$request10) => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            this.clearRequestTimer();
            const tokenStreamParser = this.createTokenStreamParser(message, new _handler.RequestTokenHandler(this, this.request));
            if ((_this$request = this.request) !== null && _this$request !== void 0 && _this$request.canceled && this.cancelTimer) {
              return this.transitionTo(this.STATE.SENT_ATTENTION);
            }
            const onResume = () => {
              tokenStreamParser.resume();
            };
            const onPause = () => {
              var _this$request2;
              tokenStreamParser.pause();
              (_this$request2 = this.request) === null || _this$request2 === void 0 ? void 0 : _this$request2.once("resume", onResume);
            };
            (_this$request3 = this.request) === null || _this$request3 === void 0 ? void 0 : _this$request3.on("pause", onPause);
            if (this.request instanceof _request.default && this.request.paused) {
              onPause();
            }
            const onCancel = () => {
              var _this$request4, _this$request5;
              tokenStreamParser.removeListener("end", onEndOfMessage);
              if (this.request instanceof _request.default && this.request.paused) {
                this.request.resume();
              }
              (_this$request4 = this.request) === null || _this$request4 === void 0 ? void 0 : _this$request4.removeListener("pause", onPause);
              (_this$request5 = this.request) === null || _this$request5 === void 0 ? void 0 : _this$request5.removeListener("resume", onResume);
              this.transitionTo(this.STATE.SENT_ATTENTION);
            };
            const onEndOfMessage = () => {
              var _this$request6, _this$request7, _this$request8, _this$request9;
              (_this$request6 = this.request) === null || _this$request6 === void 0 ? void 0 : _this$request6.removeListener("cancel", this._cancelAfterRequestSent);
              (_this$request7 = this.request) === null || _this$request7 === void 0 ? void 0 : _this$request7.removeListener("cancel", onCancel);
              (_this$request8 = this.request) === null || _this$request8 === void 0 ? void 0 : _this$request8.removeListener("pause", onPause);
              (_this$request9 = this.request) === null || _this$request9 === void 0 ? void 0 : _this$request9.removeListener("resume", onResume);
              this.transitionTo(this.STATE.LOGGED_IN);
              const sqlRequest = this.request;
              this.request = void 0;
              if (this.config.options.tdsVersion < "7_2" && sqlRequest.error && this.isSqlBatch) {
                this.inTransaction = false;
              }
              sqlRequest.callback(sqlRequest.error, sqlRequest.rowCount, sqlRequest.rows);
            };
            tokenStreamParser.once("end", onEndOfMessage);
            (_this$request10 = this.request) === null || _this$request10 === void 0 ? void 0 : _this$request10.once("cancel", onCancel);
          })();
        },
        exit: function(nextState) {
          this.clearRequestTimer();
        },
        events: {
          socketError: function(err) {
            const sqlRequest = this.request;
            this.request = void 0;
            this.transitionTo(this.STATE.FINAL);
            sqlRequest.callback(err);
          }
        }
      },
      SENT_ATTENTION: {
        name: "SentAttention",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.AttentionTokenHandler(this, this.request);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.attentionReceived) {
              this.clearCancelTimer();
              const sqlRequest = this.request;
              this.request = void 0;
              this.transitionTo(this.STATE.LOGGED_IN);
              if (sqlRequest.error && sqlRequest.error instanceof _errors.RequestError && sqlRequest.error.code === "ETIMEOUT") {
                sqlRequest.callback(sqlRequest.error);
              } else {
                sqlRequest.callback(new _errors.RequestError("Canceled.", "ECANCEL"));
              }
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function(err) {
            const sqlRequest = this.request;
            this.request = void 0;
            this.transitionTo(this.STATE.FINAL);
            sqlRequest.callback(err);
          }
        }
      },
      FINAL: {
        name: "Final",
        enter: function() {
          this.cleanupConnection(CLEANUP_TYPE.NORMAL);
        },
        events: {
          connectTimeout: function() {
          },
          message: function() {
          },
          socketError: function() {
          }
        }
      }
    };
  }
});
var require_tedious = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tedious@16.4.1/node_modules/tedious/lib/tedious.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "BulkLoad", {
      enumerable: true,
      get: function() {
        return _bulkLoad.default;
      }
    });
    Object.defineProperty(exports, "Connection", {
      enumerable: true,
      get: function() {
        return _connection.default;
      }
    });
    Object.defineProperty(exports, "ConnectionError", {
      enumerable: true,
      get: function() {
        return _errors.ConnectionError;
      }
    });
    Object.defineProperty(exports, "ISOLATION_LEVEL", {
      enumerable: true,
      get: function() {
        return _transaction.ISOLATION_LEVEL;
      }
    });
    Object.defineProperty(exports, "Request", {
      enumerable: true,
      get: function() {
        return _request.default;
      }
    });
    Object.defineProperty(exports, "RequestError", {
      enumerable: true,
      get: function() {
        return _errors.RequestError;
      }
    });
    Object.defineProperty(exports, "TDS_VERSION", {
      enumerable: true,
      get: function() {
        return _tdsVersions.versions;
      }
    });
    Object.defineProperty(exports, "TYPES", {
      enumerable: true,
      get: function() {
        return _dataType.TYPES;
      }
    });
    exports.connect = connect;
    exports.library = void 0;
    var _bulkLoad = _interopRequireDefault(require_bulk_load());
    var _connection = _interopRequireDefault(require_connection());
    var _request = _interopRequireDefault(require_request2());
    var _library = require_library();
    var _errors = require_errors();
    var _dataType = require_data_type();
    var _transaction = require_transaction2();
    var _tdsVersions = require_tds_versions();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var library = {
      name: _library.name
    };
    exports.library = library;
    function connect(config, connectListener) {
      const connection = new _connection.default(config);
      connection.connect(connectListener);
      return connection;
    }
  }
});
var require_connection_pool2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/tedious/connection-pool.js"(exports, module2) {
    "use strict";
    var tds = require_tedious();
    var debug = (0, import_chunk_MXIGSN4X.require_src)()("mssql:tedi");
    var BaseConnectionPool = require_connection_pool();
    var { IDS } = require_utils2();
    var shared = require_shared();
    var ConnectionError = require_connection_error();
    var ConnectionPool = class extends BaseConnectionPool {
      _config() {
        const cfg = {
          server: this.config.server,
          options: Object.assign({
            encrypt: typeof this.config.encrypt === "boolean" ? this.config.encrypt : true,
            trustServerCertificate: typeof this.config.trustServerCertificate === "boolean" ? this.config.trustServerCertificate : false
          }, this.config.options),
          authentication: Object.assign({
            type: this.config.domain !== void 0 ? "ntlm" : this.config.authentication_type !== void 0 ? this.config.authentication_type : "default",
            options: Object.entries({
              userName: this.config.user,
              password: this.config.password,
              domain: this.config.domain,
              clientId: this.config.clientId,
              clientSecret: this.config.clientSecret,
              tenantId: this.config.tenantId,
              token: this.config.token,
              msiEndpoint: this.config.msiEndpoint,
              msiSecret: this.config.msiSecret
            }).reduce((acc, [key, val]) => {
              if (typeof val !== "undefined") {
                return { ...acc, [key]: val };
              }
              return acc;
            }, {})
          }, this.config.authentication)
        };
        cfg.options.database = cfg.options.database || this.config.database;
        cfg.options.port = cfg.options.port || this.config.port;
        cfg.options.connectTimeout = cfg.options.connectTimeout ?? this.config.connectionTimeout ?? this.config.timeout ?? 15e3;
        cfg.options.requestTimeout = cfg.options.requestTimeout ?? this.config.requestTimeout ?? this.config.timeout ?? 15e3;
        cfg.options.tdsVersion = cfg.options.tdsVersion || "7_4";
        cfg.options.rowCollectionOnDone = cfg.options.rowCollectionOnDone || false;
        cfg.options.rowCollectionOnRequestCompletion = cfg.options.rowCollectionOnRequestCompletion || false;
        cfg.options.useColumnNames = cfg.options.useColumnNames || false;
        cfg.options.appName = cfg.options.appName || "node-mssql";
        if (cfg.options.instanceName)
          delete cfg.options.port;
        if (isNaN(cfg.options.requestTimeout))
          cfg.options.requestTimeout = 15e3;
        if (cfg.options.requestTimeout === Infinity || cfg.options.requestTimeout < 0)
          cfg.options.requestTimeout = 0;
        if (!cfg.options.debug && this.config.debug) {
          cfg.options.debug = {
            packet: true,
            token: true,
            data: true,
            payload: true
          };
        }
        return cfg;
      }
      _poolCreate() {
        return new shared.Promise((resolve, reject) => {
          const resolveOnce = (v) => {
            resolve(v);
            resolve = reject = () => {
            };
          };
          const rejectOnce = (e) => {
            reject(e);
            resolve = reject = () => {
            };
          };
          let tedious;
          try {
            tedious = new tds.Connection(this._config());
          } catch (err) {
            rejectOnce(err);
            return;
          }
          tedious.connect((err) => {
            if (err) {
              err = new ConnectionError(err);
              return rejectOnce(err);
            }
            debug("connection(%d): established", IDS.get(tedious));
            this.collation = tedious.databaseCollation;
            resolveOnce(tedious);
          });
          IDS.add(tedious, "Connection");
          debug("pool(%d): connection #%d created", IDS.get(this), IDS.get(tedious));
          debug("connection(%d): establishing", IDS.get(tedious));
          tedious.on("end", () => {
            const err = new ConnectionError("The connection ended without ever completing the connection");
            rejectOnce(err);
          });
          tedious.on("error", (err) => {
            if (err.code === "ESOCKET") {
              tedious.hasError = true;
            } else {
              this.emit("error", err);
            }
            rejectOnce(err);
          });
          if (this.config.debug) {
            tedious.on("debug", this.emit.bind(this, "debug", tedious));
          }
          if (typeof this.config.beforeConnect === "function") {
            this.config.beforeConnect(tedious);
          }
        });
      }
      _poolValidate(tedious) {
        if (tedious && !tedious.closed && !tedious.hasError) {
          return !this.config.validateConnection || new shared.Promise((resolve) => {
            const req = new tds.Request("SELECT 1;", (err) => {
              resolve(!err);
            });
            tedious.execSql(req);
          });
        }
        return false;
      }
      _poolDestroy(tedious) {
        return new shared.Promise((resolve, reject) => {
          if (!tedious) {
            resolve();
            return;
          }
          debug("connection(%d): destroying", IDS.get(tedious));
          if (tedious.closed) {
            debug("connection(%d): already closed", IDS.get(tedious));
            resolve();
          } else {
            tedious.once("end", () => {
              debug("connection(%d): destroyed", IDS.get(tedious));
              resolve();
            });
            tedious.close();
          }
        });
      }
    };
    module2.exports = ConnectionPool;
  }
});
var require_transaction3 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/tedious/transaction.js"(exports, module2) {
    "use strict";
    var debug = (0, import_chunk_MXIGSN4X.require_src)()("mssql:tedi");
    var BaseTransaction = require_transaction();
    var { IDS } = require_utils2();
    var TransactionError = require_transaction_error();
    var Transaction = class extends BaseTransaction {
      constructor(parent) {
        super(parent);
        this._abort = () => {
          if (!this._rollbackRequested) {
            const pc = this._acquiredConnection;
            setImmediate(this.parent.release.bind(this.parent), pc);
            this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
            this._acquiredConnection = null;
            this._acquiredConfig = null;
            this._aborted = true;
            this.emit("rollback", true);
          }
        };
      }
      _begin(isolationLevel, callback) {
        super._begin(isolationLevel, (err) => {
          if (err)
            return callback(err);
          debug("transaction(%d): begin", IDS.get(this));
          this.parent.acquire(this, (err2, connection, config) => {
            if (err2)
              return callback(err2);
            this._acquiredConnection = connection;
            this._acquiredConnection.on("rollbackTransaction", this._abort);
            this._acquiredConfig = config;
            connection.beginTransaction((err3) => {
              if (err3)
                err3 = new TransactionError(err3);
              debug("transaction(%d): begun", IDS.get(this));
              callback(err3);
            }, this.name, this.isolationLevel);
          });
        });
      }
      _commit(callback) {
        super._commit((err) => {
          if (err)
            return callback(err);
          debug("transaction(%d): commit", IDS.get(this));
          this._acquiredConnection.commitTransaction((err2) => {
            if (err2)
              err2 = new TransactionError(err2);
            this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
            this.parent.release(this._acquiredConnection);
            this._acquiredConnection = null;
            this._acquiredConfig = null;
            if (!err2)
              debug("transaction(%d): commited", IDS.get(this));
            callback(err2);
          });
        });
      }
      _rollback(callback) {
        super._rollback((err) => {
          if (err)
            return callback(err);
          debug("transaction(%d): rollback", IDS.get(this));
          this._acquiredConnection.rollbackTransaction((err2) => {
            if (err2)
              err2 = new TransactionError(err2);
            this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
            this.parent.release(this._acquiredConnection);
            this._acquiredConnection = null;
            this._acquiredConfig = null;
            if (!err2)
              debug("transaction(%d): rolled back", IDS.get(this));
            callback(err2);
          });
        });
      }
    };
    module2.exports = Transaction;
  }
});
var require_udt2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/udt.js"(exports, module2) {
    "use strict";
    var Point = class {
      constructor() {
        this.x = 0;
        this.y = 0;
        this.z = null;
        this.m = null;
      }
    };
    var parsePoints = (buffer, count, isGeometryPoint) => {
      const points = [];
      if (count < 1) {
        return points;
      }
      if (isGeometryPoint) {
        for (let i = 1; i <= count; i++) {
          const point = new Point();
          points.push(point);
          point.x = buffer.readDoubleLE(buffer.position);
          point.y = buffer.readDoubleLE(buffer.position + 8);
          buffer.position += 16;
        }
      } else {
        for (let i = 1; i <= count; i++) {
          const point = new Point();
          points.push(point);
          point.lat = buffer.readDoubleLE(buffer.position);
          point.lng = buffer.readDoubleLE(buffer.position + 8);
          point.x = point.lat;
          point.y = point.lng;
          buffer.position += 16;
        }
      }
      return points;
    };
    var parseZ = (buffer, points) => {
      if (points < 1) {
        return;
      }
      points.forEach((point) => {
        point.z = buffer.readDoubleLE(buffer.position);
        buffer.position += 8;
      });
    };
    var parseM = (buffer, points) => {
      if (points < 1) {
        return;
      }
      points.forEach((point) => {
        point.m = buffer.readDoubleLE(buffer.position);
        buffer.position += 8;
      });
    };
    var parseFigures = (buffer, count, properties) => {
      const figures = [];
      if (count < 1) {
        return figures;
      }
      if (properties.P) {
        figures.push({
          attribute: 1,
          pointOffset: 0
        });
      } else if (properties.L) {
        figures.push({
          attribute: 1,
          pointOffset: 0
        });
      } else {
        for (let i = 1; i <= count; i++) {
          figures.push({
            attribute: buffer.readUInt8(buffer.position),
            pointOffset: buffer.readInt32LE(buffer.position + 1)
          });
          buffer.position += 5;
        }
      }
      return figures;
    };
    var parseShapes = (buffer, count, properties) => {
      const shapes = [];
      if (count < 1) {
        return shapes;
      }
      if (properties.P) {
        shapes.push({
          parentOffset: -1,
          figureOffset: 0,
          type: 1
        });
      } else if (properties.L) {
        shapes.push({
          parentOffset: -1,
          figureOffset: 0,
          type: 2
        });
      } else {
        for (let i = 1; i <= count; i++) {
          shapes.push({
            parentOffset: buffer.readInt32LE(buffer.position),
            figureOffset: buffer.readInt32LE(buffer.position + 4),
            type: buffer.readUInt8(buffer.position + 8)
          });
          buffer.position += 9;
        }
      }
      return shapes;
    };
    var parseSegments = (buffer, count) => {
      const segments = [];
      if (count < 1) {
        return segments;
      }
      for (let i = 1; i <= count; i++) {
        segments.push({ type: buffer.readUInt8(buffer.position) });
        buffer.position++;
      }
      return segments;
    };
    var parseGeography = (buffer, isUsingGeometryPoints) => {
      const srid = buffer.readInt32LE(0);
      if (srid === -1) {
        return null;
      }
      const value = {
        srid,
        version: buffer.readUInt8(4)
      };
      const flags = buffer.readUInt8(5);
      buffer.position = 6;
      const properties = {
        Z: (flags & 1 << 0) > 0,
        M: (flags & 1 << 1) > 0,
        V: (flags & 1 << 2) > 0,
        P: (flags & 1 << 3) > 0,
        L: (flags & 1 << 4) > 0
      };
      if (value.version === 2) {
        properties.H = (flags & 1 << 3) > 0;
      }
      let numberOfPoints;
      if (properties.P) {
        numberOfPoints = 1;
      } else if (properties.L) {
        numberOfPoints = 2;
      } else {
        numberOfPoints = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
      }
      value.points = parsePoints(buffer, numberOfPoints, isUsingGeometryPoints);
      if (properties.Z) {
        parseZ(buffer, value.points);
      }
      if (properties.M) {
        parseM(buffer, value.points);
      }
      let numberOfFigures;
      if (properties.P) {
        numberOfFigures = 1;
      } else if (properties.L) {
        numberOfFigures = 1;
      } else {
        numberOfFigures = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
      }
      value.figures = parseFigures(buffer, numberOfFigures, properties);
      let numberOfShapes;
      if (properties.P) {
        numberOfShapes = 1;
      } else if (properties.L) {
        numberOfShapes = 1;
      } else {
        numberOfShapes = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
      }
      value.shapes = parseShapes(buffer, numberOfShapes, properties);
      if (value.version === 2 && buffer.position < buffer.length) {
        const numberOfSegments = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
        value.segments = parseSegments(buffer, numberOfSegments);
      } else {
        value.segments = [];
      }
      return value;
    };
    module2.exports.PARSERS = {
      geography(buffer) {
        return parseGeography(
          buffer,
          /* isUsingGeometryPoints: */
          false
        );
      },
      geometry(buffer) {
        return parseGeography(
          buffer,
          /* isUsingGeometryPoints: */
          true
        );
      }
    };
  }
});
var require_request3 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/tedious/request.js"(exports, module2) {
    "use strict";
    var tds = require_tedious();
    var debug = (0, import_chunk_MXIGSN4X.require_src)()("mssql:tedi");
    var BaseRequest = require_request();
    var RequestError = require_request_error();
    var { IDS, objectHasProperty } = require_utils2();
    var { TYPES, DECLARATIONS, declare, cast } = require_datatypes();
    var Table = require_table();
    var { PARSERS: UDT } = require_udt2();
    var { valueHandler } = require_shared();
    var JSON_COLUMN_ID = "JSON_F52E2B61-18A1-11d1-B105-00805F49916B";
    var XML_COLUMN_ID = "XML_F52E2B61-18A1-11d1-B105-00805F49916B";
    var N_TYPES = {
      BitN: 104,
      DateTimeN: 111,
      DecimalN: 106,
      FloatN: 109,
      IntN: 38,
      MoneyN: 110,
      NumericN: 108
    };
    var getTediousType = function(type2) {
      switch (type2) {
        case TYPES.VarChar:
          return tds.TYPES.VarChar;
        case TYPES.NVarChar:
          return tds.TYPES.NVarChar;
        case TYPES.Text:
          return tds.TYPES.Text;
        case TYPES.Int:
          return tds.TYPES.Int;
        case TYPES.BigInt:
          return tds.TYPES.BigInt;
        case TYPES.TinyInt:
          return tds.TYPES.TinyInt;
        case TYPES.SmallInt:
          return tds.TYPES.SmallInt;
        case TYPES.Bit:
          return tds.TYPES.Bit;
        case TYPES.Float:
          return tds.TYPES.Float;
        case TYPES.Decimal:
          return tds.TYPES.Decimal;
        case TYPES.Numeric:
          return tds.TYPES.Numeric;
        case TYPES.Real:
          return tds.TYPES.Real;
        case TYPES.Money:
          return tds.TYPES.Money;
        case TYPES.SmallMoney:
          return tds.TYPES.SmallMoney;
        case TYPES.Time:
          return tds.TYPES.Time;
        case TYPES.Date:
          return tds.TYPES.Date;
        case TYPES.DateTime:
          return tds.TYPES.DateTime;
        case TYPES.DateTime2:
          return tds.TYPES.DateTime2;
        case TYPES.DateTimeOffset:
          return tds.TYPES.DateTimeOffset;
        case TYPES.SmallDateTime:
          return tds.TYPES.SmallDateTime;
        case TYPES.UniqueIdentifier:
          return tds.TYPES.UniqueIdentifier;
        case TYPES.Xml:
          return tds.TYPES.NVarChar;
        case TYPES.Char:
          return tds.TYPES.Char;
        case TYPES.NChar:
          return tds.TYPES.NChar;
        case TYPES.NText:
          return tds.TYPES.NVarChar;
        case TYPES.Image:
          return tds.TYPES.Image;
        case TYPES.Binary:
          return tds.TYPES.Binary;
        case TYPES.VarBinary:
          return tds.TYPES.VarBinary;
        case TYPES.UDT:
        case TYPES.Geography:
        case TYPES.Geometry:
          return tds.TYPES.UDT;
        case TYPES.TVP:
          return tds.TYPES.TVP;
        case TYPES.Variant:
          return tds.TYPES.Variant;
        default:
          return type2;
      }
    };
    var getMssqlType = function(type2, length) {
      if (typeof type2 !== "object")
        return void 0;
      switch (type2) {
        case tds.TYPES.Char:
          return TYPES.Char;
        case tds.TYPES.NChar:
          return TYPES.NChar;
        case tds.TYPES.VarChar:
          return TYPES.VarChar;
        case tds.TYPES.NVarChar:
          return TYPES.NVarChar;
        case tds.TYPES.Text:
          return TYPES.Text;
        case tds.TYPES.NText:
          return TYPES.NText;
        case tds.TYPES.Int:
          return TYPES.Int;
        case tds.TYPES.BigInt:
          return TYPES.BigInt;
        case tds.TYPES.TinyInt:
          return TYPES.TinyInt;
        case tds.TYPES.SmallInt:
          return TYPES.SmallInt;
        case tds.TYPES.Bit:
          return TYPES.Bit;
        case tds.TYPES.Float:
          return TYPES.Float;
        case tds.TYPES.Real:
          return TYPES.Real;
        case tds.TYPES.Money:
          return TYPES.Money;
        case tds.TYPES.SmallMoney:
          return TYPES.SmallMoney;
        case tds.TYPES.Numeric:
          return TYPES.Numeric;
        case tds.TYPES.Decimal:
          return TYPES.Decimal;
        case tds.TYPES.DateTime:
          return TYPES.DateTime;
        case tds.TYPES.Time:
          return TYPES.Time;
        case tds.TYPES.Date:
          return TYPES.Date;
        case tds.TYPES.DateTime2:
          return TYPES.DateTime2;
        case tds.TYPES.DateTimeOffset:
          return TYPES.DateTimeOffset;
        case tds.TYPES.SmallDateTime:
          return TYPES.SmallDateTime;
        case tds.TYPES.UniqueIdentifier:
          return TYPES.UniqueIdentifier;
        case tds.TYPES.Image:
          return TYPES.Image;
        case tds.TYPES.Binary:
          return TYPES.Binary;
        case tds.TYPES.VarBinary:
          return TYPES.VarBinary;
        case tds.TYPES.Xml:
          return TYPES.Xml;
        case tds.TYPES.UDT:
          return TYPES.UDT;
        case tds.TYPES.TVP:
          return TYPES.TVP;
        case tds.TYPES.Variant:
          return TYPES.Variant;
        default:
          switch (type2.id) {
            case N_TYPES.BitN:
              return TYPES.Bit;
            case N_TYPES.NumericN:
              return TYPES.Numeric;
            case N_TYPES.DecimalN:
              return TYPES.Decimal;
            case N_TYPES.IntN:
              if (length === 8)
                return TYPES.BigInt;
              if (length === 4)
                return TYPES.Int;
              if (length === 2)
                return TYPES.SmallInt;
              return TYPES.TinyInt;
            case N_TYPES.FloatN:
              if (length === 8)
                return TYPES.Float;
              return TYPES.Real;
            case N_TYPES.MoneyN:
              if (length === 8)
                return TYPES.Money;
              return TYPES.SmallMoney;
            case N_TYPES.DateTimeN:
              if (length === 8)
                return TYPES.DateTime;
              return TYPES.SmallDateTime;
          }
      }
    };
    var createColumns = function(metadata, arrayRowMode) {
      let out = {};
      if (arrayRowMode)
        out = [];
      for (let index = 0, length = metadata.length; index < length; index++) {
        const column = metadata[index];
        const outColumn = {
          index,
          name: column.colName,
          length: column.dataLength,
          type: getMssqlType(column.type, column.dataLength),
          scale: column.scale,
          precision: column.precision,
          nullable: !!(column.flags & 1),
          caseSensitive: !!(column.flags & 2),
          identity: !!(column.flags & 16),
          readOnly: !(column.flags & 12)
        };
        if (column.udtInfo) {
          outColumn.udt = {
            name: column.udtInfo.typeName,
            database: column.udtInfo.dbname,
            schema: column.udtInfo.owningSchema,
            assembly: column.udtInfo.assemblyName
          };
          if (DECLARATIONS[column.udtInfo.typeName]) {
            outColumn.type = DECLARATIONS[column.udtInfo.typeName];
          }
        }
        if (arrayRowMode) {
          out.push(outColumn);
        } else {
          out[column.colName] = outColumn;
        }
      }
      return out;
    };
    var valueCorrection = function(value, metadata) {
      const type2 = getMssqlType(metadata.type);
      if (valueHandler.has(type2)) {
        return valueHandler.get(type2)(value);
      } else if (metadata.type === tds.TYPES.UDT && value != null) {
        if (UDT[metadata.udtInfo.typeName]) {
          return UDT[metadata.udtInfo.typeName](value);
        } else {
          return value;
        }
      } else {
        return value;
      }
    };
    var parameterCorrection = function(value) {
      if (value instanceof Table) {
        const tvp = {
          name: value.name,
          schema: value.schema,
          columns: [],
          rows: value.rows
        };
        for (const col of value.columns) {
          tvp.columns.push({
            name: col.name,
            type: getTediousType(col.type),
            length: col.length,
            scale: col.scale,
            precision: col.precision
          });
        }
        return tvp;
      } else {
        return value;
      }
    };
    var Request = class extends BaseRequest {
      /*
      Execute specified sql batch.
      */
      _batch(batch, callback) {
        this._isBatch = true;
        this._query(batch, callback);
      }
      /*
      Bulk load.
      */
      _bulk(table, options, callback) {
        super._bulk(table, options, (err) => {
          if (err)
            return callback(err);
          try {
            table._makeBulk();
          } catch (e) {
            return callback(new RequestError(e, "EREQUEST"));
          }
          if (!table.name) {
            return callback(new RequestError("Table name must be specified for bulk insert.", "ENAME"));
          }
          if (table.name.charAt(0) === "@") {
            return callback(new RequestError("You can't use table variables for bulk insert.", "ENAME"));
          }
          const errors = [];
          const errorHandlers = {};
          let hasReturned = false;
          const handleError = (doReturn, connection, info) => {
            let err2 = new Error(info.message);
            err2.info = info;
            err2 = new RequestError(err2, "EREQUEST");
            if (this.stream) {
              this.emit("error", err2);
            } else {
              if (doReturn && !hasReturned) {
                if (connection) {
                  for (const event in errorHandlers) {
                    connection.removeListener(event, errorHandlers[event]);
                  }
                  this.parent.release(connection);
                }
                hasReturned = true;
                callback(err2);
              }
            }
            errors.push(err2);
          };
          const handleInfo = (msg) => {
            this.emit("info", {
              message: msg.message,
              number: msg.number,
              state: msg.state,
              class: msg.class,
              lineNumber: msg.lineNumber,
              serverName: msg.serverName,
              procName: msg.procName
            });
          };
          this.parent.acquire(this, (err2, connection) => {
            const callbackWithRelease = (err3, ...args) => {
              try {
                this.parent.release(connection);
              } catch (e) {
              }
              callback(err3, ...args);
            };
            if (err2)
              return callbackWithRelease(err2);
            debug("connection(%d): borrowed to request #%d", IDS.get(connection), IDS.get(this));
            if (this.canceled) {
              debug("request(%d): canceled", IDS.get(this));
              return callbackWithRelease(new RequestError("Canceled.", "ECANCEL"));
            }
            this._cancel = () => {
              debug("request(%d): cancel", IDS.get(this));
              connection.cancel();
            };
            connection.on("infoMessage", errorHandlers.infoMessage = handleInfo);
            connection.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection));
            connection.on("error", errorHandlers.error = handleError.bind(null, true, connection));
            const done = (err3, rowCount) => {
              if (err3 && (!errors.length || errors.length && err3.message !== errors[errors.length - 1].message)) {
                err3 = new RequestError(err3, "EREQUEST");
                if (this.stream)
                  this.emit("error", err3);
                errors.push(err3);
              }
              delete this._cancel;
              let error;
              if (errors.length && !this.stream) {
                error = errors.pop();
                error.precedingErrors = errors;
              }
              if (!hasReturned) {
                for (const event in errorHandlers) {
                  connection.removeListener(event, errorHandlers[event]);
                }
                hasReturned = true;
                if (this.stream) {
                  callbackWithRelease(null, rowCount);
                } else {
                  callbackWithRelease(error, rowCount);
                }
              }
            };
            const bulk = connection.newBulkLoad(table.path, options, done);
            for (const col of table.columns) {
              bulk.addColumn(col.name, getTediousType(col.type), { nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision });
            }
            if (table.create) {
              const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path;
              const req = new tds.Request(`if object_id('${objectid.replace(/'/g, "''")}') is null ${table.declare()}`, (err3) => {
                if (err3)
                  return done(err3);
                connection.execBulkLoad(bulk, table.rows);
              });
              this._setCurrentRequest(req);
              connection.execSqlBatch(req);
            } else {
              connection.execBulkLoad(bulk, table.rows);
            }
          });
        });
      }
      /*
      Execute specified sql command.
      */
      _query(command, callback) {
        super._query(command, (err) => {
          if (err)
            return callback(err);
          const recordsets = [];
          const recordsetcolumns = [];
          const errors = [];
          const errorHandlers = {};
          const output = {};
          const rowsAffected = [];
          let columns = {};
          let recordset = [];
          let batchLastRow = null;
          let batchHasOutput = false;
          let isChunkedRecordset = false;
          let chunksBuffer = null;
          let hasReturned = false;
          const handleError = (doReturn, connection, info) => {
            let err2 = new Error(info.message);
            err2.info = info;
            err2 = new RequestError(err2, "EREQUEST");
            if (this.stream) {
              this.emit("error", err2);
            } else {
              if (doReturn && !hasReturned) {
                if (connection) {
                  for (const event in errorHandlers) {
                    connection.removeListener(event, errorHandlers[event]);
                  }
                  this.parent.release(connection);
                }
                hasReturned = true;
                callback(err2);
              }
            }
            errors.push(err2);
          };
          const handleInfo = (msg) => {
            this.emit("info", {
              message: msg.message,
              number: msg.number,
              state: msg.state,
              class: msg.class,
              lineNumber: msg.lineNumber,
              serverName: msg.serverName,
              procName: msg.procName
            });
          };
          this.parent.acquire(this, (err2, connection, config) => {
            if (err2)
              return callback(err2);
            debug("connection(%d): borrowed to request #%d", IDS.get(connection), IDS.get(this));
            let row;
            if (this.canceled) {
              debug("request(%d): canceled", IDS.get(this));
              this.parent.release(connection);
              return callback(new RequestError("Canceled.", "ECANCEL"));
            }
            this._cancel = () => {
              debug("request(%d): cancel", IDS.get(this));
              connection.cancel();
            };
            connection.on("infoMessage", errorHandlers.infoMessage = handleInfo);
            connection.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection));
            connection.on("error", errorHandlers.error = handleError.bind(null, true, connection));
            debug("request(%d): query", IDS.get(this), command);
            const req = new tds.Request(command, (err3) => {
              (err3?.errors ? err3.errors : [err3]).forEach((e, i, { length }) => {
                if (e && (!errors.length || errors.length && errors.length >= length && e.message !== errors[errors.length - length + i].message)) {
                  e = new RequestError(e, "EREQUEST");
                  if (this.stream)
                    this.emit("error", e);
                  errors.push(e);
                }
              });
              if (batchHasOutput) {
                if (!this.stream)
                  batchLastRow = recordsets.pop()[0];
                for (const name3 in batchLastRow) {
                  const value = batchLastRow[name3];
                  if (name3 !== "___return___") {
                    output[name3] = value;
                  }
                }
              }
              delete this._cancel;
              let error;
              if (errors.length && !this.stream) {
                error = errors.pop();
                error.precedingErrors = errors;
              }
              if (!hasReturned) {
                for (const event in errorHandlers) {
                  connection.removeListener(event, errorHandlers[event]);
                }
                this.parent.release(connection);
                hasReturned = true;
                if (error) {
                  debug("request(%d): failed", IDS.get(this), error);
                } else {
                  debug("request(%d): completed", IDS.get(this));
                }
                if (this.stream) {
                  callback(null, null, output, rowsAffected, recordsetcolumns);
                } else {
                  callback(error, recordsets, output, rowsAffected, recordsetcolumns);
                }
              }
            });
            this._setCurrentRequest(req);
            req.on("columnMetadata", (metadata) => {
              columns = createColumns(metadata, this.arrayRowMode);
              isChunkedRecordset = false;
              if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {
                isChunkedRecordset = true;
                chunksBuffer = [];
              }
              if (this.stream) {
                if (this._isBatch) {
                  if (!columns.___return___) {
                    this.emit("recordset", columns);
                  }
                } else {
                  this.emit("recordset", columns);
                }
              }
              if (this.arrayRowMode)
                recordsetcolumns.push(columns);
            });
            const doneHandler = (rowCount, more) => {
              if (rowCount != null) {
                rowsAffected.push(rowCount);
                if (this.stream) {
                  this.emit("rowsaffected", rowCount);
                }
              }
              if (Object.keys(columns).length === 0)
                return;
              if (isChunkedRecordset) {
                const concatenatedChunks = chunksBuffer.join("");
                if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {
                  try {
                    if (concatenatedChunks === "") {
                      row = null;
                    } else {
                      row = JSON.parse(concatenatedChunks);
                    }
                  } catch (ex) {
                    row = null;
                    const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), "EJSON");
                    if (this.stream)
                      this.emit("error", ex2);
                    errors.push(ex2);
                  }
                } else {
                  row = {};
                  row[Object.keys(columns)[0]] = concatenatedChunks;
                }
                chunksBuffer = null;
                if (this.stream) {
                  this.emit("row", row);
                } else {
                  recordset.push(row);
                }
              }
              if (!this.stream) {
                Object.defineProperty(recordset, "columns", {
                  enumerable: false,
                  configurable: true,
                  value: columns
                });
                Object.defineProperty(recordset, "toTable", {
                  enumerable: false,
                  configurable: true,
                  value(name3) {
                    return Table.fromRecordset(this, name3);
                  }
                });
                recordsets.push(recordset);
              }
              recordset = [];
              columns = {};
            };
            req.on("doneInProc", doneHandler);
            req.on("done", doneHandler);
            req.on("returnValue", (parameterName, value, metadata) => {
              output[parameterName] = value;
            });
            req.on("row", (columns2) => {
              if (!recordset)
                recordset = [];
              if (isChunkedRecordset) {
                return chunksBuffer.push(columns2[0].value);
              }
              if (this.arrayRowMode) {
                row = [];
              } else {
                row = {};
              }
              for (const col of columns2) {
                col.value = valueCorrection(col.value, col.metadata);
                if (this.arrayRowMode) {
                  row.push(col.value);
                } else {
                  const exi = row[col.metadata.colName];
                  if (exi !== void 0) {
                    if (exi instanceof Array) {
                      exi.push(col.value);
                    } else {
                      row[col.metadata.colName] = [exi, col.value];
                    }
                  } else {
                    row[col.metadata.colName] = col.value;
                  }
                }
              }
              if (this.stream) {
                if (this._isBatch) {
                  if (row.___return___) {
                    batchLastRow = row;
                  } else {
                    this.emit("row", row);
                  }
                } else {
                  this.emit("row", row);
                }
              } else {
                recordset.push(row);
              }
            });
            if (this._isBatch) {
              if (Object.keys(this.parameters).length) {
                for (const name3 in this.parameters) {
                  if (!objectHasProperty(this.parameters, name3)) {
                    continue;
                  }
                  const param = this.parameters[name3];
                  try {
                    param.value = getTediousType(param.type).validate(param.value, this.parent.collation);
                  } catch (e) {
                    e.message = `Validation failed for parameter '${name3}'. ${e.message}`;
                    const err3 = new RequestError(e, "EPARAM");
                    this.parent.release(connection);
                    return callback(err3);
                  }
                }
                const declarations = [];
                for (const name3 in this.parameters) {
                  if (!objectHasProperty(this.parameters, name3)) {
                    continue;
                  }
                  const param = this.parameters[name3];
                  declarations.push(`@${name3} ${declare(param.type, param)}`);
                }
                const assigns = [];
                for (const name3 in this.parameters) {
                  if (!objectHasProperty(this.parameters, name3)) {
                    continue;
                  }
                  const param = this.parameters[name3];
                  assigns.push(`@${name3} = ${cast(param.value, param.type, param)}`);
                }
                const selects = [];
                for (const name3 in this.parameters) {
                  if (!objectHasProperty(this.parameters, name3)) {
                    continue;
                  }
                  const param = this.parameters[name3];
                  if (param.io === 2) {
                    selects.push(`@${name3} as [${name3}]`);
                  }
                }
                batchHasOutput = selects.length > 0;
                req.sqlTextOrProcedure = `declare ${declarations.join(", ")};select ${assigns.join(", ")};${req.sqlTextOrProcedure};${batchHasOutput ? `select 1 as [___return___], ${selects.join(", ")}` : ""}`;
              }
            } else {
              for (const name3 in this.parameters) {
                if (!objectHasProperty(this.parameters, name3)) {
                  continue;
                }
                const param = this.parameters[name3];
                if (param.io === 1) {
                  req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
                } else {
                  req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
                }
              }
            }
            try {
              connection[this._isBatch ? "execSqlBatch" : "execSql"](req);
            } catch (error) {
              handleError(true, connection, error);
            }
          });
        });
      }
      /*
      Execute stored procedure with specified parameters.
      */
      _execute(procedure, callback) {
        super._execute(procedure, (err) => {
          if (err)
            return callback(err);
          const recordsets = [];
          const recordsetcolumns = [];
          const errors = [];
          const errorHandlers = {};
          const output = {};
          const rowsAffected = [];
          let columns = {};
          let recordset = [];
          let returnValue = 0;
          let isChunkedRecordset = false;
          let chunksBuffer = null;
          let hasReturned = false;
          const handleError = (doReturn, connection, info) => {
            let err2 = new Error(info.message);
            err2.info = info;
            err2 = new RequestError(err2, "EREQUEST");
            if (this.stream) {
              this.emit("error", err2);
            } else {
              if (doReturn && !hasReturned) {
                if (connection) {
                  for (const event in errorHandlers) {
                    connection.removeListener(event, errorHandlers[event]);
                  }
                  this.parent.release(connection);
                }
                hasReturned = true;
                callback(err2);
              }
            }
            errors.push(err2);
          };
          const handleInfo = (msg) => {
            this.emit("info", {
              message: msg.message,
              number: msg.number,
              state: msg.state,
              class: msg.class,
              lineNumber: msg.lineNumber,
              serverName: msg.serverName,
              procName: msg.procName
            });
          };
          this.parent.acquire(this, (err2, connection, config) => {
            if (err2)
              return callback(err2);
            debug("connection(%d): borrowed to request #%d", IDS.get(connection), IDS.get(this));
            let row;
            if (this.canceled) {
              debug("request(%d): canceled", IDS.get(this));
              this.parent.release(connection);
              return callback(new RequestError("Canceled.", "ECANCEL"));
            }
            this._cancel = () => {
              debug("request(%d): cancel", IDS.get(this));
              connection.cancel();
            };
            connection.on("infoMessage", errorHandlers.infoMessage = handleInfo);
            connection.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection));
            connection.on("error", errorHandlers.error = handleError.bind(null, true, connection));
            if (debug.enabled) {
              const params = Object.keys(this.parameters).map((k) => this.parameters[k]);
              const logValue = (s) => typeof s === "string" && s.length > 50 ? s.substring(0, 47) + "..." : s;
              const logName = (param) => param.name + " [sql." + param.type.name + "]";
              const logParams = {};
              params.forEach((p) => {
                logParams[logName(p)] = logValue(p.value);
              });
              debug("request(%d): execute %s %O", IDS.get(this), procedure, logParams);
            }
            const req = new tds.Request(procedure, (err3) => {
              if (err3 && (!errors.length || errors.length && err3.message !== errors[errors.length - 1].message)) {
                err3 = new RequestError(err3, "EREQUEST");
                if (this.stream)
                  this.emit("error", err3);
                errors.push(err3);
              }
              delete this._cancel;
              let error;
              if (errors.length && !this.stream) {
                error = errors.pop();
                error.precedingErrors = errors;
              }
              if (!hasReturned) {
                for (const event in errorHandlers) {
                  connection.removeListener(event, errorHandlers[event]);
                }
                this.parent.release(connection);
                hasReturned = true;
                if (error) {
                  debug("request(%d): failed", IDS.get(this), error);
                } else {
                  debug("request(%d): complete", IDS.get(this));
                }
                if (this.stream) {
                  callback(null, null, output, returnValue, rowsAffected, recordsetcolumns);
                } else {
                  callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns);
                }
              }
            });
            this._setCurrentRequest(req);
            req.on("columnMetadata", (metadata) => {
              columns = createColumns(metadata, this.arrayRowMode);
              isChunkedRecordset = false;
              if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {
                isChunkedRecordset = true;
                chunksBuffer = [];
              }
              if (this.stream)
                this.emit("recordset", columns);
              if (this.arrayRowMode)
                recordsetcolumns.push(columns);
            });
            req.on("row", (columns2) => {
              if (!recordset)
                recordset = [];
              if (isChunkedRecordset) {
                return chunksBuffer.push(columns2[0].value);
              }
              if (this.arrayRowMode) {
                row = [];
              } else {
                row = {};
              }
              for (const col of columns2) {
                col.value = valueCorrection(col.value, col.metadata);
                if (this.arrayRowMode) {
                  row.push(col.value);
                } else {
                  const exi = row[col.metadata.colName];
                  if (exi != null) {
                    if (exi instanceof Array) {
                      exi.push(col.value);
                    } else {
                      row[col.metadata.colName] = [exi, col.value];
                    }
                  } else {
                    row[col.metadata.colName] = col.value;
                  }
                }
              }
              if (this.stream) {
                this.emit("row", row);
              } else {
                recordset.push(row);
              }
            });
            req.on("doneInProc", (rowCount, more) => {
              if (rowCount != null) {
                rowsAffected.push(rowCount);
                if (this.stream) {
                  this.emit("rowsaffected", rowCount);
                }
              }
              if (Object.keys(columns).length === 0)
                return;
              if (isChunkedRecordset) {
                if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {
                  try {
                    if (chunksBuffer.length === 0) {
                      row = null;
                    } else {
                      row = JSON.parse(chunksBuffer.join(""));
                    }
                  } catch (ex) {
                    row = null;
                    const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), "EJSON");
                    if (this.stream)
                      this.emit("error", ex2);
                    errors.push(ex2);
                  }
                } else {
                  row = {};
                  row[Object.keys(columns)[0]] = chunksBuffer.join("");
                }
                chunksBuffer = null;
                if (this.stream) {
                  this.emit("row", row);
                } else {
                  recordset.push(row);
                }
              }
              if (!this.stream) {
                Object.defineProperty(recordset, "columns", {
                  enumerable: false,
                  configurable: true,
                  value: columns
                });
                Object.defineProperty(recordset, "toTable", {
                  enumerable: false,
                  configurable: true,
                  value(name3) {
                    return Table.fromRecordset(this, name3);
                  }
                });
                recordsets.push(recordset);
              }
              recordset = [];
              columns = {};
            });
            req.on("doneProc", (rowCount, more, returnStatus) => {
              returnValue = returnStatus;
            });
            req.on("returnValue", (parameterName, value, metadata) => {
              output[parameterName] = value;
            });
            for (const name3 in this.parameters) {
              if (!objectHasProperty(this.parameters, name3)) {
                continue;
              }
              const param = this.parameters[name3];
              if (param.io === 1) {
                req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
              } else {
                req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
              }
            }
            connection.callProcedure(req);
          });
        });
      }
      _pause() {
        super._pause();
        if (this._currentRequest) {
          this._currentRequest.pause();
        }
      }
      _resume() {
        super._resume();
        if (this._currentRequest) {
          this._currentRequest.resume();
        }
      }
    };
    module2.exports = Request;
  }
});
var require_tedious2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/lib/tedious/index.js"(exports, module2) {
    "use strict";
    var base = require_base();
    var ConnectionPool = require_connection_pool2();
    var Transaction = require_transaction3();
    var Request = require_request3();
    module2.exports = Object.assign({
      ConnectionPool,
      Transaction,
      Request,
      PreparedStatement: base.PreparedStatement
    }, base.exports);
    Object.defineProperty(module2.exports, "Promise", {
      enumerable: true,
      get: () => {
        return base.Promise;
      },
      set: (value) => {
        base.Promise = value;
      }
    });
    Object.defineProperty(module2.exports, "valueHandler", {
      enumerable: true,
      value: base.valueHandler,
      writable: false,
      configurable: false
    });
    base.driver.name = "tedious";
    base.driver.ConnectionPool = ConnectionPool;
    base.driver.Transaction = Transaction;
    base.driver.Request = Request;
  }
});
var require_mssql = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/mssql@10.0.2/node_modules/mssql/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_tedious2();
  }
});
var import_mssql = (0, import_chunk_FVJ3R4NJ.__toESM)(require_mssql());
function getMSSQLConfig(url) {
  const connectionUrl = new import_url.URL(url);
  return {
    user: connectionUrl.username,
    password: connectionUrl.password,
    server: connectionUrl.hostname,
    port: Number(connectionUrl.port),
    database: connectionUrl.pathname.substring(1),
    pool: {
      max: 1
    },
    options: {
      enableArithAbort: false,
      trustServerCertificate: true
      // change to true for local dev / self-signed certs
    }
  };
}
async function setupMSSQL(options, databaseName) {
  const { connectionString } = options;
  const { dirname } = options;
  const config = getMSSQLConfig(connectionString);
  const connectionPool = new import_mssql.default.ConnectionPool(config);
  const connection = await connectionPool.connect();
  try {
    await connection.query(`
CREATE DATABASE [${databaseName}-shadowdb]
CREATE DATABASE [${databaseName}]
`);
  } catch (e) {
    console.warn(e);
  }
  if (dirname !== "") {
    let schema = `USE [${databaseName}]
`;
    schema += import_fs5.default.readFileSync(import_path2.default.join(dirname, "setup.sql"), "utf-8");
    await connection.query(schema);
  }
  await connection.close();
}
async function tearDownMSSQL(options, databaseName) {
  const { connectionString } = options;
  const config = getMSSQLConfig(connectionString);
  const connectionPool = new import_mssql.default.ConnectionPool(config);
  const connection = await connectionPool.connect();
  await connection.query(`
DROP DATABASE IF EXISTS "${databaseName}-shadowdb";
DROP DATABASE IF EXISTS "${databaseName}";
`);
  await connection.close();
}
/*! Bundled license information:

@azure/msal-common/dist/_virtual/_tslib.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@azure/msal-common/dist/utils/Constants.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/error/AuthError.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/crypto/ICrypto.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/error/ClientAuthError.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/utils/StringUtils.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/logger/Logger.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/packageMetadata.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/authority/AuthorityOptions.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/cache/entities/CredentialEntity.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/error/ClientConfigurationError.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/request/ScopeSet.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/account/ClientInfo.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/authority/AuthorityType.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/cache/entities/AccountEntity.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/account/AuthToken.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/cache/CacheManager.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/config/ClientConfiguration.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/error/ServerError.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/network/ThrottlingUtils.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/network/NetworkManager.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/account/CcsCredential.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/client/BaseClient.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/request/RequestValidator.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/request/RequestParameterBuilder.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/cache/entities/IdTokenEntity.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/utils/TimeUtils.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/cache/entities/AccessTokenEntity.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/cache/entities/RefreshTokenEntity.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/error/InteractionRequiredAuthError.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/cache/entities/CacheRecord.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/utils/ProtocolUtils.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/url/UrlString.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/crypto/PopTokenGenerator.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/cache/entities/AppMetadataEntity.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/cache/persistence/TokenCacheContext.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/response/ResponseHandler.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/client/AuthorizationCodeClient.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/client/DeviceCodeClient.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/telemetry/performance/PerformanceEvent.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/client/RefreshTokenClient.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/client/ClientCredentialClient.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/client/OnBehalfOfClient.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/client/SilentFlowClient.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/client/UsernamePasswordClient.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/authority/OpenIdConfigResponse.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/authority/AuthorityMetadata.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/authority/ProtocolMode.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/cache/entities/AuthorityMetadataEntity.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/authority/RegionDiscovery.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/authority/Authority.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/authority/AuthorityFactory.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/cache/entities/ServerTelemetryEntity.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/cache/entities/ThrottlingEntity.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

@azure/msal-common/dist/index.js:
  (*! @azure/msal-common v7.6.0 2022-10-10 *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

js-md4/src/md4.js:
  (**
   * [js-md4]{@link https://github.com/emn178/js-md4}
   *
   * @namespace md4
   * @version 0.3.2
   * @author Yi-Cyuan Chen [emn178@gmail.com]
   * @copyright Yi-Cyuan Chen 2015-2027
   * @license MIT
   *)

@js-joda/core/dist/js-joda.esm.js:
  (*! @version @js-joda/core - 5.5.3 *)
  (*! @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors *)
  (*! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos *)
  (*! @license BSD-3-Clause (see LICENSE in the root directory of this source tree) *)
  (**
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (**
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thürwächter, Pattrick Hüper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
*/
